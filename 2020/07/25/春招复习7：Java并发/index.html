<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>春招复习7：Java并发 | rnang0 Blog</title><meta name="description" content="Java并发重点学习内容 并发编程的基础 锁 原子类 线程池 JUC并发工具类 并发容器  一、并发理论基础1.1 Happends-Before规则​    Happends-Before规则规定了对共享变量的写对其它线程的读操作可见。  程序次序规则：一个线程内，按照控制流顺序，前面的操作先行发生于后面的操作。  管程锁定规则：unlock操作先行发生于后面（时间上）对这个锁的lock操作。"><meta name="keywords" content="并发,锁"><meta name="author" content="rnang0"><meta name="copyright" content="rnang0"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="春招复习7：Java并发"><meta name="twitter:description" content="Java并发重点学习内容 并发编程的基础 锁 原子类 线程池 JUC并发工具类 并发容器  一、并发理论基础1.1 Happends-Before规则​    Happends-Before规则规定了对共享变量的写对其它线程的读操作可见。  程序次序规则：一个线程内，按照控制流顺序，前面的操作先行发生于后面的操作。  管程锁定规则：unlock操作先行发生于后面（时间上）对这个锁的lock操作。"><meta name="twitter:image" content="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=4060513360,1461496884&amp;fm=26&amp;gp=0.jpg"><meta property="og:type" content="article"><meta property="og:title" content="春招复习7：Java并发"><meta property="og:url" content="http://rnang0.github.io/2020/07/25/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A07%EF%BC%9AJava%E5%B9%B6%E5%8F%91/"><meta property="og:site_name" content="rnang0 Blog"><meta property="og:description" content="Java并发重点学习内容 并发编程的基础 锁 原子类 线程池 JUC并发工具类 并发容器  一、并发理论基础1.1 Happends-Before规则​    Happends-Before规则规定了对共享变量的写对其它线程的读操作可见。  程序次序规则：一个线程内，按照控制流顺序，前面的操作先行发生于后面的操作。  管程锁定规则：unlock操作先行发生于后面（时间上）对这个锁的lock操作。"><meta property="og:image" content="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=4060513360,1461496884&amp;fm=26&amp;gp=0.jpg"><meta property="article:published_time" content="2020-07-24T16:00:00.000Z"><meta property="article:modified_time" content="2020-08-02T13:29:46.327Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="canonical" href="http://rnang0.github.io/2020/07/25/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A07%EF%BC%9AJava%E5%B9%B6%E5%8F%91/"><link rel="prev" title="春招复习8：数据库与缓存" href="http://rnang0.github.io/2020/08/03/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A08%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98/"><link rel="next" title="春招复习6：JVM" href="http://rnang0.github.io/2020/07/13/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A06%EF%BC%9AJVM/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'none',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/autor.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">41</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-mars"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java并发"><span class="toc-text">Java并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#重点学习内容"><span class="toc-text">重点学习内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一、并发理论基础"><span class="toc-text">一、并发理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Happends-Before规则"><span class="toc-text">1.1 Happends-Before规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-死锁"><span class="toc-text">1.2 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-产生死锁的条件"><span class="toc-text">1.2.1 产生死锁的条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-防止死锁"><span class="toc-text">1.2.2 防止死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-避免死锁"><span class="toc-text">1.2.3 避免死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-检测死锁"><span class="toc-text">1.2.4 检测死锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-进程与线程"><span class="toc-text">1.3 进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-进程、线程区别"><span class="toc-text">1.3.1 进程、线程区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-内核级线程"><span class="toc-text">1.3.2 内核级线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-用户级线程"><span class="toc-text">1.3.3 用户级线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-4-四种线程创建方式"><span class="toc-text">1.3.4 四种线程创建方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-线程状态"><span class="toc-text">1.4 线程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-线程状态概述"><span class="toc-text">1.4.1 线程状态概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-Timed-Waiting（计时等待）"><span class="toc-text">1.4.2 Timed Waiting（计时等待）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3-BLOCKED（锁阻塞）"><span class="toc-text">1.4.3 BLOCKED（锁阻塞）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-4-Waiting（无限等待）"><span class="toc-text">1.4.4 Waiting（无限等待）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-5-补充"><span class="toc-text">1.4.5 补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-线程调度"><span class="toc-text">1.5 线程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-三级调度"><span class="toc-text">1.5.1 三级调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-优先级调度算法（时间相关）"><span class="toc-text">1.5.2 优先级调度算法（时间相关）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-3-分级调度算法"><span class="toc-text">1.5.3 分级调度算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、锁"><span class="toc-text">二、锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-并发机制的底层实现"><span class="toc-text">2.1 并发机制的底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-Volatile的实现原理"><span class="toc-text">2.1.1 Volatile的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1-1-CAS"><span class="toc-text">2.1.1.1 CAS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1-2-原子整数"><span class="toc-text">2.1.1.2 原子整数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1-3-原子引用"><span class="toc-text">2.1.1.3 原子引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1-4-原子数组"><span class="toc-text">2.1.1.4 原子数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1-5-字段更新器"><span class="toc-text">2.1.1.5 字段更新器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1-6-原子累加器"><span class="toc-text">2.1.1.6 原子累加器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-synchronized的实现原理"><span class="toc-text">2.1.2 synchronized的实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-Lock锁"><span class="toc-text">2.1.3 Lock锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-锁升级"><span class="toc-text">2.2 锁升级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-轻量级锁"><span class="toc-text">2.2.1 轻量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-偏向锁"><span class="toc-text">2.2.2 偏向锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-悲观锁-乐观锁"><span class="toc-text">2.3 悲观锁 -乐观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-管程-悲观锁"><span class="toc-text">2.3.1 管程-悲观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-无锁并发-乐观锁"><span class="toc-text">2.3.2 无锁并发-乐观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-悲观锁-乐观锁比较"><span class="toc-text">2.3.3 悲观锁-乐观锁比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、线程池"><span class="toc-text">三、线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-线程池优势"><span class="toc-text">3.1 线程池优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-ThreadPoolExecutor"><span class="toc-text">3.2 ThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-线程池状态"><span class="toc-text">3.2.1 线程池状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-shutdown与stop区别："><span class="toc-text">3.2.2 shutdown与stop区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-线程池构造方法，参数说明"><span class="toc-text">3.2.3 线程池构造方法，参数说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-ScheduledThreadPoolExecutor"><span class="toc-text">3.2.4 ScheduledThreadPoolExecutor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-拒绝策略"><span class="toc-text">3.3 拒绝策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-Fork-Join线程池"><span class="toc-text">3.4 Fork&#x2F;Join线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、并发工具类"><span class="toc-text">四、并发工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-AQS"><span class="toc-text">4.1 AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-核心思想"><span class="toc-text">4.1.1 核心思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-AQS三要素："><span class="toc-text">4.1.2 AQS三要素：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-与synchronized的区别"><span class="toc-text">4.1.3 与synchronized的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-ReentrantLock"><span class="toc-text">4.2 ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-非公平锁实现原理"><span class="toc-text">4.2.1 非公平锁实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-可重入原理"><span class="toc-text">4.2.2 可重入原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-可打断原理"><span class="toc-text">4.2.3 可打断原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-公平锁实现原理"><span class="toc-text">4.2.4 公平锁实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-ReadWriteLock"><span class="toc-text">4.3 ReadWriteLock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-ReentrantReadWriteLock"><span class="toc-text">4.3.1 ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-StampedLock"><span class="toc-text">4.3.2 StampedLock</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-信号量"><span class="toc-text">4.4 信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-线程安全集合类"><span class="toc-text">4.5 线程安全集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-遗留的安全集合"><span class="toc-text">4.5.1 遗留的安全集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-修饰的安全集合"><span class="toc-text">4.5.2 修饰的安全集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-3-J-U-C下的并发容器"><span class="toc-text">4.5.3 J.U.C下的并发容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-ConcurrentHashMap"><span class="toc-text">4.6 ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-1-原理"><span class="toc-text">4.6.1 原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-2-ConcurrentHashMap比HashTable的优点"><span class="toc-text">4.6.2 ConcurrentHashMap比HashTable的优点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-CopyOnWriteArrayList"><span class="toc-text">4.7 CopyOnWriteArrayList</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=4060513360,1461496884&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">rnang0 Blog</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-mars"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">春招复习7：Java并发</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-25 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-07-25</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-08-02 21:29:46"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-08-02</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/">春招复习</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h1><h2 id="重点学习内容"><a href="#重点学习内容" class="headerlink" title="重点学习内容"></a>重点学习内容</h2><ul>
<li>并发编程的基础</li>
<li>锁</li>
<li>原子类</li>
<li>线程池</li>
<li>JUC并发工具类</li>
<li>并发容器</li>
</ul>
<h2 id="一、并发理论基础"><a href="#一、并发理论基础" class="headerlink" title="一、并发理论基础"></a>一、并发理论基础</h2><h3 id="1-1-Happends-Before规则"><a href="#1-1-Happends-Before规则" class="headerlink" title="1.1 Happends-Before规则"></a>1.1 Happends-Before规则</h3><p>​    Happends-Before规则规定了对共享变量的写对其它线程的读操作可见。</p>
<ul>
<li><p>程序次序规则：一个线程内，按照控制流顺序，前面的操作先行发生于后面的操作。</p>
</li>
<li><p>管程锁定规则：unlock操作先行发生于后面（时间上）对这个锁的lock操作。</p>
</li>
<li><p>Volatile规则：对一个volatile变量的写操作先行发生于后面（时间上）对这个变量的读操作。</p>
</li>
<li><p>线程：</p>
<p>线程启动规则：一个线程的start先行发生于这个线程的每一个动作。</p>
<p>线程终止规则：一个线程的所有操作先行发生于这个线程的终止检测join。</p>
<p>线程中断规则：对线程interrupt方法的调用先行发生于检测到中断事件的发生。</p>
</li>
<li><p>对象终结规则：一个对象的初始化完成先行发生于其finalize方法的开始。</p>
</li>
<li><p>传递性：若A先行发生于B，B先行发生于C，则A先行发生于C。</p>
</li>
</ul>
<p><strong>总结：</strong></p>
<p>​    一、同一线程内，按控制流顺序；</p>
<p>​    二、不同线程：</p>
<ol>
<li><p>依赖对象的：</p>
<p>volatile对象开始读，其之前的所有写一定可见；</p>
<p>对象开始执行finalize，其初始化操作一定可见；</p>
<p>对象/类被lock，其之前的unlock一定可见；</p>
</li>
<li><p>依赖线程本身的：</p>
<p>当线程开始执行操作，其start一定可见；</p>
<p>当线程可被检测为结束，其线程内所有操作一定可见；</p>
<p>当线程被中断，引发中断的事件一定可见。</p>
</li>
</ol>
<h3 id="1-2-死锁"><a href="#1-2-死锁" class="headerlink" title="1.2 死锁"></a>1.2 死锁</h3><h4 id="1-2-1-产生死锁的条件"><a href="#1-2-1-产生死锁的条件" class="headerlink" title="1.2.1 产生死锁的条件"></a>1.2.1 产生死锁的条件</h4><ol>
<li><p>互斥：一个资源同一时刻只能由一个进程占用</p>
</li>
<li><p>请求和保持：一个进程被阻塞时，不释放已有资源</p>
</li>
<li><p>不可剥夺：只有线程使用资源结束时可以释放资源</p>
</li>
<li><p>循环等待：多个线程之间形成一个互相阻塞头尾相接的等待资源关系</p>
</li>
</ol>
<h4 id="1-2-2-防止死锁"><a href="#1-2-2-防止死锁" class="headerlink" title="1.2.2 防止死锁"></a>1.2.2 防止死锁</h4><ol>
<li><p>破坏请求与保持：一次性申请所有资源</p>
</li>
<li><p>破坏不可剥夺：申请资源失败时释放已占有的资源</p>
</li>
<li><p>破坏循环等待：所有线程按相同顺序申请资源，释放反向</p>
</li>
</ol>
<h4 id="1-2-3-避免死锁"><a href="#1-2-3-避免死锁" class="headerlink" title="1.2.3 避免死锁"></a>1.2.3 避免死锁</h4><p>银行家算法（借钱给有偿还能力的客户）：</p>
<p>在为进程分配资源前预先测试系统状态。若把资源分配给进程会产生死锁，则拒绝分配。</p>
<h4 id="1-2-4-检测死锁"><a href="#1-2-4-检测死锁" class="headerlink" title="1.2.4 检测死锁"></a>1.2.4 检测死锁</h4><p>​    系统定时运行一个死锁检测程序，判断系统内是否出现死锁。若检测到死锁，则设法解除。</p>
<p>​    设计两张表：等待资源表 + 占用资源表</p>
<p>​    若有进程Pi等待资源rk，而rk被进程Pj占用，则Pi和Pj具有等待占用关系。根据上述二表，可以扫描出所有进程的等待占用关系。当等待占用关系出现首尾相接时，说明出现了死锁。</p>
<h3 id="1-3-进程与线程"><a href="#1-3-进程与线程" class="headerlink" title="1.3 进程与线程"></a>1.3 进程与线程</h3><p>进程是一个拥有一定独立功能的程序关于某个数据集合的一次运行活动</p>
<p>进程是操作系统进行资源分配和调度的一个独立单位</p>
<h4 id="1-3-1-进程、线程区别"><a href="#1-3-1-进程、线程区别" class="headerlink" title="1.3.1 进程、线程区别"></a>1.3.1 进程、线程区别</h4><p>进程作为系统资源分配和保护的独立单位，不需要频繁的切换。</p>
<p>线程作为系统调度和分派的基本单位，能轻装运行，能被频繁的调度和切换。</p>
<p>OS感知线程的环境下，处理器调度线程；不感知线程的环境下，处理器调度进程，进程中的用户调度程序调度线程。</p>
<h4 id="1-3-2-内核级线程"><a href="#1-3-2-内核级线程" class="headerlink" title="1.3.2 内核级线程"></a>1.3.2 内核级线程</h4><ol>
<li><p>线程的管理工作由OS负责；</p>
</li>
<li><p>进程中一个线程被阻塞，OS能调用同一进程的其他线程占有处理器运行；</p>
</li>
<li><p>应用程序线程运行在用户态，调度管理在内核实现，切换线程时需要模式切换，系统开销大。</p>
</li>
</ol>
<h4 id="1-3-3-用户级线程"><a href="#1-3-3-用户级线程" class="headerlink" title="1.3.3 用户级线程"></a>1.3.3 用户级线程</h4><ol>
<li>线程管理工作由应用程序完成，内核没有意识到线程的存在；</li>
<li>线程切换不需要切换模式；</li>
<li>运行进程按应用需要选择调度算法；</li>
<li>不依赖OS；</li>
<li>不能利用多处理器优点；</li>
<li>一个线程阻塞，将引起整个进程阻塞。</li>
</ol>
<p>​    <strong>混合式策略：</strong></p>
<p>​    多个用户线程与多个内核线程建立绑定关系。</p>
<h4 id="1-3-4-四种线程创建方式"><a href="#1-3-4-四种线程创建方式" class="headerlink" title="1.3.4 四种线程创建方式"></a>1.3.4 四种线程创建方式</h4><ol>
<li>继承Thread重写run</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//此处为thread执行的任务内容</span></span><br><span class="line">		System.out.println(Thread.currentThread().getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>实现Runnable接口重写run，用其实例初始化Thread<strong>（推荐使用）</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//此处为thread执行的任务内容</span></span><br><span class="line">		System.out.println(Thread.currentThread().getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread());</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么推荐使用Runnable来创建线程<ol>
<li><strong>Runnable与Thread是组合的关系，Thread的run方法，实际上就是调用的Runnable的run方法</strong></li>
<li><strong>Runnable（实际执行的任务），这种格式更容易与其他API配合，拖了Thread，灵活性强。</strong></li>
</ol>
</li>
</ul>
<ol start="3">
<li><p>实现Callable接口重写call，用其实例初始化FutureTask，用FutureTask实例初始化Thread</p>
<p><strong>只是比Runnable多个get返回值，给其他线程</strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"running..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(task, <span class="string">"t1"</span>);</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取返回值，给其他线程</span></span><br><span class="line">Integer result = task.get();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>线程池创建</li>
</ol>
<h3 id="1-4-线程状态"><a href="#1-4-线程状态" class="headerlink" title="1.4 线程状态"></a>1.4 线程状态</h3><h4 id="1-4-1-线程状态概述"><a href="#1-4-1-线程状态概述" class="headerlink" title="1.4.1 线程状态概述"></a>1.4.1 线程状态概述</h4><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在<strong>线程的生命周期</strong>中这各个<strong>线程状态</strong>发生的条件，下面将会对每种状态进行详细解析：<br><img src="https://img-blog.csdnimg.cn/20191007120702449.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（1）Runnable(可运行)<br>线程可以在java虚拟机中运行的状态，<strong>可能正在运行自己代码，也可能没有，这取决于操作系统处理器（cpu）</strong>。</p>
<p>​    <strong>Java将操作系统中线程运行和就绪合并为运行状态。</strong></p>
<p>（2）Blocked(锁阻塞)<br>当一个线程试图获取一个对象锁，<strong>而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。</strong></p>
<p>（3）Waiting(无限等待)<br>一个线程在<strong>等待另一个线程执行一个（唤醒）动作时</strong>，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，<strong>必须等待另一个线程调用notify或者notifyAll方法才能够唤醒</strong>。</p>
<p>我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几个状态呢，新建与被终止还是很容易理解的，我们就研究一下<strong>线程从Runnable（可运行）状态与非运行状态之间的转换问题</strong>。</p>
<h4 id="1-4-2-Timed-Waiting（计时等待）"><a href="#1-4-2-Timed-Waiting（计时等待）" class="headerlink" title="1.4.2 Timed Waiting（计时等待）"></a>1.4.2 Timed Waiting（计时等待）</h4><p>Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。在我们写卖票的案例中，<strong>为了减少线程执行太快，现象不明显等问题</strong>，我们在run方法中添加了<strong>sleep语句</strong>，这样就<strong>强制当前正在执行的线程休眠（暂停执行），以“减慢线程”</strong>。</p>
<p><strong>sleep就是等待。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 卖票操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//开启线程锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                String name = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name + <span class="string">"正在卖"</span> + ticket--);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//关闭线程锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们需要记住下面几点：</p>
<ol>
<li>进入 TIMED_WAITING 状态的一种常见情形是<strong>调用的 sleep 方法</strong>，单独的线程也可以调用，不一定非要有协<br>作关系。</li>
<li>为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程<br>中会睡眠</li>
<li><strong>sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态</strong>。<br><img src="https://img-blog.csdnimg.cn/20191007121725479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<h4 id="1-4-3-BLOCKED（锁阻塞）"><a href="#1-4-3-BLOCKED（锁阻塞）" class="headerlink" title="1.4.3 BLOCKED（锁阻塞）"></a>1.4.3 BLOCKED（锁阻塞）</h4><p>Blocked状态在API中的介绍为：一个正在阻塞<strong>等待一个监视器锁（锁对象）的线程</strong>处于这一状态。<br>比如，线程A与线程B代码中使用同一锁，<strong>如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。</strong><br><img src="https://img-blog.csdnimg.cn/20191007121939722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="1-4-4-Waiting（无限等待）"><a href="#1-4-4-Waiting（无限等待）" class="headerlink" title="1.4.4 Waiting（无限等待）"></a>1.4.4 Waiting（无限等待）</h4><p>一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。<br><img src="https://img-blog.csdnimg.cn/20191007123214690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入了Waiting（无限等待）状态，同时失去了同步锁。<strong>假如这个时候B线程获取到了同步锁，在运行状态中调用了notify()方法，那么就会将无限等待的A线程唤醒</strong>。注意是唤醒，如果A获取到锁对象，那么A线程唤醒后就进入Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。</p>
<h4 id="1-4-5-补充"><a href="#1-4-5-补充" class="headerlink" title="1.4.5 补充"></a>1.4.5 补充</h4><p>线程状态整体概括：<br><img src="https://img-blog.csdnimg.cn/20191007123300449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="1-5-线程调度"><a href="#1-5-线程调度" class="headerlink" title="1.5 线程调度"></a>1.5 线程调度</h3><h4 id="1-5-1-三级调度"><a href="#1-5-1-三级调度" class="headerlink" title="1.5.1 三级调度"></a>1.5.1 三级调度</h4><p>高级调度：从后备作业队列中选取作业加入主存（新建态-&gt;就绪态）</p>
<p>中级调度：进程的挂起与唤醒（挂起：使一个进程暂时失去与其他进程竞争处理器的机会）</p>
<p>低级调度：又称进程调度、短程调度、处理器调度，按照某种原则把处理器分配给就绪进程或内核级进程。</p>
<h4 id="1-5-2-优先级调度算法（时间相关）"><a href="#1-5-2-优先级调度算法（时间相关）" class="headerlink" title="1.5.2 优先级调度算法（时间相关）"></a>1.5.2 优先级调度算法（时间相关）</h4><ol>
<li><p>计算时间短优先</p>
</li>
<li><p>剩余计算时间短优先</p>
</li>
<li><p>高响应比优先（响应比 = 等待时间 / 进入时间）</p>
</li>
<li><p>先来先服务</p>
</li>
<li><p>时间片轮转调度算法（常用作先来先服务的改进）</p>
</li>
</ol>
<h4 id="1-5-3-分级调度算法"><a href="#1-5-3-分级调度算法" class="headerlink" title="1.5.3 分级调度算法"></a>1.5.3 分级调度算法</h4><p>​    基于时间片轮转调度。不同优先级建立不同的队列，优先级越高的进程，时间片越短。</p>
<h2 id="二、锁"><a href="#二、锁" class="headerlink" title="二、锁"></a>二、锁</h2><h3 id="2-1-并发机制的底层实现"><a href="#2-1-并发机制的底层实现" class="headerlink" title="2.1 并发机制的底层实现"></a>2.1 并发机制的底层实现</h3><h4 id="2-1-1-Volatile的实现原理"><a href="#2-1-1-Volatile的实现原理" class="headerlink" title="2.1.1 Volatile的实现原理"></a>2.1.1 Volatile的实现原理</h4><p>​    在<a href="https://rnang0.github.io/2020/07/13/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A06%EF%BC%9AJVM/">JVM</a>中已经详细阐述Volatile如何实现可见性，但他不保证原子性，因为他没加锁，不能解决指令交错的问题。</p>
<h5 id="2-1-1-1-CAS"><a href="#2-1-1-1-CAS" class="headerlink" title="2.1.1.1 CAS"></a>2.1.1.1 CAS</h5><p>​    CompareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子类型。</p>
<p>​    <strong>CAS必须借助volatile来实现读取到共享数据的最新值从而进行比较交换的效果。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取余额的最新值</span></span><br><span class="line">            <span class="keyword">int</span> prev = money.get();</span><br><span class="line">            <span class="comment">// 要修改的余额</span></span><br><span class="line">            <span class="keyword">int</span> next = prev - amount;</span><br><span class="line">            <span class="comment">// money必须是原子类型，底层value被Volatile修饰</span></span><br><span class="line">            <span class="keyword">if</span>(money.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;	  <span class="comment">//如果最新的余额与之前的余额不一致继续下一轮循环，一致则退出循环	</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    compareAndSet 正是做这个检查，在set前，先比较prev与当前值         </p>
<ul>
<li>不一致了，next 作废，返回 false 表示失败，比如，别的线程已经做了减法，当前值已经被减成了 990 ，那么本线程的这次 990 就作废了，进入 while 下次循环重试</li>
<li>一致，<strong>以 next 设置为新值</strong>，返回 true 表示成功</li>
</ul>
<h5 id="2-1-1-2-原子整数"><a href="#2-1-1-2-原子整数" class="headerlink" title="2.1.1.2 原子整数"></a>2.1.1.2 原子整数</h5><p>​    是对整数类包装类的封装，使用CAS实现内部的线程安全性，使用volatile来保证可见性，读取到最新值。</p>
<h5 id="2-1-1-3-原子引用"><a href="#2-1-1-3-原子引用" class="headerlink" title="2.1.1.3 原子引用"></a>2.1.1.3 原子引用</h5><p>​    ABA问题：即该线程查觉不到共享变量被修改过，但希望能判断其他线程使用过 （修改过），这时使得自己的CAS失效，返回false。</p>
<p>​    <strong>解决办法：加一个版本号，使得每次修改都使得版本号+1</strong></p>
<p><em>AtomicStamptdReference就是如此，还可以根据版本号的值来判断修改次数，但有时为了简单不需要关系修改次数，则使用AtomicMarkableReference，他可以返回布尔类型值，只关心判断是否修改。</em></p>
<h5 id="2-1-1-4-原子数组"><a href="#2-1-1-4-原子数组" class="headerlink" title="2.1.1.4 原子数组"></a>2.1.1.4 原子数组</h5><p><strong>不安全的数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">demo(</span><br><span class="line">	 ()-&gt;<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>],</span><br><span class="line">	 (array)-&gt;array.length,</span><br><span class="line">	 (array, index) -&gt; array[index]++,</span><br><span class="line">	 array-&gt; System.out.println(Arrays.toString(array))</span><br><span class="line">);</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p><strong>安全的数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">demo(</span><br><span class="line">	 ()-&gt; <span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>),</span><br><span class="line">	 (array) -&gt; array.length(),</span><br><span class="line">	 (array, index) -&gt; array.getAndIncrement(index),</span><br><span class="line">	 array -&gt; System.out.println(array)</span><br><span class="line">);</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<h5 id="2-1-1-5-字段更新器"><a href="#2-1-1-5-字段更新器" class="headerlink" title="2.1.1.5 字段更新器"></a>2.1.1.5 字段更新器</h5><p>​    保护的是类的字段（成员变量），而且字段必须volatile修饰，否则会出现异常。</p>
<p><code>Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Must be volatile type</code></p>
<h5 id="2-1-1-6-原子累加器"><a href="#2-1-1-6-原子累加器" class="headerlink" title="2.1.1.6 原子累加器"></a>2.1.1.6 原子累加器</h5><p>​    JDK8之后专门提供了几个类，来做原子的累加，性能要高很多。</p>
<p>性能提升的原因很简单，就是在有竞争时，<strong>设置多个累加单元</strong>，不是只在一个变量上加。因此<strong>减少了 CAS 重试失败</strong>，从而提高性能。</p>
<h4 id="2-1-2-synchronized的实现原理"><a href="#2-1-2-synchronized的实现原理" class="headerlink" title="2.1.2 synchronized的实现原理"></a>2.1.2 synchronized的实现原理</h4><p>​    synchronize又被称作<strong>对象锁（Monitor对象）</strong>，是一种<strong>阻塞性</strong>的锁。</p>
<p><strong>synchronized底层实际上是通过管程Monitor来实现</strong>，那么如何给对象用synchronized上锁呢？</p>
<img src="https://img-blog.csdnimg.cn/20200729081026811.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" style="zoom: 50%;" />

<p>（1）Java对象的对象头中的Mark Word，指向一个管程Monitor对象的指针。</p>
<p>（2）对象中锁标志位从01-&gt;10，然后当前线程指向管程中的owner部分，表示拥有该管程。</p>
<p>（3）下一个线程来了，发现该对象有锁（标志位判断），然后继续看对象指向的Monitor他的owner，发现有线程指向，则进入EntryList阻塞。</p>
<p>（4）线程将临界资源用完后，就不指向owner了，就从EntryList中拿线程去指向Monitor</p>
<img src="https://img-blog.csdnimg.cn/20200729081112101.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" style="zoom:150%;" />

<p>​    <strong>总结：让作为锁的对象关联一个管程，管程才是真正意义上的锁，使用成本太高，但是具有原子性。</strong></p>
<h4 id="2-1-3-Lock锁"><a href="#2-1-3-Lock锁" class="headerlink" title="2.1.3 Lock锁"></a>2.1.3 Lock锁</h4><p>​    java.util.concurrent.locks.Lock 机制提供了比synchronized代码块和synchronized方法<strong>更广泛的锁定操作</strong>,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。</p>
<p>​    <strong>显示的创建锁，锁获取和释放，具有可操作性，可以中断的获取锁，超时获取锁；而synchronized则是隐式的获取锁，锁获取和释放都固化了，就先获取再释放。（不能像Lock实现类ReetrantLook一样可重入，再次获取锁）</strong></p>
<p>​    <strong>Lock锁也称同步锁</strong>，加锁与释放锁 方法化了，如下：<br>​    <strong>public void lock() :加同步锁。<br>​    public void unlock() :释放同步锁。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟票</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mango</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多线程共享数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个lock锁对象</span></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 卖票操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//同步方法</span></span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                String name = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name + <span class="string">"正在卖"</span> + ticket--);</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-锁升级"><a href="#2-2-锁升级" class="headerlink" title="2.2 锁升级"></a>2.2 锁升级</h3><h4 id="2-2-1-轻量级锁"><a href="#2-2-1-轻量级锁" class="headerlink" title="2.2.1 轻量级锁"></a>2.2.1 轻量级锁</h4><p>​    适用场景：多线程访问在同一周期（一段时间）内没有竞争发生。</p>
<p>​    它实际上对使用者是透明的，语法依然是synchronized，<strong>每次会尝试先加轻量级锁，进行CAS操作。</strong></p>
<ol>
<li><strong>CAS操作：对象头的Mark Word 尝试复制到 栈帧中的锁记录中，成功，则获取锁，失败则其他对象竞争锁，进行锁膨胀；自己重入获取锁的话，则进行重入计数。</strong></li>
</ol>
<ul>
<li><strong>锁膨胀：为对象申请Monitor，让对象指向Monitor锁地址。</strong></li>
</ul>
<p>​    结束后（退出synchronized代码块时），再使用CAS操作。</p>
<ol start="2">
<li><strong>CAS操作：讲栈帧中的锁记录，恢复给对象头的Mark Word值，成功，则解锁成功，失败则说明已经膨胀为重量级锁，实行重量级锁的解锁流程。</strong></li>
</ol>
<h4 id="2-2-2-偏向锁"><a href="#2-2-2-偏向锁" class="headerlink" title="2.2.2 偏向锁"></a>2.2.2 偏向锁</h4><p>​    轻量级锁如果没竞争，每次都要CAS操作，所以可以使用锁优化：</p>
<p>​    第一次CAS时，将线程ID设置到对象的Mark Word头，之后发现线程ID无竞争，则不用CAS，只需要判断线程ID。</p>
<p>​    何时撤销偏向锁？</p>
<ul>
<li>调用对象的hashCode方法，因为<strong>hashCode值会被存入轻量级中的锁记录，重量级锁中的Monitor中。</strong></li>
<li>其他线程使用，自然就会撤销掉偏向锁，升级为轻量级锁。</li>
<li>wait和notify，它们是重量级锁的机制。</li>
</ul>
<h3 id="2-3-悲观锁-乐观锁"><a href="#2-3-悲观锁-乐观锁" class="headerlink" title="2.3 悲观锁 -乐观锁"></a>2.3 悲观锁 -乐观锁</h3><h4 id="2-3-1-管程-悲观锁"><a href="#2-3-1-管程-悲观锁" class="headerlink" title="2.3.1 管程-悲观锁"></a>2.3.1 管程-悲观锁</h4><p>​    管程实际上是抽象相关并发进程对共享变量的访问。</p>
<ul>
<li><p>条件变量：检测互斥的标志</p>
</li>
<li><p>同步<strong>原语wait</strong>：进程无法获取资源时，阻塞进程；<strong>原语signal</strong>：进程释放资源时，唤醒（notify）等待队列</p>
</li>
<li><p>管程局部变量：进程共享变量，过程实际上就是对管程局部变量的操作</p>
</li>
</ul>
<h4 id="2-3-2-无锁并发-乐观锁"><a href="#2-3-2-无锁并发-乐观锁" class="headerlink" title="2.3.2 无锁并发-乐观锁"></a>2.3.2 无锁并发-乐观锁</h4><p>​    乐观锁实际上没有锁，<strong>CAS和Volatile结合可以实现无锁并发</strong>，不使用synchronized关键字，适用于<strong>线程少 ，多核CPU</strong>的场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountCas</span> <span class="keyword">implements</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger balance;  <span class="comment">//使用原子整形AtomicInteger，底层是用的Volatile，实现每次拿到最新值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountCas</span><span class="params">(<span class="keyword">int</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = <span class="keyword">new</span> AtomicInteger(balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance.get();    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取余额的最新值</span></span><br><span class="line">            <span class="keyword">int</span> prev = balance.get();</span><br><span class="line">            <span class="comment">// 要修改的余额</span></span><br><span class="line">            <span class="keyword">int</span> next = prev - amount;</span><br><span class="line">            <span class="comment">// 真正修改</span></span><br><span class="line">            <span class="keyword">if</span>(balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;	  <span class="comment">//如果最新的余额与之前的余额不一致继续下一轮循环，一致则退出循环	</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-3-悲观锁-乐观锁比较"><a href="#2-3-3-悲观锁-乐观锁比较" class="headerlink" title="2.3.3 悲观锁-乐观锁比较"></a>2.3.3 悲观锁-乐观锁比较</h4><ul>
<li>CAS是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃点亏再重试呗。</li>
<li>synchronized是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li>
<li>CAS体现的是无锁并发、无阻塞并发：<ul>
<li>因为没有使用synchronized，所以线程不会陷入阻塞，这是提升效率的因素之一</li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率可能会受到影响</li>
</ul>
</li>
</ul>
<ol>
<li>注：为什么无锁就效率高呢？</li>
</ol>
<ul>
<li>无锁情况下，线程始终高速运转，没有停歇，而synchronized会让没有获取锁的线程，发生上下文切换，进入阻塞。（重新打火一样，代价太大）</li>
</ul>
<ol start="2">
<li>但无锁情况下，线程需要高速运转，需要cpu的支持，<strong>如果没有额外的cpu核数，线程就无法高速运转，虽然不会阻塞，但由于分不到时间片还是回上下文切换。</strong>所以要求线程数低于CPU核数，才能发挥优势。</li>
</ol>
<h2 id="三、线程池"><a href="#三、线程池" class="headerlink" title="三、线程池"></a>三、线程池</h2><h3 id="3-1-线程池优势"><a href="#3-1-线程池优势" class="headerlink" title="3.1 线程池优势"></a>3.1 线程池优势</h3><p>​    合理利用线程池能够带来三个好处：</p>
<ol>
<li><p>降低资源消耗。<strong>减少了线程创建销毁的过程（节约资源），每个工作线程都可以被重复利用</strong>，可执行多个任务。</p>
</li>
<li><p><strong>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</strong></p>
</li>
<li><p>提高线程的可管理性。可以根据系统的承受能力，<strong>调整线程池中工作线线程的数目。</strong></p>
<p>防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200725213522417.png" alt=""></p>
<h3 id="3-2-ThreadPoolExecutor"><a href="#3-2-ThreadPoolExecutor" class="headerlink" title="3.2 ThreadPoolExecutor"></a>3.2 ThreadPoolExecutor</h3><p>​    java中线程池的顶级接口是java.util.concurrent.Executor，但它并不是一个线程池，而只是一个执行线程的工具，真正的线程池接口是java.util.concurrent.ExecutorService</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9teS1ibG9nLXRvLXVzZS5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vMjAxOS03LyVFNCVCQiVCQiVFNSU4QSVBMSVFNyU5QSU4NCVFNiU4OSVBNyVFOCVBMSU4QyVFNyU5QiVCOCVFNSU4NSVCMyVFNiU4RSVBNSVFNSU4RiVBMy5wbmc?x-oss-process=image/format,png" alt=""></p>
<h4 id="3-2-1-线程池状态"><a href="#3-2-1-线程池状态" class="headerlink" title="3.2.1 线程池状态"></a>3.2.1 线程池状态</h4><p><img src="https://img-blog.csdnimg.cn/20200725210852400.png" alt=""></p>
<h4 id="3-2-2-shutdown与stop区别："><a href="#3-2-2-shutdown与stop区别：" class="headerlink" title="3.2.2 shutdown与stop区别："></a>3.2.2 shutdown与stop区别：</h4><ol>
<li>shutdown状态，不会接受新任务，把阻塞队列中的继续执行完</li>
<li>stop状态，立即中断，抛弃阻塞队列中的任务</li>
</ol>
<h4 id="3-2-3-线程池构造方法，参数说明"><a href="#3-2-3-线程池构造方法，参数说明" class="headerlink" title="3.2.3 线程池构造方法，参数说明"></a>3.2.3 线程池构造方法，参数说明</h4><p><img src="https://img-blog.csdnimg.cn/20200725211002613.png" alt="img"></p>
<h4 id="3-2-4-ScheduledThreadPoolExecutor"><a href="#3-2-4-ScheduledThreadPoolExecutor" class="headerlink" title="3.2.4 ScheduledThreadPoolExecutor"></a>3.2.4 ScheduledThreadPoolExecutor</h4><p>​    <strong>功能：带有任务调度功能，可以延时执行，定时执行</strong></p>
<h3 id="3-3-拒绝策略"><a href="#3-3-拒绝策略" class="headerlink" title="3.3 拒绝策略"></a>3.3 拒绝策略</h3><p>​    先来说一下JDK线程池的执行过程：</p>
<ol>
<li>线程池开始没线程，任务交给后，开始创建执行任务，任务达到corePoolSize（核心线程数）时，这时任务进入阻塞队列。</li>
<li>如果设置为有界队列，任务超出阻塞队列大小时，则会创建maximumPoolSize 减去 corePoolSize这么多线程来救急。</li>
<li>线程到达maximumPoolSize仍然有新任务，<strong>这时就会执行拒绝策略。</strong></li>
<li>高峰期过去，超过corePoolSize的线程长时间没有task任务做，则结束释放资源。</li>
</ol>
<ul>
<li>拒绝策略：</li>
</ul>
<ol>
<li>默认：抛出RejectedExecutionException异常</li>
<li>运行任务</li>
<li>放弃</li>
<li><strong>Netty的实现：创建新线程来执行</strong></li>
<li><strong>ActiveMq的实现：带超时等待（60s）尝试放入队列</strong></li>
<li>。。。。等等</li>
</ol>
<h3 id="3-4-Fork-Join线程池"><a href="#3-4-Fork-Join线程池" class="headerlink" title="3.4 Fork/Join线程池"></a>3.4 Fork/Join线程池</h3><p>​    Fork/Join ：拆分 + 合并，采用分治的思想，适用于能够进行任务拆分的cpu密集型运算。（线程数 = cpu）</p>
<p>​    在分治的基础上，加入了多线程，可以把每个任务分解合并交给不同的线程来完成，提高效率，默认创建与cpu核心数相同的线程池。</p>
<h2 id="四、并发工具类"><a href="#四、并发工具类" class="headerlink" title="四、并发工具类"></a>四、并发工具类</h2><ol>
<li>永远只在更新对象的成员变量时加锁</li>
<li>永远只在访问可变的成员变量时加锁</li>
<li>永远不在调用其他对象的方法时加锁（其他方法内部可能有锁，或者执行时间过长）</li>
</ol>
<h3 id="4-1-AQS"><a href="#4-1-AQS" class="headerlink" title="4.1 AQS"></a>4.1 AQS</h3><p>​    抽象队列同步器AbstractQueuedSynchronizer，是除了java自带的synchronized关键字之外的锁机制，可以用来实现锁。</p>
<p><img src="https://img-blog.csdnimg.cn/20200726110705582.png" alt=""></p>
<h4 id="4-1-1-核心思想"><a href="#4-1-1-核心思想" class="headerlink" title="4.1.1 核心思想"></a>4.1.1 核心思想</h4><p>​    <strong>AQS的核心思想</strong>是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态state置为1，如果被请求的共享资源被占用，那么就需要<strong>一套线程阻塞等待以及被唤醒时锁分配的机制</strong>，这个机制AQS是用CLH队列锁实现的，即将<strong>暂时获取不到锁的线程加入到等待队列（类似于 Monitor 的 EntryList）</strong>中。</p>
<p>​    <strong>总结：AQS就是基于CLH队列，用volatile修饰共享变量state，线程的tryAcquire()方法通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20181128142923147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L211bGluc2VuNzc=,size_16,color_FFFFFF,t_70" alt=""></p>
<p>例：继承AQS实现独占不可重入锁，Lock的锁方法，都是调用的独占锁（继承同步器类）的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义锁（不可重入锁）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 独占锁  同步器类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MySync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 加上了锁，并设置 owner 为当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span> <span class="comment">// 是否持有独占锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> MySync sync = <span class="keyword">new</span> MySync();</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 加锁（不成功会进入等待队列）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 加锁，可打断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 尝试加锁（一次）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 尝试加锁，带超时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 创建条件变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-2-AQS三要素："><a href="#4-1-2-AQS三要素：" class="headerlink" title="4.1.2 AQS三要素："></a>4.1.2 AQS三要素：</h4><ol>
<li><p>原子维护state状态：volatile配合CAS保证修改时的可见性</p>
</li>
<li><p>维护等待队列：使用FIFO先入先出队列</p>
</li>
<li><p>阻塞、唤醒线程的方法：使用park &amp; unpark来，标志为-1，则需要恢复后序的线程</p>
</li>
</ol>
<h4 id="4-1-3-与synchronized的区别"><a href="#4-1-3-与synchronized的区别" class="headerlink" title="4.1.3 与synchronized的区别"></a>4.1.3 与synchronized的区别</h4><p>相比于synchronized，能够：</p>
<ol>
<li>响应中断</li>
<li>支持超时</li>
<li>非阻塞的获取锁</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="comment">// 加锁，可打断的API</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">// 尝试加锁，非阻塞的获取锁，底层是用CAS实现无阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">// 尝试加锁，带超时</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-ReentrantLock"><a href="#4-2-ReentrantLock" class="headerlink" title="4.2 ReentrantLock"></a>4.2 ReentrantLock</h3><p>​    可重入锁，即同一线程可以重复获取同一把锁。</p>
<h4 id="4-2-1-非公平锁实现原理"><a href="#4-2-1-非公平锁实现原理" class="headerlink" title="4.2.1 非公平锁实现原理"></a>4.2.1 非公平锁实现原理</h4><p>​    ReentrantLock默认构造函数是创建<strong>非公平锁NonfairSync</strong>。</p>
<ul>
<li>非公平锁即在有线程释放锁时，<strong>随机唤醒</strong>阻塞队列中的一个线程</li>
<li>公平锁即在有线程释放锁时，唤醒<strong>等待时间最长（阻塞队列队头）</strong>的线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>NonfairSync</code>非公平锁是继承自AQS的一个同步器类，作为ReetranLock的实现（是其一个内部类，与我们自定义锁类似）</p>
<ol>
<li>刚开始第一个线程获取锁时，这时没有竞争，直接state置为1，让Owner指向线程。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200726112154937.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">//state置为1</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//Owner指向当前线程</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>当出现竞争时</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200802085847837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>新线程继续上面代码，CAS尝试失败，然后进入tryAcquire再次尝试获得锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如果开始线程依然没有释放锁又失败，则进入addWaiter，构造一个Node队列。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200802090916852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>黄色三角为标志位，0位正常</li>
<li>Node创建时懒创建，第一个Node是哨兵，用来占位使用</li>
</ul>
<ol start="4">
<li>竞争的线程进入到acquireQueued</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">    <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">        setHead(node);</span><br><span class="line">        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        failed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> interrupted;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">        parkAndCheckInterrupt())</span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200802091434691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>（1）会在死循环中，<strong>一直不断尝试获得锁，失败后进入park阻塞</strong></p>
<p>（2）如果是第二位（即哨兵后一位），那么再次尝试，如果state依然为-1，则失败</p>
<p>（3）进入到shouldParkAfterFailedAcquire，将前驱结点标志位置为-1</p>
<ol start="5">
<li>线程再次循环到shouldParkAfterFailedAcquire时，这时前驱为-1，则返回true，进入parkAndCheckInterrupt，线程结点用灰色表示</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200802091831425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>​    多个线程依然经历上述过程，到开始线程没有释放锁之前，都竞争失败</p>
<p><img src="https://img-blog.csdnimg.cn/20200802092135292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol start="6">
<li>终于，开始线程释放了锁，进入到了tryRelease流程，成功则进行对称操作</li>
</ol>
<ul>
<li>owner置为null</li>
<li>state置为0</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200802092409109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>​    当前队列不为null，并且head标志位为-1，进入unpark恢复流程，恢复最近的一个线程即 Thread-1，然后Thread-1进入acquireQueued</p>
<p><img src="https://img-blog.csdnimg.cn/2020080209313259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>​    如果加锁成功（没有外部线程竞争），会设置：</p>
<ul>
<li>owner，state，head指向Thread-1</li>
<li>head指向Thread-1的Node，清空置为null即可</li>
<li><strong>原来的head从链表中断开 ，被GC</strong></li>
</ul>
<p>​    如果加锁不成功，即外面有线程竞争，不巧由于非公平锁被Thread-4占了先</p>
<p><img src="https://img-blog.csdnimg.cn/20200802093519760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>​    则Thread-4进行原先线程的操作owner指向Thread-4，state置为1，Thread-1再次进入acquireQueued，获取锁失败，则重新进入park阻塞</p>
<h4 id="4-2-2-可重入原理"><a href="#4-2-2-可重入原理" class="headerlink" title="4.2.2 可重入原理"></a>4.2.2 可重入原理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非公平锁为例</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">     <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">         <span class="keyword">int</span> c = getState();</span><br><span class="line">         <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// state++ state变成2，变成两次</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// state-- </span></span><br><span class="line">         <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">         <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">         <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">         <span class="comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span></span><br><span class="line">         <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">             free = <span class="keyword">true</span>;</span><br><span class="line">             setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         setState(c);</span><br><span class="line">         <span class="keyword">return</span> free;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入，state++ ，例如state变成2，表示两次加锁</li>
<li>支持锁重入, 只有 state 减为 0, 才setExclusiveOwnerThread释放成功</li>
</ul>
<h4 id="4-2-3-可打断原理"><a href="#4-2-3-可打断原理" class="headerlink" title="4.2.3 可打断原理"></a>4.2.3 可打断原理</h4><p>​    默认为不可打断，不能被其他线程打断，终止我的等待。即使被打断，也仍然会在AQS队列中，等获得锁时打个标记继续运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    parkAndCheckInterrupt()) &#123;</span><br><span class="line">    <span class="comment">// 在 park 过程中如果被 interrupt 会进入此</span></span><br><span class="line">    <span class="comment">// 这时候抛出异常, 而不会再次进入 for (;;)，从而终止等待</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：在 park 过程中如果被 interrupt 会抛出异常, 而不会再次进入 for (;;)，从而终止等待。</strong></p>
<h4 id="4-2-4-公平锁实现原理"><a href="#4-2-4-公平锁实现原理" class="headerlink" title="4.2.4 公平锁实现原理"></a>4.2.4 公平锁实现原理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与非公平锁主要区别在于 tryAcquire 方法的实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="comment">// h != t 时表示队列中有 Node</span></span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        (</span><br><span class="line">        <span class="comment">// (s = h.next) == null 表示队列中还有没有老二（哨兵后一位）</span></span><br><span class="line">        (s = h.next) == <span class="keyword">null</span> ||</span><br><span class="line">        <span class="comment">// 或者队列中老二线程不是此线程</span></span><br><span class="line">        s.thread != Thread.currentThread()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-ReadWriteLock"><a href="#4-3-ReadWriteLock" class="headerlink" title="4.3 ReadWriteLock"></a>4.3 ReadWriteLock</h3><h4 id="4-3-1-ReentrantReadWriteLock"><a href="#4-3-1-ReentrantReadWriteLock" class="headerlink" title="4.3.1 ReentrantReadWriteLock"></a>4.3.1 ReentrantReadWriteLock</h4><p>​    ReentrantReadWriteLock：读写锁，支持共享锁和排它锁。</p>
<p>​    支持降级重入，即可以先获得写锁，再获得读锁，反之则不行。</p>
<p>​    <strong>总结：当读操作远远高于写操作时，这时候使用 读写锁 让 读-读 可以并发，提高性能。</strong> </p>
<h4 id="4-3-2-StampedLock"><a href="#4-3-2-StampedLock" class="headerlink" title="4.3.2 StampedLock"></a>4.3.2 StampedLock</h4><p>​    StampedLock：为了进一步优化读性能，<strong>支持乐观读</strong>、悲观读、也有写锁（避免了写线程饥饿）</p>
<p>​    特点：使用乐观锁、读锁、写锁必须配合【戳】来使用，判断返回值。</p>
<p>​    乐观读：StampedLock支持tryOptimisticRead()方法来进行乐观读，读取完毕需要加一次<code>戳验证</code>，看是否被其他写线程修改，验证不通过则进行锁升级为读锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StampedLock lock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> stamp = lock.tryOptimisticRead();</span><br><span class="line"><span class="comment">// 验证戳</span></span><br><span class="line"><span class="keyword">if</span> (!lock.validate(stamp)) &#123;</span><br><span class="line">    <span class="comment">// 进行锁升级，获取读锁</span></span><br><span class="line">    lock.readLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    注意：</p>
<ul>
<li><p>StampedLock不支持条件变量（条件不满足进入waitSet等待）相比较于ReentrantLock支持多条件变量就逊色了</p>
</li>
<li><p>StampedLock不支持可重入</p>
</li>
</ul>
<h3 id="4-4-信号量"><a href="#4-4-信号量" class="headerlink" title="4.4 信号量"></a>4.4 信号量</h3><p>​    Semaphore：限制能同时访问共享资源的<strong>线程上限</strong>，线程运行需要获取许可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每次最多运行三个线程</span></span><br><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取许可，则permits就减1</span></span><br><span class="line">    semaphore.acquire();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放许可</span></span><br><span class="line">    semaphore.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200726132002186.png" alt=""></p>
<p>​    信号量模型：</p>
<ul>
<li><p>一个计数器：底层实际上还是使用AQS，通过对permits（state）实现加减来判断能否获取共享资源</p>
</li>
<li><p>一个等待队列：同样有个CLH队列，有park阻塞</p>
</li>
<li><p>三个方法</p>
<p><img src="https://img-blog.csdnimg.cn/20200722214903119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<h3 id="4-5-线程安全集合类"><a href="#4-5-线程安全集合类" class="headerlink" title="4.5 线程安全集合类"></a>4.5 线程安全集合类</h3><h4 id="4-5-1-遗留的安全集合"><a href="#4-5-1-遗留的安全集合" class="headerlink" title="4.5.1 遗留的安全集合"></a>4.5.1 遗留的安全集合</h4><p>​    不推荐使用，主要有Hashtable和Vector，一个是线程安全的Map类型，一个是线程安全（加synchronized）的List类型。</p>
<h4 id="4-5-2-修饰的安全集合"><a href="#4-5-2-修饰的安全集合" class="headerlink" title="4.5.2 修饰的安全集合"></a>4.5.2 修饰的安全集合</h4><p>​    SynchronizedMap 和 SynchronizedList，都是通过Collections修饰变成线程安全的集合。</p>
<p>​    内部实现实现就是调用Map和List的方法，<strong>在方法体中，加入了Synchronized(mutex)的方法块。</strong></p>
<h4 id="4-5-3-J-U-C下的并发容器"><a href="#4-5-3-J-U-C下的并发容器" class="headerlink" title="4.5.3 J.U.C下的并发容器"></a>4.5.3 J.U.C下的并发容器</h4><p>​    <strong>主要分为三大类：Blocking、CopyOnWrite、Concurrent</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200722214857269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li><p>Blocking 大部分实现基于锁，并提供了阻塞的方法实现，即不满足条件即阻塞。</p>
</li>
<li><p>CopyOnWrite：容器修改时<strong>会进行拷贝</strong>，来避免多线程并发的线程安全，<strong>适合于读多写少的场景</strong>。</p>
</li>
<li><p>Concurrent：<strong>（强烈推荐，性能好）</strong></p>
<ol>
<li>内部<strong>很多操作</strong>使用CAS进行优化，也有用Synchronized来实现的，<strong>一般可以提供高吞吐量，避免频繁阻塞。</strong></li>
<li>弱一致性：遍历时，求大小时，读取时会存在弱一致性，发生修改<strong>可能</strong>拿取到的是旧值（注意是可能），但是比其他性能高。</li>
</ol>
<p>注：遍历时，对应非安全类（即没有加Synchronized）容器，使用<code>fail-fast</code>机制让遍历尽快失败，抛出ConcurrentModificationException，不再继续的遍历。</p>
</li>
</ol>
<p><strong>注：弱一致性不一定不好，并发高和弱一致性无法两全，需要权衡。</strong></p>
<h3 id="4-6-ConcurrentHashMap"><a href="#4-6-ConcurrentHashMap" class="headerlink" title="4.6 ConcurrentHashMap"></a>4.6 ConcurrentHashMap</h3><p>​    使用：一般使用 <strong>computeIfAbsent()方法 + 原子累加器</strong>（原子类例如LongAdder）来实现。</p>
<p>​    <strong>synchronized加在computeIfAbsent()方法中的bin链表头部的，性能高。</strong></p>
<p> <img src="https://img-blog.csdnimg.cn/20200726155504476.png" alt=""></p>
<h4 id="4-6-1-原理"><a href="#4-6-1-原理" class="headerlink" title="4.6.1 原理"></a>4.6.1 原理</h4><p>​    JDK1.8之前：维护一个Segment数组，每个Segment对应一把锁，多个线程访问不同的segment，实际是无冲突与8类似。</p>
<p>​    JDK1.8：数组+ 链表（红黑树）来实现，以下数组=table，链表为bin，红黑树为TreeNode</p>
<ul>
<li>初始化，使用<strong>cas保证并发安全</strong>，懒惰初始化table</li>
<li>树化，当table长度&lt;64时，尝试扩容；当bin的长度&gt;8，会将链表转化成红黑树，<strong>树化过程用synchronized锁住链表头。</strong></li>
<li>put，没链表时为cas创建链表，有就尾插法</li>
<li>get，无锁仅需保证可见性</li>
<li>扩容，需要对每个链表进行synchronized</li>
<li>size，元素个数保存在baseCount，并发时将个数变动保存到CounterCell[]中，最后统计数量时再进行累加即可</li>
</ul>
<h4 id="4-6-2-ConcurrentHashMap比HashTable的优点"><a href="#4-6-2-ConcurrentHashMap比HashTable的优点" class="headerlink" title="4.6.2 ConcurrentHashMap比HashTable的优点"></a>4.6.2 ConcurrentHashMap比HashTable的优点</h4><ul>
<li><p>ConcurrentHashMap里使用了 <strong>Segment分段锁 + HashEntry（将整个map分为N段，操作时只锁一段）</strong>，而HashTable用的是Syncronized锁全部，所有线程竞争一把锁。</p>
</li>
<li><p>Segment分段锁继承ReentrantLock，在并发数高的时候，ReentrantLock比Syncronized总体开销要小一些。</p>
<p><img src="https://img-blog.csdnimg.cn/20200722214908422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<h3 id="4-7-CopyOnWriteArrayList"><a href="#4-7-CopyOnWriteArrayList" class="headerlink" title="4.7 CopyOnWriteArrayList"></a>4.7 CopyOnWriteArrayList</h3><p>​    CopyOnWriteSet就是调用CopyOnWriteArrayList的方法，每次执行前加一次判断Set中是否值。</p>
<p>底层实现采用<code>写入时拷贝</code>，即增删改这种写操作，<strong>会将底层数组拷贝一份，更改在新数组中执行</strong>，这时并不影响其他线程<strong>并发读，读写分离。</strong>Java8采用可重入锁实现，到了Java11就采用的是synchronized来实现。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">rnang0</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://rnang0.github.io/2020/07/25/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A07%EF%BC%9AJava%E5%B9%B6%E5%8F%91/">http://rnang0.github.io/2020/07/25/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A07%EF%BC%9AJava%E5%B9%B6%E5%8F%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://rnang0.github.io" target="_blank">rnang0 Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a><a class="post-meta__tags" href="/tags/%E9%94%81/">锁</a></div><div class="post_share"><div class="social-share" data-image="https://img-blog.csdnimg.cn/20210215203123879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/08/03/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A08%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98/"><img class="prev_cover" src="https://www.lgstatic.com/i/image2/M01/8A/CA/CgoB5l14rXSAWVk7AAFdi6Ly8iM148.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">春招复习8：数据库与缓存</div></div></a></div><div class="next-post pull_right"><a href="/2020/07/13/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A06%EF%BC%9AJVM/"><img class="next_cover" src="https://img-blog.csdnimg.cn/20200718152358438.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">春招复习6：JVM</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/06/23/春招复习4：操作系统/" title="春招复习4：操作系统"><img class="relatedPosts_cover" src="https://img-blog.csdnimg.cn/20200624114032370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-23</div><div class="relatedPosts_title">春招复习4：操作系统</div></div></a></div><div class="relatedPosts_item"><a href="/2021/02/15/春招面经：多线程并发/" title="春招面经：并发编程"><img class="relatedPosts_cover" src="https://img-blog.csdnimg.cn/20210215203123879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-02-15</div><div class="relatedPosts_title">春招面经：并发编程</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/13/春招复习6：JVM/" title="春招复习6：JVM"><img class="relatedPosts_cover" src="https://img-blog.csdnimg.cn/20200718152358438.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-13</div><div class="relatedPosts_title">春招复习6：JVM</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By rnang0</div><div class="footer_custom_text">Hi, welcome to my <a href="http://rnang0.github.io/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script></body></html>