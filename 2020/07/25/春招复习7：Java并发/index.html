<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>春招复习7：Java并发 | rnang0 Blog</title><meta name="description" content="Java并发重点学习内容 并发编程的基础 锁 原子类 线程池 JUC并发工具类 并发容器  一、并发理论基础1.1 Happends-Before规则​    Happends-Before规则规定了对共享变量的写对其它线程的读操作可见。  程序次序规则：一个线程内，按照控制流顺序，前面的操作先行发生于后面的操作。  管程锁定规则：unlock操作先行发生于后面（时间上）对这个锁的lock操作。"><meta name="keywords" content="并发,锁"><meta name="author" content="rnang0"><meta name="copyright" content="rnang0"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="春招复习7：Java并发"><meta name="twitter:description" content="Java并发重点学习内容 并发编程的基础 锁 原子类 线程池 JUC并发工具类 并发容器  一、并发理论基础1.1 Happends-Before规则​    Happends-Before规则规定了对共享变量的写对其它线程的读操作可见。  程序次序规则：一个线程内，按照控制流顺序，前面的操作先行发生于后面的操作。  管程锁定规则：unlock操作先行发生于后面（时间上）对这个锁的lock操作。"><meta name="twitter:image" content="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=4060513360,1461496884&amp;fm=26&amp;gp=0.jpg"><meta property="og:type" content="article"><meta property="og:title" content="春招复习7：Java并发"><meta property="og:url" content="http://yoursite.com/2020/07/25/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A07%EF%BC%9AJava%E5%B9%B6%E5%8F%91/"><meta property="og:site_name" content="rnang0 Blog"><meta property="og:description" content="Java并发重点学习内容 并发编程的基础 锁 原子类 线程池 JUC并发工具类 并发容器  一、并发理论基础1.1 Happends-Before规则​    Happends-Before规则规定了对共享变量的写对其它线程的读操作可见。  程序次序规则：一个线程内，按照控制流顺序，前面的操作先行发生于后面的操作。  管程锁定规则：unlock操作先行发生于后面（时间上）对这个锁的lock操作。"><meta property="og:image" content="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=4060513360,1461496884&amp;fm=26&amp;gp=0.jpg"><meta property="article:published_time" content="2020-07-24T16:00:00.000Z"><meta property="article:modified_time" content="2020-08-01T08:07:45.094Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="canonical" href="http://yoursite.com/2020/07/25/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A07%EF%BC%9AJava%E5%B9%B6%E5%8F%91/"><link rel="next" title="春招复习6：JVM" href="http://yoursite.com/2020/07/13/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A06%EF%BC%9AJVM/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'none',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/autor.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">73</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">99</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-mars"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java并发"><span class="toc-text">Java并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#重点学习内容"><span class="toc-text">重点学习内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一、并发理论基础"><span class="toc-text">一、并发理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Happends-Before规则"><span class="toc-text">1.1 Happends-Before规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-死锁"><span class="toc-text">1.2 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-产生死锁的条件"><span class="toc-text">1.2.1 产生死锁的条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-防止死锁"><span class="toc-text">1.2.2 防止死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-避免死锁"><span class="toc-text">1.2.3 避免死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-检测死锁"><span class="toc-text">1.2.4 检测死锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-进程与线程"><span class="toc-text">1.3 进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-进程、线程区别"><span class="toc-text">1.3.1 进程、线程区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-内核级线程"><span class="toc-text">1.3.2 内核级线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-用户级线程"><span class="toc-text">1.3.3 用户级线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-4-四种线程创建方式"><span class="toc-text">1.3.4 四种线程创建方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-线程状态"><span class="toc-text">1.4 线程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-线程状态概述"><span class="toc-text">1.4.1 线程状态概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-Timed-Waiting（计时等待）"><span class="toc-text">1.4.2 Timed Waiting（计时等待）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3-BLOCKED（锁阻塞）"><span class="toc-text">1.4.3 BLOCKED（锁阻塞）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-4-Waiting（无限等待）"><span class="toc-text">1.4.4 Waiting（无限等待）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-5-补充"><span class="toc-text">1.4.5 补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-线程调度"><span class="toc-text">1.5 线程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-三级调度"><span class="toc-text">1.5.1 三级调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-优先级调度算法（时间相关）"><span class="toc-text">1.5.2 优先级调度算法（时间相关）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-3-分级调度算法"><span class="toc-text">1.5.3 分级调度算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、锁"><span class="toc-text">二、锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-并发机制的底层实现"><span class="toc-text">2.1 并发机制的底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-Volatile的实现原理"><span class="toc-text">2.1.1 Volatile的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1-1-CAS"><span class="toc-text">2.1.1.1 CAS</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-synchronized的实现原理"><span class="toc-text">2.1.2 synchronized的实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-Lock锁"><span class="toc-text">2.1.3 Lock锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-锁升级"><span class="toc-text">2.2 锁升级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-轻量级锁"><span class="toc-text">2.2.1 轻量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-偏向锁"><span class="toc-text">2.2.2 偏向锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-悲观锁-乐观锁"><span class="toc-text">2.3 悲观锁 -乐观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-管程-悲观锁"><span class="toc-text">2.3.1 管程-悲观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-无锁并发-乐观锁"><span class="toc-text">2.3.2 无锁并发-乐观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-悲观锁-乐观锁比较"><span class="toc-text">2.3.3 悲观锁-乐观锁比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、原子类"><span class="toc-text">三、原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-原子整数"><span class="toc-text">3.1 原子整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-原子引用"><span class="toc-text">3.2 原子引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-原子数组"><span class="toc-text">3.3 原子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-字段更新器"><span class="toc-text">3.4 字段更新器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-原子累加器"><span class="toc-text">3.5 原子累加器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、线程池"><span class="toc-text">四、线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-线程池优势"><span class="toc-text">4.1 线程池优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-ThreadPoolExecutor"><span class="toc-text">4.2 ThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-线程池状态"><span class="toc-text">4.2.1 线程池状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-线程池构造方法，参数说明"><span class="toc-text">4.2.2 线程池构造方法，参数说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-ScheduledThreadPoolExecutor"><span class="toc-text">4.2.3 ScheduledThreadPoolExecutor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-拒绝策略"><span class="toc-text">4.3 拒绝策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Fork-Join线程池"><span class="toc-text">4.4 Fork&#x2F;Join线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、并发工具类"><span class="toc-text">五、并发工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-AQS"><span class="toc-text">5.1 AQS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-并发容器"><span class="toc-text">5.2 并发容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-信号量"><span class="toc-text">5.3 信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap比HashTable的优点"><span class="toc-text">ConcurrentHashMap比HashTable的优点</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=4060513360,1461496884&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">rnang0 Blog</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-mars"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">春招复习7：Java并发</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-25 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-07-25</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-08-01 16:07:45"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-08-01</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/">春招复习</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h1><h2 id="重点学习内容"><a href="#重点学习内容" class="headerlink" title="重点学习内容"></a>重点学习内容</h2><ul>
<li>并发编程的基础</li>
<li>锁</li>
<li>原子类</li>
<li>线程池</li>
<li>JUC并发工具类</li>
<li>并发容器</li>
</ul>
<h2 id="一、并发理论基础"><a href="#一、并发理论基础" class="headerlink" title="一、并发理论基础"></a>一、并发理论基础</h2><h3 id="1-1-Happends-Before规则"><a href="#1-1-Happends-Before规则" class="headerlink" title="1.1 Happends-Before规则"></a>1.1 Happends-Before规则</h3><p>​    Happends-Before规则规定了对共享变量的写对其它线程的读操作可见。</p>
<ul>
<li><p>程序次序规则：一个线程内，按照控制流顺序，前面的操作先行发生于后面的操作。</p>
</li>
<li><p>管程锁定规则：unlock操作先行发生于后面（时间上）对这个锁的lock操作。</p>
</li>
<li><p>Volatile规则：对一个volatile变量的写操作先行发生于后面（时间上）对这个变量的读操作。</p>
</li>
<li><p>线程：</p>
<p>线程启动规则：一个线程的start先行发生于这个线程的每一个动作。</p>
<p>线程终止规则：一个线程的所有操作先行发生于这个线程的终止检测join。</p>
<p>线程中断规则：对线程interrupt方法的调用先行发生于检测到中断事件的发生。</p>
</li>
<li><p>对象终结规则：一个对象的初始化完成先行发生于其finalize方法的开始。</p>
</li>
<li><p>传递性：若A先行发生于B，B先行发生于C，则A先行发生于C。</p>
</li>
</ul>
<p><strong>总结：</strong></p>
<p>​    一、同一线程内，按控制流顺序；</p>
<p>​    二、不同线程：</p>
<ol>
<li><p>依赖对象的：</p>
<p>volatile对象开始读，其之前的所有写一定可见；</p>
<p>对象开始执行finalize，其初始化操作一定可见；</p>
<p>对象/类被lock，其之前的unlock一定可见；</p>
</li>
<li><p>依赖线程本身的：</p>
<p>当线程开始执行操作，其start一定可见；</p>
<p>当线程可被检测为结束，其线程内所有操作一定可见；</p>
<p>当线程被中断，引发中断的事件一定可见。</p>
</li>
</ol>
<h3 id="1-2-死锁"><a href="#1-2-死锁" class="headerlink" title="1.2 死锁"></a>1.2 死锁</h3><h4 id="1-2-1-产生死锁的条件"><a href="#1-2-1-产生死锁的条件" class="headerlink" title="1.2.1 产生死锁的条件"></a>1.2.1 产生死锁的条件</h4><ol>
<li><p>互斥：一个资源同一时刻只能由一个进程占用</p>
</li>
<li><p>请求和保持：一个进程被阻塞时，不释放已有资源</p>
</li>
<li><p>不可剥夺：只有线程使用资源结束时可以释放资源</p>
</li>
<li><p>循环等待：多个线程之间形成一个互相阻塞头尾相接的等待资源关系</p>
</li>
</ol>
<h4 id="1-2-2-防止死锁"><a href="#1-2-2-防止死锁" class="headerlink" title="1.2.2 防止死锁"></a>1.2.2 防止死锁</h4><ol>
<li><p>破坏请求与保持：一次性申请所有资源</p>
</li>
<li><p>破坏不可剥夺：申请资源失败时释放已占有的资源</p>
</li>
<li><p>破坏循环等待：所有线程按相同顺序申请资源，释放反向</p>
</li>
</ol>
<h4 id="1-2-3-避免死锁"><a href="#1-2-3-避免死锁" class="headerlink" title="1.2.3 避免死锁"></a>1.2.3 避免死锁</h4><p>银行家算法（借钱给有偿还能力的客户）：</p>
<p>在为进程分配资源前预先测试系统状态。若把资源分配给进程会产生死锁，则拒绝分配。</p>
<h4 id="1-2-4-检测死锁"><a href="#1-2-4-检测死锁" class="headerlink" title="1.2.4 检测死锁"></a>1.2.4 检测死锁</h4><p>​    系统定时运行一个死锁检测程序，判断系统内是否出现死锁。若检测到死锁，则设法解除。</p>
<p>​    设计两张表：等待资源表 + 占用资源表</p>
<p>​    若有进程Pi等待资源rk，而rk被进程Pj占用，则Pi和Pj具有等待占用关系。根据上述二表，可以扫描出所有进程的等待占用关系。当等待占用关系出现首尾相接时，说明出现了死锁。</p>
<h3 id="1-3-进程与线程"><a href="#1-3-进程与线程" class="headerlink" title="1.3 进程与线程"></a>1.3 进程与线程</h3><p>进程是一个拥有一定独立功能的程序关于某个数据集合的一次运行活动</p>
<p>进程是操作系统进行资源分配和调度的一个独立单位</p>
<h4 id="1-3-1-进程、线程区别"><a href="#1-3-1-进程、线程区别" class="headerlink" title="1.3.1 进程、线程区别"></a>1.3.1 进程、线程区别</h4><p>进程作为系统资源分配和保护的独立单位，不需要频繁的切换。</p>
<p>线程作为系统调度和分派的基本单位，能轻装运行，能被频繁的调度和切换。</p>
<p>OS感知线程的环境下，处理器调度线程；不感知线程的环境下，处理器调度进程，进程中的用户调度程序调度线程。</p>
<h4 id="1-3-2-内核级线程"><a href="#1-3-2-内核级线程" class="headerlink" title="1.3.2 内核级线程"></a>1.3.2 内核级线程</h4><ol>
<li><p>线程的管理工作由OS负责；</p>
</li>
<li><p>进程中一个线程被阻塞，OS能调用同一进程的其他线程占有处理器运行；</p>
</li>
<li><p>应用程序线程运行在用户态，调度管理在内核实现，切换线程时需要模式切换，系统开销大。</p>
</li>
</ol>
<h4 id="1-3-3-用户级线程"><a href="#1-3-3-用户级线程" class="headerlink" title="1.3.3 用户级线程"></a>1.3.3 用户级线程</h4><ol>
<li>线程管理工作由应用程序完成，内核没有意识到线程的存在；</li>
<li>线程切换不需要切换模式；</li>
<li>运行进程按应用需要选择调度算法；</li>
<li>不依赖OS；</li>
<li>不能利用多处理器优点；</li>
<li>一个线程阻塞，将引起整个进程阻塞。</li>
</ol>
<p>​    <strong>混合式策略：</strong></p>
<p>​    多个用户线程与多个内核线程建立绑定关系。</p>
<h4 id="1-3-4-四种线程创建方式"><a href="#1-3-4-四种线程创建方式" class="headerlink" title="1.3.4 四种线程创建方式"></a>1.3.4 四种线程创建方式</h4><ol>
<li>继承Thread重写run</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//此处为thread执行的任务内容</span></span><br><span class="line">		System.out.println(Thread.currentThread().getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>实现Runnable接口重写run，用其实例初始化Thread<strong>（推荐使用）</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//此处为thread执行的任务内容</span></span><br><span class="line">		System.out.println(Thread.currentThread().getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread());</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么推荐使用Runnable来创建线程<ol>
<li><strong>Runnable与Thread是组合的关系，Thread的run方法，实际上就是调用的Runnable的run方法</strong></li>
<li><strong>Runnable（实际执行的任务），这种格式更容易与其他API配合，拖了Thread，灵活性强。</strong></li>
</ol>
</li>
</ul>
<ol start="3">
<li><p>实现Callable接口重写call，用其实例初始化FutureTask，用FutureTask实例初始化Thread</p>
<p><strong>只是比Runnable多个get返回值，给其他线程</strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"running..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(task, <span class="string">"t1"</span>);</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取返回值，给其他线程</span></span><br><span class="line">Integer result = task.get();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>线程池创建</li>
</ol>
<h3 id="1-4-线程状态"><a href="#1-4-线程状态" class="headerlink" title="1.4 线程状态"></a>1.4 线程状态</h3><h4 id="1-4-1-线程状态概述"><a href="#1-4-1-线程状态概述" class="headerlink" title="1.4.1 线程状态概述"></a>1.4.1 线程状态概述</h4><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在<strong>线程的生命周期</strong>中这各个<strong>线程状态</strong>发生的条件，下面将会对每种状态进行详细解析：<br><img src="https://img-blog.csdnimg.cn/20191007120702449.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（1）Runnable(可运行)<br>线程可以在java虚拟机中运行的状态，<strong>可能正在运行自己代码，也可能没有，这取决于操作系统处理器（cpu）</strong>。</p>
<p>​    <strong>Java将操作系统中线程运行和就绪合并为运行状态。</strong></p>
<p>（2）Blocked(锁阻塞)<br>当一个线程试图获取一个对象锁，<strong>而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。</strong></p>
<p>（3）Waiting(无限等待)<br>一个线程在<strong>等待另一个线程执行一个（唤醒）动作时</strong>，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，<strong>必须等待另一个线程调用notify或者notifyAll方法才能够唤醒</strong>。</p>
<p>我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几个状态呢，新建与被终止还是很容易理解的，我们就研究一下<strong>线程从Runnable（可运行）状态与非运行状态之间的转换问题</strong>。</p>
<h4 id="1-4-2-Timed-Waiting（计时等待）"><a href="#1-4-2-Timed-Waiting（计时等待）" class="headerlink" title="1.4.2 Timed Waiting（计时等待）"></a>1.4.2 Timed Waiting（计时等待）</h4><p>Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。在我们写卖票的案例中，<strong>为了减少线程执行太快，现象不明显等问题</strong>，我们在run方法中添加了<strong>sleep语句</strong>，这样就<strong>强制当前正在执行的线程休眠（暂停执行），以“减慢线程”</strong>。</p>
<p><strong>sleep就是等待。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 卖票操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//开启线程锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                String name = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name + <span class="string">"正在卖"</span> + ticket--);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//关闭线程锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们需要记住下面几点：</p>
<ol>
<li>进入 TIMED_WAITING 状态的一种常见情形是<strong>调用的 sleep 方法</strong>，单独的线程也可以调用，不一定非要有协<br>作关系。</li>
<li>为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程<br>中会睡眠</li>
<li><strong>sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态</strong>。<br><img src="https://img-blog.csdnimg.cn/20191007121725479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<h4 id="1-4-3-BLOCKED（锁阻塞）"><a href="#1-4-3-BLOCKED（锁阻塞）" class="headerlink" title="1.4.3 BLOCKED（锁阻塞）"></a>1.4.3 BLOCKED（锁阻塞）</h4><p>Blocked状态在API中的介绍为：一个正在阻塞<strong>等待一个监视器锁（锁对象）的线程</strong>处于这一状态。<br>比如，线程A与线程B代码中使用同一锁，<strong>如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。</strong><br><img src="https://img-blog.csdnimg.cn/20191007121939722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="1-4-4-Waiting（无限等待）"><a href="#1-4-4-Waiting（无限等待）" class="headerlink" title="1.4.4 Waiting（无限等待）"></a>1.4.4 Waiting（无限等待）</h4><p>一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。<br><img src="https://img-blog.csdnimg.cn/20191007123214690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入了Waiting（无限等待）状态，同时失去了同步锁。<strong>假如这个时候B线程获取到了同步锁，在运行状态中调用了notify()方法，那么就会将无限等待的A线程唤醒</strong>。注意是唤醒，如果A获取到锁对象，那么A线程唤醒后就进入Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。</p>
<h4 id="1-4-5-补充"><a href="#1-4-5-补充" class="headerlink" title="1.4.5 补充"></a>1.4.5 补充</h4><p>线程状态整体概括：<br><img src="https://img-blog.csdnimg.cn/20191007123300449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="1-5-线程调度"><a href="#1-5-线程调度" class="headerlink" title="1.5 线程调度"></a>1.5 线程调度</h3><h4 id="1-5-1-三级调度"><a href="#1-5-1-三级调度" class="headerlink" title="1.5.1 三级调度"></a>1.5.1 三级调度</h4><p>高级调度：从后备作业队列中选取作业加入主存（新建态-&gt;就绪态）</p>
<p>中级调度：进程的挂起与唤醒（挂起：使一个进程暂时失去与其他进程竞争处理器的机会）</p>
<p>低级调度：又称进程调度、短程调度、处理器调度，按照某种原则把处理器分配给就绪进程或内核级进程。</p>
<h4 id="1-5-2-优先级调度算法（时间相关）"><a href="#1-5-2-优先级调度算法（时间相关）" class="headerlink" title="1.5.2 优先级调度算法（时间相关）"></a>1.5.2 优先级调度算法（时间相关）</h4><ol>
<li><p>计算时间短优先</p>
</li>
<li><p>剩余计算时间短优先</p>
</li>
<li><p>高响应比优先（响应比 = 等待时间 / 进入时间）</p>
</li>
<li><p>先来先服务</p>
</li>
<li><p>时间片轮转调度算法（常用作先来先服务的改进）</p>
</li>
</ol>
<h4 id="1-5-3-分级调度算法"><a href="#1-5-3-分级调度算法" class="headerlink" title="1.5.3 分级调度算法"></a>1.5.3 分级调度算法</h4><p>​    基于时间片轮转调度。不同优先级建立不同的队列，优先级越高的进程，时间片越短。</p>
<h2 id="二、锁"><a href="#二、锁" class="headerlink" title="二、锁"></a>二、锁</h2><h3 id="2-1-并发机制的底层实现"><a href="#2-1-并发机制的底层实现" class="headerlink" title="2.1 并发机制的底层实现"></a>2.1 并发机制的底层实现</h3><h4 id="2-1-1-Volatile的实现原理"><a href="#2-1-1-Volatile的实现原理" class="headerlink" title="2.1.1 Volatile的实现原理"></a>2.1.1 Volatile的实现原理</h4><p>​    在<a href="https://rnang0.github.io/2020/07/13/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A06%EF%BC%9AJVM/" target="_blank" rel="noopener">JVM</a>中已经详细阐述Volatile如何实现可见性，但他不保证原子性，因为他没加锁，不能解决指令交错的问题。</p>
<h5 id="2-1-1-1-CAS"><a href="#2-1-1-1-CAS" class="headerlink" title="2.1.1.1 CAS"></a>2.1.1.1 CAS</h5><p>​    CompareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子类型。</p>
<p>​    <strong>CAS必须借助volatile来实现读取到共享数据的最新值从而进行比较交换的效果。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取余额的最新值</span></span><br><span class="line">            <span class="keyword">int</span> prev = money.get();</span><br><span class="line">            <span class="comment">// 要修改的余额</span></span><br><span class="line">            <span class="keyword">int</span> next = prev - amount;</span><br><span class="line">            <span class="comment">// money必须是原子类型，底层value被Volatile修饰</span></span><br><span class="line">            <span class="keyword">if</span>(money.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;	  <span class="comment">//如果最新的余额与之前的余额不一致继续下一轮循环，一致则退出循环	</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    compareAndSet 正是做这个检查，在set前，先比较prev与当前值         </p>
<ul>
<li>不一致了，next 作废，返回 false 表示失败，比如，别的线程已经做了减法，当前值已经被减成了 990 ，那么本线程的这次 990 就作废了，进入 while 下次循环重试</li>
<li>一致，<strong>以 next 设置为新值</strong>，返回 true 表示成功</li>
</ul>
<h4 id="2-1-2-synchronized的实现原理"><a href="#2-1-2-synchronized的实现原理" class="headerlink" title="2.1.2 synchronized的实现原理"></a>2.1.2 synchronized的实现原理</h4><p>​    synchronize又被称作<strong>对象锁（Monitor对象）</strong>，是一种<strong>阻塞性</strong>的锁。</p>
<p><strong>synchronized底层实际上是通过管程Monitor来实现</strong>，那么如何给对象用synchronized上锁呢？</p>
<img src="https://img-blog.csdnimg.cn/20200729081026811.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" style="zoom: 50%;" />

<p>（1）Java对象的对象头中的Mark Word，指向一个管程Monitor对象的指针。</p>
<p>（2）对象中锁标志位从01-&gt;10，然后当前线程指向管程中的owner部分，表示拥有该管程。</p>
<p>（3）下一个线程来了，发现该对象有锁（标志位判断），然后继续看对象指向的Monitor他的owner，发现有线程指向，则进入EntryList阻塞。</p>
<p>（4）线程将临界资源用完后，就不指向owner了，就从EntryList中拿线程去指向Monitor</p>
<img src="https://img-blog.csdnimg.cn/20200729081112101.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" style="zoom:150%;" />

<p>​    <strong>总结：让作为锁的对象关联一个管程，管程才是真正意义上的锁，使用成本太高，但是具有原子性。</strong></p>
<h4 id="2-1-3-Lock锁"><a href="#2-1-3-Lock锁" class="headerlink" title="2.1.3 Lock锁"></a>2.1.3 Lock锁</h4><p>​    java.util.concurrent.locks.Lock 机制提供了比synchronized代码块和synchronized方法<strong>更广泛的锁定操作</strong>,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。</p>
<p>​    <strong>显示的创建锁，锁获取和释放，具有可操作性，可以中断的获取锁，超时获取锁；而synchronized则是隐式的获取锁，锁获取和释放都固化了，就先获取再释放。（不能像Lock实现类ReetrantLook一样可重入，再次获取锁）</strong></p>
<p>​    <strong>Lock锁也称同步锁</strong>，加锁与释放锁 方法化了，如下：<br>​    <strong>public void lock() :加同步锁。<br>​    public void unlock() :释放同步锁。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟票</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mango</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多线程共享数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个lock锁对象</span></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 卖票操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//同步方法</span></span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                String name = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name + <span class="string">"正在卖"</span> + ticket--);</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-锁升级"><a href="#2-2-锁升级" class="headerlink" title="2.2 锁升级"></a>2.2 锁升级</h3><h4 id="2-2-1-轻量级锁"><a href="#2-2-1-轻量级锁" class="headerlink" title="2.2.1 轻量级锁"></a>2.2.1 轻量级锁</h4><p>​    适用场景：多线程访问在同一周期（一段时间）内没有竞争发生。</p>
<p>​    它实际上对使用者是透明的，语法依然是synchronized，<strong>每次会尝试先加轻量级锁，进行CAS操作。</strong></p>
<ol>
<li><strong>CAS操作：对象头的Mark Word 尝试复制到 栈帧中的锁记录中，成功，则获取锁，失败则其他对象竞争锁，进行锁膨胀；自己重入获取锁的话，则进行重入计数。</strong></li>
</ol>
<ul>
<li><strong>锁膨胀：为对象申请Monitor，让对象指向Monitor锁地址。</strong></li>
</ul>
<p>​    结束后（退出synchronized代码块时），再使用CAS操作。</p>
<ol start="2">
<li><strong>CAS操作：讲栈帧中的锁记录，恢复给对象头的Mark Word值，成功，则解锁成功，失败则说明已经膨胀为重量级锁，实行重量级锁的解锁流程。</strong></li>
</ol>
<h4 id="2-2-2-偏向锁"><a href="#2-2-2-偏向锁" class="headerlink" title="2.2.2 偏向锁"></a>2.2.2 偏向锁</h4><p>​    轻量级锁如果没竞争，每次都要CAS操作，所以可以使用锁优化：</p>
<p>​    第一次CAS时，将线程ID设置到对象的Mark Word头，之后发现线程ID无竞争，则不用CAS，只需要判断线程ID。</p>
<p>​    何时撤销偏向锁？</p>
<ul>
<li>调用对象的hashCode方法，因为<strong>hashCode值会被存入轻量级中的锁记录，重量级锁中的Monitor中。</strong></li>
<li>其他线程使用，自然就会撤销掉偏向锁，升级为轻量级锁。</li>
<li>wait和notify，它们是重量级锁的机制。</li>
</ul>
<h3 id="2-3-悲观锁-乐观锁"><a href="#2-3-悲观锁-乐观锁" class="headerlink" title="2.3 悲观锁 -乐观锁"></a>2.3 悲观锁 -乐观锁</h3><h4 id="2-3-1-管程-悲观锁"><a href="#2-3-1-管程-悲观锁" class="headerlink" title="2.3.1 管程-悲观锁"></a>2.3.1 管程-悲观锁</h4><p>​    管程实际上是抽象相关并发进程对共享变量的访问。</p>
<ul>
<li><p>条件变量：检测互斥的标志</p>
</li>
<li><p>同步<strong>原语wait</strong>：进程无法获取资源时，阻塞进程；<strong>原语signal</strong>：进程释放资源时，唤醒（notify）等待队列</p>
</li>
<li><p>管程局部变量：进程共享变量，过程实际上就是对管程局部变量的操作</p>
</li>
</ul>
<h4 id="2-3-2-无锁并发-乐观锁"><a href="#2-3-2-无锁并发-乐观锁" class="headerlink" title="2.3.2 无锁并发-乐观锁"></a>2.3.2 无锁并发-乐观锁</h4><p>​    乐观锁实际上没有锁，CAS和Volatile结合可以实现无锁并发，不使用synchronized关键字，适用于线程少 ，多核CPU的场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountCas</span> <span class="keyword">implements</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger balance;  <span class="comment">//使用原子整形AtomicInteger，底层是用的Volatile，实现每次拿到最新值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountCas</span><span class="params">(<span class="keyword">int</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = <span class="keyword">new</span> AtomicInteger(balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance.get();    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取余额的最新值</span></span><br><span class="line">            <span class="keyword">int</span> prev = balance.get();</span><br><span class="line">            <span class="comment">// 要修改的余额</span></span><br><span class="line">            <span class="keyword">int</span> next = prev - amount;</span><br><span class="line">            <span class="comment">// 真正修改</span></span><br><span class="line">            <span class="keyword">if</span>(balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;	  <span class="comment">//如果最新的余额与之前的余额不一致继续下一轮循环，一致则退出循环	</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-3-悲观锁-乐观锁比较"><a href="#2-3-3-悲观锁-乐观锁比较" class="headerlink" title="2.3.3 悲观锁-乐观锁比较"></a>2.3.3 悲观锁-乐观锁比较</h4><ul>
<li>CAS是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃点亏再重试呗。</li>
<li>synchronized是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li>
<li>CAS体现的是无锁并发、无阻塞并发：<ul>
<li>因为没有使用synchronized，所以线程不会陷入阻塞，这是提升效率的因素之一</li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率可能会受到影响</li>
</ul>
</li>
</ul>
<ol>
<li>注：为什么无锁就效率高呢？</li>
</ol>
<ul>
<li>无锁情况下，线程始终高速运转，没有停歇，而synchronized会让没有获取锁的线程，发生上下文切换，进入阻塞。（重新打火一样，代价太大）</li>
</ul>
<ol start="2">
<li>但无锁情况下，线程需要高速运转，需要cpu的支持，<strong>如果没有额外的cpu核数，线程就无法高速运转，虽然不会阻塞，但由于分不到时间片还是回上下文切换。</strong>所以要求线程数低于CPU核数，才能发挥优势。</li>
</ol>
<h2 id="三、原子类"><a href="#三、原子类" class="headerlink" title="三、原子类"></a>三、原子类</h2><h3 id="3-1-原子整数"><a href="#3-1-原子整数" class="headerlink" title="3.1 原子整数"></a>3.1 原子整数</h3><p>​    是对整数类包装类的封装，使用CAS实现内部的线程安全性，使用volatile来保证可见性，读取到最新值。</p>
<h3 id="3-2-原子引用"><a href="#3-2-原子引用" class="headerlink" title="3.2 原子引用"></a>3.2 原子引用</h3><p>​    ABA问题：即该线程查觉不到共享变量被修改过，但希望能判断其他线程使用过 （修改过），这时使得自己的CAS失效，返回false。</p>
<p>​    <strong>解决办法：加一个版本号，使得每次修改都使得版本号+1</strong></p>
<p><em>AtomicStamptdReference就是如此，还可以根据版本号的值来判断修改次数，但有时为了简单不需要关系修改次数，则使用AtomicMarkableReference，他可以返回布尔类型值，只关心判断是否修改。</em></p>
<h3 id="3-3-原子数组"><a href="#3-3-原子数组" class="headerlink" title="3.3 原子数组"></a>3.3 原子数组</h3><p><strong>不安全的数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">demo(</span><br><span class="line">	 ()-&gt;<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>],</span><br><span class="line">	 (array)-&gt;array.length,</span><br><span class="line">	 (array, index) -&gt; array[index]++,</span><br><span class="line">	 array-&gt; System.out.println(Arrays.toString(array))</span><br><span class="line">);</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p><strong>安全的数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">demo(</span><br><span class="line">	 ()-&gt; <span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>),</span><br><span class="line">	 (array) -&gt; array.length(),</span><br><span class="line">	 (array, index) -&gt; array.getAndIncrement(index),</span><br><span class="line">	 array -&gt; System.out.println(array)</span><br><span class="line">);</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-字段更新器"><a href="#3-4-字段更新器" class="headerlink" title="3.4 字段更新器"></a>3.4 字段更新器</h3><p>​    保护的是类的字段（成员变量），而且字段必须volatile修饰，否则会出现异常。</p>
<p><code>Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Must be volatile type</code></p>
<h3 id="3-5-原子累加器"><a href="#3-5-原子累加器" class="headerlink" title="3.5 原子累加器"></a>3.5 原子累加器</h3><p>​    JDK8之后专门提供了几个类，来做原子的累加，性能要高很多。</p>
<p>性能提升的原因很简单，就是在有竞争时，<strong>设置多个累加单元</strong>，不是只在一个变量上加。因此<strong>减少了 CAS 重试失败</strong>，从而提高性能。</p>
<h2 id="四、线程池"><a href="#四、线程池" class="headerlink" title="四、线程池"></a>四、线程池</h2><h3 id="4-1-线程池优势"><a href="#4-1-线程池优势" class="headerlink" title="4.1 线程池优势"></a>4.1 线程池优势</h3><p>​    合理利用线程池能够带来三个好处：</p>
<ol>
<li><p>降低资源消耗。<strong>减少了线程创建销毁的过程（节约资源），每个工作线程都可以被重复利用</strong>，可执行多个任务。</p>
</li>
<li><p><strong>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</strong></p>
</li>
<li><p>提高线程的可管理性。可以根据系统的承受能力，<strong>调整线程池中工作线线程的数目。</strong></p>
<p>防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</p>
</li>
</ol>
<p><img src="C:%5CUsers%5CMango%5CDesktop%5C20200725213522417.png" alt=""></p>
<h3 id="4-2-ThreadPoolExecutor"><a href="#4-2-ThreadPoolExecutor" class="headerlink" title="4.2 ThreadPoolExecutor"></a>4.2 ThreadPoolExecutor</h3><p>​    java中线程池的顶级接口是java.util.concurrent.Executor，但它并不是一个线程池，而只是一个执行线程的工具，真正的线程池接口是java.util.concurrent.ExecutorService</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9teS1ibG9nLXRvLXVzZS5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vMjAxOS03LyVFNCVCQiVCQiVFNSU4QSVBMSVFNyU5QSU4NCVFNiU4OSVBNyVFOCVBMSU4QyVFNyU5QiVCOCVFNSU4NSVCMyVFNiU4RSVBNSVFNSU4RiVBMy5wbmc?x-oss-process=image/format,png" alt=""></p>
<h4 id="4-2-1-线程池状态"><a href="#4-2-1-线程池状态" class="headerlink" title="4.2.1 线程池状态"></a>4.2.1 线程池状态</h4><p><img src="C:%5CUsers%5CMango%5CDesktop%5C20200725210852400.png" alt=""></p>
<ul>
<li>shutdown状态与stop状态：</li>
</ul>
<ol>
<li>shutdown状态，不会接受新任务，把阻塞队列中的继续执行完</li>
<li>stop状态，立即中断，抛弃阻塞队列中的任务</li>
</ol>
<h4 id="4-2-2-线程池构造方法，参数说明"><a href="#4-2-2-线程池构造方法，参数说明" class="headerlink" title="4.2.2 线程池构造方法，参数说明"></a>4.2.2 线程池构造方法，参数说明</h4><p><img src="https://img-blog.csdnimg.cn/20200725211002613.png" alt="img"></p>
<h4 id="4-2-3-ScheduledThreadPoolExecutor"><a href="#4-2-3-ScheduledThreadPoolExecutor" class="headerlink" title="4.2.3 ScheduledThreadPoolExecutor"></a>4.2.3 ScheduledThreadPoolExecutor</h4><p>​    <strong>功能：带有任务调度功能，可以延时执行，定时执行</strong></p>
<h3 id="4-3-拒绝策略"><a href="#4-3-拒绝策略" class="headerlink" title="4.3 拒绝策略"></a>4.3 拒绝策略</h3><p>​    先来说一下JDK线程池的执行过程：</p>
<ol>
<li>线程池开始没线程，任务交给后，开始创建执行任务，任务达到corePoolSize（核心线程数）时，这时任务进入阻塞队列。</li>
<li>如果设置为有界队列，任务超出阻塞队列大小时，则会创建maximumPoolSize 减去 corePoolSize这么多线程来救急。</li>
<li>线程到达maximumPoolSize仍然有新任务，<strong>这时就会执行拒绝策略。</strong></li>
<li>高峰期过去，超过corePoolSize的线程长时间没有task任务做，则结束释放资源。</li>
</ol>
<ul>
<li>拒绝策略：</li>
</ul>
<ol>
<li>默认：抛出RejectedExecutionException异常</li>
<li>运行任务</li>
<li>放弃</li>
<li><strong>Netty的实现：创建新线程来执行</strong></li>
<li><strong>ActiveMq的实现：带超时等待（60s）尝试放入队列</strong></li>
<li>。。。。等等</li>
</ol>
<h3 id="4-4-Fork-Join线程池"><a href="#4-4-Fork-Join线程池" class="headerlink" title="4.4 Fork/Join线程池"></a>4.4 Fork/Join线程池</h3><p>​    Fork/Join ：拆分 + 合并，采用分治的思想，适用于能够进行任务拆分的cpu密集型运算。（线程数 = cpu）</p>
<p>​    在分治的基础上，加入了多线程，可以把每个任务分解合并交给不同的线程来完成，提高效率，默认创建与cpu核心数相同的线程池。</p>
<h2 id="五、并发工具类"><a href="#五、并发工具类" class="headerlink" title="五、并发工具类"></a>五、并发工具类</h2><ol>
<li>永远只在更新对象的成员变量时加锁</li>
<li>永远只在访问可变的成员变量时加锁</li>
<li>永远不在调用其他对象的方法时加锁（其他方法内部可能有锁，或者执行时间过长）</li>
</ol>
<h3 id="5-1-AQS"><a href="#5-1-AQS" class="headerlink" title="5.1 AQS"></a>5.1 AQS</h3><p>​    抽象队列同步器，三要素：</p>
<ol>
<li><p>资源变量</p>
</li>
<li><p>对资源变量的操作集合</p>
</li>
<li><p>阻塞、唤醒线程的方法</p>
</li>
</ol>
<p>相比于synchronize，能够：</p>
<ol>
<li><p>响应中断</p>
</li>
<li><p>支持超时</p>
</li>
<li><p>非阻塞的获取锁</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200722214851443.png" alt="在这里插入图片描述"> </p>
<p>ReentrantLock：可重入锁，即同一线程可以重复获取同一把锁。</p>
<p>ReentrantLock默认构造函数是创建非公平锁。非公平锁即在有线程释放锁时，随机唤醒阻塞队列中的一个线程；公平锁即在有线程释放锁时，唤醒等待时间最长的线程。</p>
<p>ReadWriteLock：读写锁，支持共享锁和排它锁。</p>
<p>StampedLock：支持乐观读、悲观读和写锁（避免了写线程饥饿）。</p>
<h3 id="5-2-并发容器"><a href="#5-2-并发容器" class="headerlink" title="5.2 并发容器"></a>5.2 并发容器</h3><p><img src="https://img-blog.csdnimg.cn/20200722214857269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="5-3-信号量"><a href="#5-3-信号量" class="headerlink" title="5.3 信号量"></a>5.3 信号量</h3><p>Semaphore</p>
<p>信号量模型：一个计数器，一个等待队列，三个方法</p>
<p> <img src="https://img-blog.csdnimg.cn/20200722214903119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="ConcurrentHashMap比HashTable的优点"><a href="#ConcurrentHashMap比HashTable的优点" class="headerlink" title="ConcurrentHashMap比HashTable的优点"></a>ConcurrentHashMap比HashTable的优点</h4><p>将整个map分为N段，操作时只锁一段。</p>
<p> <img src="https://img-blog.csdnimg.cn/20200722214908422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">rnang0</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/07/25/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A07%EF%BC%9AJava%E5%B9%B6%E5%8F%91/">http://yoursite.com/2020/07/25/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A07%EF%BC%9AJava%E5%B9%B6%E5%8F%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">rnang0 Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a><a class="post-meta__tags" href="/tags/%E9%94%81/">锁</a></div><div class="post_share"><div class="social-share" data-image="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=4060513360,1461496884&amp;fm=26&amp;gp=0.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/07/13/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A06%EF%BC%9AJVM/"><img class="next_cover" src="https://img-blog.csdnimg.cn/20200718152358438.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">春招复习6：JVM</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/06/23/春招复习4：操作系统/" title="春招复习4：操作系统"><img class="relatedPosts_cover" src="https://img-blog.csdnimg.cn/20200624114032370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-23</div><div class="relatedPosts_title">春招复习4：操作系统</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/13/春招复习6：JVM/" title="春招复习6：JVM"><img class="relatedPosts_cover" src="https://img-blog.csdnimg.cn/20200718152358438.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-13</div><div class="relatedPosts_title">春招复习6：JVM</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By rnang0</div><div class="footer_custom_text">Hi, welcome to my <a href="http://rnang0.github.io/" target="_blank" rel="noopener">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script></body></html>