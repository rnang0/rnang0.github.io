<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>春招复习6：JVM | rnang0 Blog</title><meta name="description" content="JVM重点内容 类加载机制 运行时数据区域 字节码执行机制 GC垃圾回收 JVM内存模型  一、类加载机制​    类的生命周期：加载、验证、准备、解析、初始化、使用、卸载 1.1 类加载的时机​    有且只有这几种情况必须对类进行加载： (1)  遇到new、getstatic、putstatic或invokestatic四条指令时，会生成四条指令的场景：  使用new实例化对象时  读取或设"><meta name="keywords" content="锁,JVM,Java内存模型"><meta name="author" content="rnang0"><meta name="copyright" content="rnang0"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="春招复习6：JVM"><meta name="twitter:description" content="JVM重点内容 类加载机制 运行时数据区域 字节码执行机制 GC垃圾回收 JVM内存模型  一、类加载机制​    类的生命周期：加载、验证、准备、解析、初始化、使用、卸载 1.1 类加载的时机​    有且只有这几种情况必须对类进行加载： (1)  遇到new、getstatic、putstatic或invokestatic四条指令时，会生成四条指令的场景：  使用new实例化对象时  读取或设"><meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200718152358438.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70"><meta property="og:type" content="article"><meta property="og:title" content="春招复习6：JVM"><meta property="og:url" content="http://rnang0.github.io/2020/07/13/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A06%EF%BC%9AJVM/"><meta property="og:site_name" content="rnang0 Blog"><meta property="og:description" content="JVM重点内容 类加载机制 运行时数据区域 字节码执行机制 GC垃圾回收 JVM内存模型  一、类加载机制​    类的生命周期：加载、验证、准备、解析、初始化、使用、卸载 1.1 类加载的时机​    有且只有这几种情况必须对类进行加载： (1)  遇到new、getstatic、putstatic或invokestatic四条指令时，会生成四条指令的场景：  使用new实例化对象时  读取或设"><meta property="og:image" content="https://img-blog.csdnimg.cn/20200718152358438.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70"><meta property="article:published_time" content="2020-07-12T16:00:00.000Z"><meta property="article:modified_time" content="2020-07-26T06:16:52.652Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="canonical" href="http://rnang0.github.io/2020/07/13/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A06%EF%BC%9AJVM/"><link rel="prev" title="春招复习7：Java并发" href="http://rnang0.github.io/2020/07/25/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A07%EF%BC%9AJava%E5%B9%B6%E5%8F%91/"><link rel="next" title="春招复习5：计算机网络" href="http://rnang0.github.io/2020/06/28/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A05%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'none',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/autor.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">74</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">105</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-mars"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM"><span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#重点内容"><span class="toc-text">重点内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一、类加载机制"><span class="toc-text">一、类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-类加载的时机"><span class="toc-text">1.1 类加载的时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-类加载过程"><span class="toc-text">1.2 类加载过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-类加载器"><span class="toc-text">1.3 类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-双亲委派机制"><span class="toc-text">1.4 双亲委派机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、JAVA内存区域与内存溢出异常"><span class="toc-text">二、JAVA内存区域与内存溢出异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Java运行时数据区域"><span class="toc-text">2.1 Java运行时数据区域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-程序计数器"><span class="toc-text">2.1.1 程序计数器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-虚拟机栈"><span class="toc-text">2.1.2 虚拟机栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-本地方法栈"><span class="toc-text">2.1.3 本地方法栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-堆"><span class="toc-text">2.1.4 堆</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-4-1-Java堆与JVM栈的关系："><span class="toc-text">2.1.4.1 Java堆与JVM栈的关系：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-4-2-对象栈上分配"><span class="toc-text">2.1.4.2 对象栈上分配</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-5-方法区"><span class="toc-text">2.1.5 方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-5-1-方法区、堆、JVM栈之间的交互关系："><span class="toc-text">2.1.5.1 方法区、堆、JVM栈之间的交互关系：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-6-直接内存"><span class="toc-text">2.1.6 直接内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-对象的创建、内存布局与访问"><span class="toc-text">2.2 对象的创建、内存布局与访问</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-对象的创建"><span class="toc-text">2.2.1 对象的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1-1-对象创建的方式"><span class="toc-text">2.2.1.1 对象创建的方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1-2-对象创建的步骤"><span class="toc-text">2.2.1.2 对象创建的步骤</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-对象的内存布局"><span class="toc-text">2.2.2 对象的内存布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-对象的访问定位"><span class="toc-text">2.2.3 对象的访问定位</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-OutOfMemoryError异常（OOM异常）"><span class="toc-text">2.3 OutOfMemoryError异常（OOM异常）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-内存溢出与内存泄露（面试）"><span class="toc-text">2.4 内存溢出与内存泄露（面试）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、垃圾收集器与内存分配策略"><span class="toc-text">三、垃圾收集器与内存分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-补充：执行引擎"><span class="toc-text">3.1 补充：执行引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-标记阶段（对象是否存活）"><span class="toc-text">3.2 标记阶段（对象是否存活）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-引用计数算法（不用）"><span class="toc-text">3.2.1 引用计数算法（不用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-可达性分析算法（JVM使用）"><span class="toc-text">3.2.2 可达性分析算法（JVM使用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-引用"><span class="toc-text">3.2.3 引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-自救（不使用）"><span class="toc-text">3.2.4 自救（不使用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-回收方法区"><span class="toc-text">3.2.5 回收方法区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-垃圾收集算法"><span class="toc-text">3.3 垃圾收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-标记-清除算法"><span class="toc-text">3.3.1 标记-清除算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-复制算法"><span class="toc-text">3.3.2 复制算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-标记-整理算法"><span class="toc-text">3.3.3 标记-整理算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-4-分代收集理论"><span class="toc-text">3.3.4 分代收集理论</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-HotSpot算法细节实现"><span class="toc-text">3.4 HotSpot算法细节实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-根节点枚举"><span class="toc-text">3.4.1 根节点枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-安全点"><span class="toc-text">3.4.2 安全点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-安全区域"><span class="toc-text">3.4.3 安全区域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-4-记忆集与卡表"><span class="toc-text">3.4.4 记忆集与卡表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-5-并发的可达性分析"><span class="toc-text">3.4.5 并发的可达性分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-经典垃圾收集器"><span class="toc-text">3.5 经典垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-Serial收集器"><span class="toc-text">3.5.1 Serial收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2-ParNew收集器（与CMS组合）"><span class="toc-text">3.5.2 ParNew收集器（与CMS组合）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-3-Parallel-Scavenge收集器"><span class="toc-text">3.5.3 Parallel Scavenge收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-4-Serial-Old收集器"><span class="toc-text">3.5.4 Serial Old收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-5-Parallel-Old收集器"><span class="toc-text">3.5.5 Parallel Old收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-6-CMS收集器"><span class="toc-text">3.5.6 CMS收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-7-G1收集器"><span class="toc-text">3.5.7 G1收集器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-低延迟GC"><span class="toc-text">3.6 低延迟GC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-1-Shenandoah收集器"><span class="toc-text">3.6.1 Shenandoah收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-2-ZGC"><span class="toc-text">3.6.2 ZGC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-内存分配策略"><span class="toc-text">3.7 内存分配策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、Java内存模型与线程"><span class="toc-text">四、Java内存模型与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Java内存模型"><span class="toc-text">4.1 Java内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-主内存与工作内存"><span class="toc-text">4.1.1 主内存与工作内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-内存间交互操作"><span class="toc-text">4.1.2 内存间交互操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-Volatile"><span class="toc-text">4.1.3 Volatile</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-线程"><span class="toc-text">4.2 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-Java线程调度"><span class="toc-text">4.2.1 Java线程调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-状态转换"><span class="toc-text">4.2.2 状态转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、JVM常用参数"><span class="toc-text">五、JVM常用参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-标准参数"><span class="toc-text">5.1 标准参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Verbose"><span class="toc-text">Verbose</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-扩展参数-X"><span class="toc-text">5.2 扩展参数(-X)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#内存大小"><span class="toc-text">内存大小</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-非Stable参数-XX"><span class="toc-text">5.3 非Stable参数(-XX)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、锁"><span class="toc-text">六、锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-锁优化"><span class="toc-text">6.1 锁优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-自旋锁与自适应自旋"><span class="toc-text">6.1.1 自旋锁与自适应自旋</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-锁消除"><span class="toc-text">6.1.2 锁消除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-3-锁粗化"><span class="toc-text">6.1.3 锁粗化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-4-轻量级锁"><span class="toc-text">6.1.4 轻量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-5-偏向锁"><span class="toc-text">6.1.5 偏向锁</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://img-blog.csdnimg.cn/20200718152358438.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">rnang0 Blog</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-mars"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">春招复习6：JVM</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-13 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-07-13</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-26 14:16:52"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-07-26</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/">春招复习</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="重点内容"><a href="#重点内容" class="headerlink" title="重点内容"></a>重点内容</h2><ul>
<li>类加载机制</li>
<li>运行时数据区域</li>
<li>字节码执行机制</li>
<li>GC垃圾回收</li>
<li>JVM内存模型</li>
</ul>
<h2 id="一、类加载机制"><a href="#一、类加载机制" class="headerlink" title="一、类加载机制"></a>一、类加载机制</h2><p>​    类的生命周期：加载、验证、准备、解析、初始化、使用、卸载</p>
<h3 id="1-1-类加载的时机"><a href="#1-1-类加载的时机" class="headerlink" title="1.1 类加载的时机"></a>1.1 类加载的时机</h3><p>​    有且只有这几种情况必须对类进行加载：</p>
<p>(1)  遇到new、getstatic、putstatic或invokestatic四条指令时，会生成四条指令的场景：</p>
<ul>
<li><p>使用new实例化对象时</p>
</li>
<li><p>读取或设置一个静态字段（final除外）</p>
</li>
<li><p>调用静态方法</p>
</li>
</ul>
<p>(2)  对类型反射调用，没有被初始化就进行初始化</p>
<p>(3)  初始化子类时，发现父类还未初始化</p>
<p>(4)  虚拟机启动时，要执行的主类会被初始化</p>
<p>上述为主动引用，而其他方式都是被动引用，不会触发初始化。</p>
<p><strong>例如：子类调用父类静态字段、数组定义形式引用类、调用类的final静态字段</strong>则不会触发本类的初始化。</p>
<h3 id="1-2-类加载过程"><a href="#1-2-类加载过程" class="headerlink" title="1.2 类加载过程"></a>1.2 类加载过程</h3><ul>
<li>加载</li>
</ul>
<p>(1)  <strong>通过全限定类名获得此类的二进制字节流。</strong>（类加载器实现）</p>
<p>(2)  将字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>
<p>(3)  在内存中生成一个代表该类的Class对象</p>
<p>加载完成后，class文件即按照JVM设定的格式<strong>存储在方法区</strong>了。</p>
<ul>
<li><p>验证</p>
<p>作用：防止恶意攻击，不会危害虚拟机自身安全。</p>
</li>
</ul>
<p>(1)  文件格式验证：验证字节流是否符合class文件格式规范（<strong>唯一基于字节流的验证</strong>，结束后字节流内容进入内存）。</p>
<p>(2)  元数据验证：语义分析。保证其描述的信息符合java语言规范的要求。</p>
<p>(3)  <strong>字节码验证</strong>：通过数据流和控制流验证语义是否合法，保证被校验类的方法不会危害虚拟机安全。</p>
<p>(4)  符号引用验证：保证类中的引用都能正常访问。</p>
<ul>
<li>准备</li>
</ul>
<p>在<code>方法区</code>为<strong>static变量（类变量）分配内存并赋予初始值（零值）</strong>。</p>
<ul>
<li>解析</li>
</ul>
<p>将<code>常量池</code>中的<strong>符号引用替换为直接引用</strong>。</p>
<ul>
<li>初始化</li>
</ul>
<p>本质就是：即执行<clinit>()方法（构造器方法），区别于构造方法 <init></p>
<ul>
<li><p><clinit>方法是由编译器自动收集的<strong>所有static变量和static块中的语句合并</strong>而成。</p>
</li>
<li><p><clinit>不需要显式的调用父类构造器，因为jvm能保证在子类初始化前，父类已初始化结束。</p>
</li>
</ul>
<p>如果一个类没有static变量赋值操作和static块，可以不生成<clinit>。接口的初始化不需要事先初始化其父接口。其实现类也同理。</p>
<h3 id="1-3-类加载器"><a href="#1-3-类加载器" class="headerlink" title="1.3 类加载器"></a>1.3 类加载器</h3><ul>
<li><p><strong>启动类加载器</strong>(Bootstrap Class Loader):加载存放在<JAVA_HOME>\lib目录下的，并能被JVM识别的类库。</p>
<p>主要是<strong>加载核心类库</strong>（java，javax，sun），所以自定义获取时为null（没有权限获取）。</p>
</li>
<li><p><strong>扩展类加载器</strong>(Extension Class Loader):加载<JAVA_HOME>\lib\ext和java.ext.dirs系统变量所指定的目录路径中的所有类库。用于实现java类库的扩展。</p>
</li>
<li><p><strong>应用程序类加载器</strong>(Application Class Loader):也叫系统类加载器，加载应用程序中的类。自定义<strong>默认使用</strong>的类加载器。</p>
</li>
</ul>
<p>判断两个类是否相等 要在两个类由同一个ClassLoader加载完成的条件下讨论才有意义。</p>
<p>即两个类相等 &lt;=&gt; 包名相同 + 同一类加载器加载</p>
<h3 id="1-4-双亲委派机制"><a href="#1-4-双亲委派机制" class="headerlink" title="1.4 双亲委派机制"></a>1.4 双亲委派机制</h3><p>​    要求除了顶层的启动类加载器之外，其余的类加载器都应有自己的<strong>“父类”</strong>加载器。这里的父子关系<strong>一般是用组合实现</strong>（等级或包含关系不是继承关系）的。</p>
<img src="https://img-blog.csdnimg.cn/2020071621102410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" style="zoom:150%;" />

<p>工作过程：</p>
<p>​    一个类加载器收到一个类加载的请求，<strong>会把请求向父类加载器委派，每一层次都是如此</strong>，所以最终所有类加载请求都会委派到启动类加载器。<strong>当父类加载器搜索不到相应类时，才会反馈自己无法完成请求，子类加载器才会尝试加载。</strong></p>
<p>作用：</p>
<ul>
<li><strong>保证同一层级的类都由同一类加载器加载</strong>，保证了基础类型的一致性。</li>
<li>保护程序的安全，防止核心API被随缘篡改。</li>
</ul>
<h2 id="二、JAVA内存区域与内存溢出异常"><a href="#二、JAVA内存区域与内存溢出异常" class="headerlink" title="二、JAVA内存区域与内存溢出异常"></a>二、JAVA内存区域与内存溢出异常</h2><h3 id="2-1-Java运行时数据区域"><a href="#2-1-Java运行时数据区域" class="headerlink" title="2.1 Java运行时数据区域"></a>2.1 Java运行时数据区域</h3><img src="https://img-blog.csdnimg.cn/20200716211545128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" style="zoom:150%;" />

<h4 id="2-1-1-程序计数器"><a href="#2-1-1-程序计数器" class="headerlink" title="2.1.1 程序计数器"></a>2.1.1 程序计数器</h4><p>​    PC寄存器主要作为<strong>当前线程所执行的字节码的行号指示器</strong></p>
<p>​    类似于x86的IP寄存器。字节解释器工作时通过改变该计数器的值来<strong>选取下一条需要执行的指令</strong>。</p>
<p>​    分支、循环、跳转、异常处理、线程恢复等都需依赖该计数器。若正在执行的是java方法，则该计数器记录的是正在执行的字节码的地址。若正在执行的是本地(Native)方法，该计数器值为空。</p>
<p>​    唯一一个没有规定OutOfMemoryError的内存区域。</p>
<h4 id="2-1-2-虚拟机栈"><a href="#2-1-2-虚拟机栈" class="headerlink" title="2.1.2 虚拟机栈"></a>2.1.2 虚拟机栈</h4><p>​    每一个Java方法被执行时，jvm都会创建一个栈帧(Stack Frame)，来用于存储<strong>局部变量表、操作数栈、动态连接、方法出口</strong>等信息。每一个方法从被调用直至执行完毕，对应一个栈帧在虚拟机栈中从入栈到出栈。</p>
<p>​    局部变量表：用于存放方法参数和方法内部定义的局部变量。所需的内存空间在编译期间完成分配。</p>
<ul>
<li>局部变量表存放了<strong>编译期可知的</strong> 基本数据类型、对象引用(reference类型)、returnAddress类型(指向字节码的地址)</li>
<li>局部变量表空间的最小单位——局部变量槽(Slot)。<strong>Slot是32位，所以long、double占两个slot，其余占一个。</strong></li>
</ul>
<p>​    操作数栈：</p>
<p>内存溢出异常：</p>
<ol>
<li><p>当线程请求的<strong>栈深度</strong>大于虚拟机允许的深度，抛出StackOverflowError异常（栈溢出）。</p>
</li>
<li><p>若虚拟机<strong>栈容量</strong>可以动态扩展，当栈扩展到无法申请到足够内存时抛出OutOfMemory异常（内存溢出）。</p>
</li>
</ol>
<h4 id="2-1-3-本地方法栈"><a href="#2-1-3-本地方法栈" class="headerlink" title="2.1.3 本地方法栈"></a>2.1.3 本地方法栈</h4><p>​    与虚拟机栈类似。虚拟机栈为java方法提供服务，本地方法栈为本地方法提供服务。</p>
<h4 id="2-1-4-堆"><a href="#2-1-4-堆" class="headerlink" title="2.1.4 堆"></a>2.1.4 堆</h4><p>​    <strong>存放对象实例和字符串常量池、数组。几乎所有对象实例都在这里分配内存。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200719114234522.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>​    Java堆 = 新生代 + 老年代 + TLAB（每个线程私有的分配缓冲区）</p>
<p>​    虚拟机所管理的内存中最大的一块。在虚拟机启动时创建。是垃圾收集器管理的内存区域，因此也被称作GC堆。</p>
<ul>
<li><p>从回收内存的角度来看，可能包含“新生代”、“老生代”、“永久代”等。</p>
</li>
<li><p>从分配内存的角度来看，包含多个线程私有的分配缓冲区(TLAB)，以提升对象分配时的效率。将java堆细分的目的只是为了更好的回收内存，或更快的分配内存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对象分配时，TLAB作为内存分配首选，一旦对象在TLAB上分配失败就就会通过加锁（堆内存是线程共享）在eden区分配内存。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200718170618340.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt=""></p>
<ul>
<li>处于物理上不连续的内存空间中，但在逻辑上应该视为连续的。</li>
<li>可以是固定大小，也可以是可扩展的。当堆中没有内存完成实例分配，且堆也无法扩展时，抛出OOM异常。</li>
</ul>
<h5 id="2-1-4-1-Java堆与JVM栈的关系："><a href="#2-1-4-1-Java堆与JVM栈的关系：" class="headerlink" title="2.1.4.1 Java堆与JVM栈的关系："></a>2.1.4.1 Java堆与JVM栈的关系：</h5><pre><code>1. JVM栈中的引用（主要是局部变量，方法参数）指向Java堆中的对象实例。     
2. 方法执行完毕以后，只是JVM栈中的引用消失，GC时才会对Java堆中的对象进行回收。</code></pre><h5 id="2-1-4-2-对象栈上分配"><a href="#2-1-4-2-对象栈上分配" class="headerlink" title="2.1.4.2 对象栈上分配"></a>2.1.4.2 对象栈上分配</h5><p>​    逃逸分析：分析对象<strong>动态作用域。</strong></p>
<ul>
<li><p>当一个对象在方法中定义后，对象只在方法内部使用，则认为没有发生逃逸。</p>
</li>
<li><p>当一个对象在方法中定义后，对象被外部方法引用，则认为发生逃逸。</p>
<p>对象能否被分配到栈，需要使用逃逸分析手段，可以减轻堆内存分配的压力。</p>
</li>
</ul>
<p><strong>如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配，这样就不需要在堆上分配空间，也不用进行GC。</strong></p>
<h4 id="2-1-5-方法区"><a href="#2-1-5-方法区" class="headerlink" title="2.1.5 方法区"></a>2.1.5 方法区</h4><p>​    又可以叫做元空间 （在JDK1.8之前，是永久代），但是不准确。</p>
<p>​    <strong>存储已被虚拟机类加载后的类信息、常量（运行时常量池）、静态变量、即时编译器编译后的代码缓存、运行时常量池等数据。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200719114248459.jpg" alt="在这里插入图片描述"></p>
<p>​    可以选择不实现垃圾收集。该区域的内存回收目标主要是<strong>针对常量池的回收和对类型的卸载</strong>。一般回收效果较难令人满意。</p>
<p>​    方法区无法满足新的内存分配需求时，抛出OOM异常。k</p>
<p>​    <strong>运行时常量池：</strong>方法区的一部分。Class文件中的常量池表（存放编译期生成的<strong>各种字面量与符号引用</strong>）在类加载后存放到方法区的运行时常量池中。运行期间也可以将新的常量放入运行时常量池。</p>
<h5 id="2-1-5-1-方法区、堆、JVM栈之间的交互关系："><a href="#2-1-5-1-方法区、堆、JVM栈之间的交互关系：" class="headerlink" title="2.1.5.1 方法区、堆、JVM栈之间的交互关系："></a>2.1.5.1 方法区、堆、JVM栈之间的交互关系：</h5><img src="https://img-blog.csdnimg.cn/20200718171257640.jpg" style="zoom:200%;" />

<p>如上图一条Java新建对象实例语句：</p>
<ol>
<li>第一个Person是<strong>变量类型</strong>，所以存放在方法区（变量的类型，类的信息，等等）中</li>
<li>第二个person是<strong>局部变量引用</strong>，在一个方法中写的，所以放在JVM栈中</li>
<li>第三个new Person()；是一个<strong>实例化对象</strong>，所以放在Java堆中</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200718171302947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt=""></p>
<p><strong>JVM栈中为局部变量的引用，实际上是指向Java堆中的对象实例，然后对象实例又指向方法区中的对象类型。</strong></p>
<h4 id="2-1-6-直接内存"><a href="#2-1-6-直接内存" class="headerlink" title="2.1.6 直接内存"></a>2.1.6 直接内存</h4><p>​    <strong>并非虚拟机运行时数据区的一部分。</strong></p>
<p>​    NIO类引入了一种基于通道和缓冲区的IO方式，它使用Native函数库直接分配堆外内存。然后通过java堆内的DirectByteBuffer对象作为这块内存的引用进行操作。避免了在Java堆和Native堆之间来回复制数据，在一些场景提升了性能。</p>
<p>​    受物理和操作系统级内存限制，存在OOM异常。</p>
<h3 id="2-2-对象的创建、内存布局与访问"><a href="#2-2-对象的创建、内存布局与访问" class="headerlink" title="2.2 对象的创建、内存布局与访问"></a>2.2 对象的创建、内存布局与访问</h3><p>​    以HotSpot为例</p>
<h4 id="2-2-1-对象的创建"><a href="#2-2-1-对象的创建" class="headerlink" title="2.2.1 对象的创建"></a>2.2.1 对象的创建</h4><h5 id="2-2-1-1-对象创建的方式"><a href="#2-2-1-1-对象创建的方式" class="headerlink" title="2.2.1.1 对象创建的方式"></a>2.2.1.1 对象创建的方式</h5><p>​    主要分为五种方式创建：</p>
<pre><code>1. new：最常见的方式，变形有`调用类的静态方法`和`类的建造者和工厂方法来实例化`
 2. 反射：一种是Class的newInstance()，调用类的空参构造器，权限是public；一种是Constructor的newInstance(XXX类)，可以掉空参和带参的构造器，权限没有要求。
 3. clone()方法：用一个类来克隆，前提是类实现了Cloneable接口
 4. 反序列化：从文件、网络中获取一个对象的二进制流来进行反序列化成对象
 5. 第三方库Objenesls</code></pre><h5 id="2-2-1-2-对象创建的步骤"><a href="#2-2-1-2-对象创建的步骤" class="headerlink" title="2.2.1.2 对象创建的步骤"></a>2.2.1.2 对象创建的步骤</h5><p>​    <strong>①寻找符号引用：</strong>遇到new指令，检查该指令的参数<strong>是否能在常量池中定位到一个类的符号引用</strong>。</p>
<p>​    <strong>②类加载检查：</strong>该符号引用代表的类是否已被加载、链接和初始化。如果没有，先执行类加载过程（双亲委派机制）。</p>
<p>​    <strong>③内存分配：</strong>对象所需内存的大小在类加载完成后便可完全确定。</p>
<p>​    <strong>内存分配的两种方式：“指针碰撞”、“空闲列表”。</strong></p>
<ul>
<li>指针碰撞：若java堆中的<strong>内存都是绝对规整</strong>的。<strong>使用过的放在一边，空闲的放在另一边。</strong>分配内存即是将指针向空闲方向挪动与对象等大小的一段距离。</li>
<li>空闲列表：若java堆中的内存并不规整，<strong>碎片化</strong>。使用过的内存和空闲内存交错在一起。虚拟机必须维护一个<strong>空闲列表</strong>，记录哪些内存块是可用的。分配内存时找到一块足够大的空间划分给对象实例。并更新表的记录。</li>
</ul>
<p>​    <strong>Java堆是否规整由GC是否带有空间压缩整理能力决定。</strong></p>
<p>​    并发情况下内存分配安全策略：</p>
<p>​    (1)对分配空间动作进行同步处理，通过<strong>CAS配上失败重试</strong>方式，进行<strong>区域加锁</strong>保证更新操作的原子性。</p>
<p>CAS(Compare and Swap)：通过比较预期数值和新值，若相等，内存位置替换为新值。若不相等，无操作。</p>
<p>​    (2)每个线程在<strong>java堆中预先分配一小块线程私有的TLAB</strong>，用于该线程的内存分配。本地缓冲区（TLAB）用完了，需要分配新的缓冲区时才需要同步锁定。</p>
<p>​    <strong>④内存初始化：</strong>虚拟机将分配到的空间都初始化为0值<strong>（对象头除外）</strong>，区别于类加载过程中对类进行初始化。若使用了TLAB，该工作也可以提前至TLAB分配时执行。</p>
<p>​    <strong>⑤对象的必要信息存入对象头中。</strong>所以对象头指向的是方法区中类的信息。</p>
<p>​    <strong>⑥执行<init>()方法：</strong>即该类的构造函数</p>
<h4 id="2-2-2-对象的内存布局"><a href="#2-2-2-对象的内存布局" class="headerlink" title="2.2.2 对象的内存布局"></a>2.2.2 对象的内存布局</h4><p>​    对象的存储布局划分为三个部分：<strong>对象头、实例数据、对齐填充</strong>。</p>
<p>​    对象头：包括两类信息。</p>
<ul>
<li>第一类用于存储运行时元数据（哈希值、GC分代年龄、锁状态标志等）(Mark Word)。</li>
<li>第二类是类型指针，即<strong>对象指向类型元数据的指针</strong>（并非所有虚拟机实现都必须在对象数据中保留类型指针）。</li>
<li>若该对象为数组，对象头中还需记录<strong>数组长度</strong>。</li>
</ul>
<p>​    实例数据：对象真正存储的有效信息，各种被定义类型的字段。（包括从父类那继承下来的）</p>
<ul>
<li>分配顺序为宽度由长到短。<strong>相同宽度的字段被分配到一起存放</strong>，<strong>父类在前，子类在后</strong>。子类中<strong>较窄的变量</strong>也允许插入父类变量的空隙中。</li>
</ul>
<p>​    对齐填充：占位符的作用。HotSpot的自动内存管理系统要求对象的大小必须是8字节的整数倍。对齐填充位用来补全到8字节整数倍。</p>
<p>例子：以<code>Customer cust = new Customer();</code></p>
<p>说明：Customer里面有int string属性 和 一个Account对象</p>
<p><img src="https://img-blog.csdnimg.cn/20200719092921453.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt=""></p>
<h4 id="2-2-3-对象的访问定位"><a href="#2-2-3-对象的访问定位" class="headerlink" title="2.2.3 对象的访问定位"></a>2.2.3 对象的访问定位</h4><p>​    对象的访问定位方式有两种：<strong>句柄访问</strong>和<strong>直接指针访问</strong>。</p>
<p>​    句柄访问：</p>
<ul>
<li>实现：在堆中维护一个句柄池。句柄中包含对象实例数据与类型数据的地址信息。Reference存储该对象句柄地址。</li>
<li>优点：稳定，<strong>在对象被移动时（GC时普遍发生），reference本身无需更改</strong>。</li>
</ul>
<img src="https://img-blog.csdnimg.cn/2020071909411524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" style="zoom:150%;" />

<p>​    直接指针访问：</p>
<ul>
<li>直接指针访问：reference存储对象实例数据的地址。对象头中包含类型数据的地址。</li>
<li>优点：<strong>速度快，节省了一次指针定位的时间开销</strong>。</li>
</ul>
<img src="https://img-blog.csdnimg.cn/20200719094122701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" style="zoom:150%;" />

<h3 id="2-3-OutOfMemoryError异常（OOM异常）"><a href="#2-3-OutOfMemoryError异常（OOM异常）" class="headerlink" title="2.3 OutOfMemoryError异常（OOM异常）"></a>2.3 OutOfMemoryError异常（OOM异常）</h3><p>​    OutOfMemoryError异常：内存溢出异常 ，简称OOM异常。</p>
<h3 id="2-4-内存溢出与内存泄露（面试）"><a href="#2-4-内存溢出与内存泄露（面试）" class="headerlink" title="2.4 内存溢出与内存泄露（面试）"></a>2.4 内存溢出与内存泄露（面试）</h3><ul>
<li><p>内存溢出（OOM）</p>
<p>​    没有空闲内存，并且垃圾收集器GC后也无法提供更多的内存了，<strong>会尝试回收软引用对象</strong>。</p>
<p>原因：（1）堆内存设置的不够：可能有内存泄露问题，设置大小不合理，用-Xms和-Xmx来调整。</p>
<p>​           （2）创建大量的大对象，并且没有被回收。</p>
</li>
<li><p>内存泄露</p>
<p>​    <strong>严格来说，只有对象不会再被程序用到，并且GC不会回收到它们，才叫做内存泄露。</strong></p>
<p>宽泛讲：对象的生命周期变得很长（比如局部变量，设置成Static变量）。</p>
</li>
</ul>
<p><strong>举例（面试）：</strong></p>
<ol>
<li><p>单例模式：</p>
<p>单例对象的生命周期同应用程序一样长，如果它有外部引用的话，则外部对象不会被回收，则导致内存泄露。</p>
</li>
<li><p>一些提供了close()的资源未使用close()：</p>
<p>例如：数据库连接，使用dataSource.getConnection()，网络连接Socket 和 IO流未手动close()，否则都无法回收。</p>
</li>
</ol>
<h2 id="三、垃圾收集器与内存分配策略"><a href="#三、垃圾收集器与内存分配策略" class="headerlink" title="三、垃圾收集器与内存分配策略"></a>三、垃圾收集器与内存分配策略</h2><p>​    关于GC：JVM自动进行内存分配与垃圾收集，这样就会<strong>降低内存泄露和内存溢出的风险</strong>。</p>
<ol>
<li><p>什么是垃圾？</p>
<p>​    运行程序中<strong>没有任何指针指向</strong>的对象</p>
</li>
<li><p>为什么要GC？</p>
<ul>
<li>如果不进行GC，内存迟早要消耗殆尽，导致内存溢出</li>
<li>释放没用的对象，对内存进行碎片化整理，以便JVM将整理出的内存分配给以后新对象</li>
<li>随着应用程序越来越大，业务越来越多，不进行GC不能保证应用程序的正常运行</li>
</ul>
</li>
</ol>
<h3 id="3-1-补充：执行引擎"><a href="#3-1-补充：执行引擎" class="headerlink" title="3.1 补充：执行引擎"></a>3.1 补充：执行引擎</h3><p><strong>Java是半编译半解释型语言</strong>：现在JVM在执行Java代码的时候，通常会将解释执行和编译执行二者结合起来进行。</p>
<p><strong>执行引擎的任务就是将字节码指令解释/编译为对应平台上的本地机器指令</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20200719095946611.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt=""></p>
<p>某些被频繁执行的方法或者代码块，会被JVM认定为“<strong>热点代码</strong>”。在运行时JVM会把这些热点代码编译成与本地平台相关的机器码，并且进行各种层次的优化，以提高执行效率。完成这个任务的编译器称为即时编译器（JIT编译器）。</p>
<h3 id="3-2-标记阶段（对象是否存活）"><a href="#3-2-标记阶段（对象是否存活）" class="headerlink" title="3.2 标记阶段（对象是否存活）"></a>3.2 标记阶段（对象是否存活）</h3><h4 id="3-2-1-引用计数算法（不用）"><a href="#3-2-1-引用计数算法（不用）" class="headerlink" title="3.2.1 引用计数算法（不用）"></a>3.2.1 引用计数算法（不用）</h4><p>​    在对象中添加一个引用计数器。每当一个地方引用它，计数器值+1。引用失效时，计数器值-1。计数器值为0时，对象就不会再被使用的。</p>
<p>​    优点：原理简单，判断效率高。</p>
<p>​    缺点：每次都要操作计数器，时间开销大；无法解决循环引用的问题（两个对象相互引用，不会被回收），造成内存泄露。导致Java垃圾收集器没有使用这个标记算法。</p>
<h4 id="3-2-2-可达性分析算法（JVM使用）"><a href="#3-2-2-可达性分析算法（JVM使用）" class="headerlink" title="3.2.2 可达性分析算法（JVM使用）"></a>3.2.2 可达性分析算法（JVM使用）</h4><p>​    通过一系列称为GC Roots的根对象集合，作为起始节点集。<strong>从这些节点开始，根据引用关系向下搜索</strong>。若从GC Roots到某个对象不可达，则该对象可回收。</p>
<p><img src="https://img-blog.csdnimg.cn/20200719100628754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>作为GC Roots对象的条件：必须活跃的引用，例如</p>
<p>(1)  在<strong>虚拟机栈中有引用的对象</strong>（参数、局部变量等）（栈帧出栈后不再作为GC Roots）</p>
<p>(2)  <strong>本地方法栈中本地方法引用的对象</strong>。</p>
<p>(3)  <strong>方法区中的类静态属性引用的对象（即static的类变量）</strong></p>
<p>(4)  <strong>方法区中常量引用的对象（即final变量）</strong></p>
<p>(5)  虚拟机内部的引用（基本数据类型对应的Class对象、常驻的异常对象、<strong>类加载器</strong>等）</p>
<p>(6)  <strong>被同步锁持有的对象（synchronized关键字）</strong></p>
<p>(7)  反应java虚拟机内部情况的JMXBean、本地代码缓存等。</p>
<p>(8)  根据<strong>垃圾收集器和当前回收区域</strong>的不同，还可能临时加入其它GC Roots。</p>
<p>​    <strong>比如：分代收集和局部回收，这个区域的对象完全可能被其他区域对象所引用，例如老年代的对象引用与年轻代的对象实例。</strong></p>
<p><strong>在新生代建立一个全局数据结构“记忆集”。这个结构把老年代划分为若干小块，标识出哪一块会出现跨代引用。此后发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入GC Roots进行扫描。该方法需要在对象改变引用关系时维护记录数据的正确性。</strong></p>
<h4 id="3-2-3-引用"><a href="#3-2-3-引用" class="headerlink" title="3.2.3 引用"></a>3.2.3 引用</h4><p>​    <strong>强引用</strong>：最传统的引用定义。任何情况下，只要强引用关系存在，GC永远不会回收掉被引用对象。</p>
<p>​    <strong>软引用</strong>：还有用，但并非必须的对象。在系统即将发生内存溢出异常前，会把软引用关联对象列入回收范围进行第二次回收。</p>
<p>​    <strong>弱引用</strong>：强度比软引用更弱。下一次垃圾收集发生时，无论内存是否足够，都进行回收。</p>
<p>​    <strong>虚引用</strong>：最弱的引用关系。虚引用的唯一作用就是在该对象被GC回收时收到一个通知。</p>
<h4 id="3-2-4-自救（不使用）"><a href="#3-2-4-自救（不使用）" class="headerlink" title="3.2.4 自救（不使用）"></a>3.2.4 自救（不使用）</h4><p>​    finalize()方法：类似C++析构函数，对象回收之前被JVM垃圾收集器调用，<strong>只会被调用一次</strong>。</p>
<p>​    主要用于：</p>
<ul>
<li>对象被回收前进行资源的释放（类似遗嘱）。</li>
<li>自救行为：只要重新与引用链上的任何一个对象建立关联即可。</li>
</ul>
<p>​    一个对象拥有两次标记的对象才会被回收。</p>
<p>​    当GC Roots判定为不可达时，对象被进行第一次标记。随后筛选是否有必要执行finalize()方法（或已执行过）。</p>
<ul>
<li><p>没有finalize()方法（或已执行）的对象会进行第二次标记。</p>
</li>
<li><p>拥有finalize()方法并未被执行的，会被放置在F-Queue队列中。并由虚拟机创建一条低优先级的Finalizer线程执行它们的finalize()方法。虚拟机会“触发”该finalize()方法的开始，但并不承诺会等待其结束（为了避免某个对象的finalize()方法执行缓慢或陷入死循环，导致GC崩溃）。</p>
<p><strong>若对象在finalize()方法中与引用链中的对象或类成功建立起了联系，就会逃脱第二次标记，被移出即将回收集合。</strong>（但一个对象的finalize()方法只会被执行一次，第二次回收时将不会再执行其finalize()方法）</p>
</li>
</ul>
<p><strong>建议不使用该方法，不管是自救还是释放资源，他的代价高昂，不确定性太大，就算是释放资源，try-finally或者其他方式会做的更好。</strong></p>
<h4 id="3-2-5-回收方法区"><a href="#3-2-5-回收方法区" class="headerlink" title="3.2.5 回收方法区"></a>3.2.5 回收方法区</h4><p>​    方法区的回收并非java虚拟机必须实现的功能。</p>
<p>​    <strong>方法区回收主要是：废弃常量和不再使用的类型。</strong></p>
<ol>
<li><p>常量的回收类似于堆中对象的回收。如果一个常量曾经进入了常量池，当前系统及虚拟机中又没有任何引用该常量，即可回收。</p>
</li>
<li><p>类型可回收的条件：</p>
</li>
</ol>
<p>(1)  堆中不存在该类及其派生子类的实例。</p>
<p>(2)  该类的类加载器已被回收。</p>
<p>(3)  该类对应的java.lang.Class对象没有在任何地方被引用</p>
<h3 id="3-3-垃圾收集算法"><a href="#3-3-垃圾收集算法" class="headerlink" title="3.3 垃圾收集算法"></a>3.3 垃圾收集算法</h3><h4 id="3-3-1-标记-清除算法"><a href="#3-3-1-标记-清除算法" class="headerlink" title="3.3.1 标记-清除算法"></a>3.3.1 标记-清除算法</h4><p>​    最基础的GC算法。即标记可回收对象，再回收标记对象，需要维持空闲列表。</p>
<p><img src="https://img-blog.csdnimg.cn/20200719100642328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>缺点：</p>
<p>(1)执行效率不稳定，标记和清除过程可能耗时过长。</p>
<p>(2)内存空间碎片化</p>
<h4 id="3-3-2-复制算法"><a href="#3-3-2-复制算法" class="headerlink" title="3.3.2 复制算法"></a>3.3.2 复制算法</h4><p>​    半区复制算法：将可用内存划分为大小相等的两块。每次只用其中一块。当这一块内存用完时，将仍存活的对象复制到另一块上。然后把已使用过的内存块一次清除，对象分配空间为指针碰撞。</p>
<p><img src="https://img-blog.csdnimg.cn/20200719100647865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>Appel式回收：<strong>将新生代划分为一块较大的内存(Eden)和两块较小的内存(Survivor)</strong>。Eden和Survivor默认大小比8:1。</p>
<p><strong>每次分配内存只使用Eden和一块Survivor，发生垃圾收集时，将存活的对象复制到另一块Survivor中，清除Eden和使用过的Survivor。</strong>当Survivor中的空间不足以容纳一次Minor GC的存活对象时，需要依赖老年代区域进行分配担保（即多余的存活对象进入老年代区）。</p>
<p>优缺点：</p>
<p>（1）简单、运行高效，复制过去保证了连续性，不会出现“碎片问题”。</p>
<p>（2）需要两倍空间，需要维护引用与对象之间的关系，不管是内存占用和时间开销都比较大</p>
<p>适用于存活对象较少的情况，例如老年代。</p>
<h4 id="3-3-3-标记-整理算法"><a href="#3-3-3-标记-整理算法" class="headerlink" title="3.3.3 标记-整理算法"></a>3.3.3 标记-整理算法</h4><p>​    针对老年代对象的回收算法。将存活的对象向内存一端移动，直接清理掉边界以外的内存。</p>
<p> <img src="https://img-blog.csdnimg.cn/20200719100653491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>​    优缺点：</p>
<p>（1）不用内存减半的代价，JVM只需维持一个内存的起始地址即可，存活对象分配使用指针碰撞。</p>
<p>（2）移动大量存活对象带来极大的负重，需要全程暂停用户应用程序。</p>
<h4 id="3-3-4-分代收集理论"><a href="#3-3-4-分代收集理论" class="headerlink" title="3.3.4 分代收集理论"></a>3.3.4 分代收集理论</h4><p>​    当前大多数商业虚拟机的GC，大都遵循“分代收集”设计。</p>
<p>​    设计原则：GC应将java堆划分出不同区域，把java堆划分为新生代和老年代两个区域。</p>
<ul>
<li>年轻代：对象比较短，生命周期短，使用复制算法比较好（Eden Survivor0 复制到 Survivor1）</li>
<li>老年代：使用标记-清除-整理结合，平时使用标记-清除算法，<strong>当内存碎片化过于严重，以致影响对象分配时，使用一次标记-整理算法消除碎片化空间。</strong></li>
</ul>
<h3 id="3-4-HotSpot算法细节实现"><a href="#3-4-HotSpot算法细节实现" class="headerlink" title="3.4 HotSpot算法细节实现"></a>3.4 HotSpot算法细节实现</h3><h4 id="3-4-1-根节点枚举"><a href="#3-4-1-根节点枚举" class="headerlink" title="3.4.1 根节点枚举"></a>3.4.1 根节点枚举</h4><p>​    <strong>枚举根节点时，必须暂停所有线程。即GC时，暂停所以线程（STW）。</strong></p>
<p>​    准确式垃圾收集：HotSpot使用OopMap保存并区分一个地址存储的是数据还是引用。OopMap协助完成根节点枚举。</p>
<h4 id="3-4-2-安全点"><a href="#3-4-2-安全点" class="headerlink" title="3.4.2 安全点"></a>3.4.2 安全点</h4><p>​    判断依据：引用关系不会发生变化，程序能够长时间执行，这些时候才能是安全点。</p>
<p>​    并非每一次引用变化都会生成OopMap。只在特殊的位置生成OopMap。这些位置被称为“安全点”。<strong>所以用户程序并非任何时刻都能够进行STW和垃圾收集，只有在安全点才可以。</strong>一般安全点出现在指令序列的复用时（循环、方法调用、异常跳转等）。</p>
<p>​    多线程状态下，安全点的寻找有抢先式中断和主动式中断两种方式。</p>
<ul>
<li>抢先式中断（没有虚拟机使用）：垃圾收集发生时，中断所有线程。此时没有停在安全点上的恢复执行，过段时间再中断，直到停到安全点上为止。</li>
<li><strong>主动式中断</strong>：需要垃圾收集时，设置一个标志位。线程运行时每次经过轮询点都会轮询标志位。发现修改即停止。（轮询点=安全点+需要分配堆内存时）</li>
</ul>
<p>​    HotSpot使用内存保护陷阱的方式解决轮询操作。设置标志位操作=置xxx内存区不可读，轮询操作=读xxx内存区。轮询读到不可读时会进入异常，异常处理器中挂起该线程。</p>
<h4 id="3-4-3-安全区域"><a href="#3-4-3-安全区域" class="headerlink" title="3.4.3 安全区域"></a>3.4.3 安全区域</h4><p>​    安全区域相当于拉伸了的安全点。在安全区域中，能够确保引用关系不会发生变化。</p>
<p>​    安全区域的使用是为了防止在使用安全点时<strong>发生一个线程一直分配不到处理器以致无法运行至安全点</strong>，比如Sleep状态和Blocked状态，无法响应中断请求。</p>
<p>​    用户线程执行到安全区域中时，会标明自己进入了安全区域。GC在进行垃圾收集时可以忽略这些线程。<strong>当用户线程离开安全区域时会检查是否在进行根节点枚举（或者说是GC），若在进行根节点枚举(GC)，则线程等待枚举完成。</strong></p>
<h4 id="3-4-4-记忆集与卡表"><a href="#3-4-4-记忆集与卡表" class="headerlink" title="3.4.4 记忆集与卡表"></a>3.4.4 记忆集与卡表</h4><p>​    <strong>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。</strong></p>
<p>​    记录表有三种记录精度：</p>
<p>​    <strong>字长精度</strong>：每个精度精确到一个机器字长。该字包含跨代指针。</p>
<p>​    <strong>对象精度</strong>：每个记录精确到一个对象。该对象里有字段含有跨代指针。</p>
<p>​    <strong>卡精度</strong>：每个记录精确到一块内存区域。该区域内有对象含有跨代指针。</p>
<p>​    卡精度，即使用“卡表”实现记忆集。是最常用的记忆集实现方式。卡表是一个字节数组，数组的每一个元素对应着一个卡页（类似内存页）。一个卡页一般2^N大小。卡表的下标代表卡页的标号。当前元素置1称为变脏。垃圾收集发生时，只需找出变脏的元素，并将该卡页加入GC Roots进行扫描。</p>
<h4 id="3-4-5-并发的可达性分析"><a href="#3-4-5-并发的可达性分析" class="headerlink" title="3.4.5 并发的可达性分析"></a>3.4.5 并发的可达性分析</h4><p><strong>三色标记：</strong></p>
<p>白色：未被GC访问过的对象</p>
<p>黑色：已被GC访问过，且其所有直接引用都已被访问过的对象</p>
<p>灰色：已被GC访问过，但其仍有直接引用未被访问</p>
<p>仅当以下两个条件同时满足时，会产生“对象消失”问题：</p>
<ol>
<li><p>赋值器插入了一条或多条黑色对象到白色对象的引用</p>
</li>
<li><p>赋值器删除了灰色对象所有到该白色对象的直接或间接引用</p>
</li>
</ol>
<p>两种解决方案：</p>
<ol>
<li><p>增量更新：破坏第一个条件。当黑色对象插入一个指向新的白色对象的引用时，记录下来。并发扫描结束，以该黑色对象为根再扫描一次。</p>
</li>
<li><p>原始快照：破坏第二个条件。当灰色对象删除一个指向白色对象的引用时，记录下来。并发扫描结束，重新扫描该白色对象。</p>
</li>
</ol>
<p>CMS采用增量更新，G1和Shenandoah采用原始快照。</p>
<h3 id="3-5-经典垃圾收集器"><a href="#3-5-经典垃圾收集器" class="headerlink" title="3.5 经典垃圾收集器"></a>3.5 经典垃圾收集器</h3><p><img src="https://img-blog.csdnimg.cn/20200722210141573.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>垃圾收集器的指标：<strong>不可能三角</strong></li>
</ul>
<ol>
<li>吞吐量：用户线程执行时间/总执行时间（用户线程执行时间 + GC时间）</li>
<li>暂停时间：STW的时间</li>
<li>内存占用：Java堆区所占的内存大小</li>
</ol>
<p>​    注重吞吐量（做的事多），每次STW时间长，总时长短</p>
<p>​    注重低延迟（用户交互性好，不卡），每次STW间隔短，总时长长</p>
<p><strong>现在的垃圾回收器标准：在满足最大吞吐量优先的情况下，降低停顿时间。</strong></p>
<ul>
<li>垃圾收集器的分类：除了并发的收集器都要STW，<strong>加粗</strong>的是年轻代的收集器</li>
</ul>
<ol>
<li><p>串行收集器：<strong>Serial</strong>，Serial Old</p>
</li>
<li><p>并行收集器：<strong>ParNew</strong>，<strong>Parallel Scarage</strong>，Paraller Old</p>
</li>
<li><p>并发收集器：CMS，G1（年轻代老年代都可以），垃圾回收与用户线程并发执行</p>
</li>
</ol>
<ul>
<li>垃圾收集器的历史</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200722212811289.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="3-5-1-Serial收集器"><a href="#3-5-1-Serial收集器" class="headerlink" title="3.5.1 Serial收集器"></a>3.5.1 Serial收集器</h4><p>​    默认的新生代GC，在Client模式下的收集器。收集时会暂停所有其他用户线程。 </p>
<p><img src="https://img-blog.csdnimg.cn/20200719103523827.png" alt="在这里插入图片描述"></p>
<p>优点：</p>
<p>(1)额外内存消耗最小</p>
<p>(2)没有线程交互的开销，<strong>在核心数较少的处理器中效率较高（一般只用于单核处理器）</strong>。适合桌面应用或部分微服务场景。</p>
<p>缺点：垃圾收集时会有停顿。</p>
<h4 id="3-5-2-ParNew收集器（与CMS组合）"><a href="#3-5-2-ParNew收集器（与CMS组合）" class="headerlink" title="3.5.2 ParNew收集器（与CMS组合）"></a>3.5.2 ParNew收集器（与CMS组合）</h4><p>​    实质上是<strong>Serial收集器的多线程并行版本</strong>。</p>
<p> <img src="https://img-blog.csdnimg.cn/20200719103529454.png" alt="在这里插入图片描述"></p>
<p>​    <strong>ParNew与CMS是默认组合。</strong>可以认为ParNew收集器已经并入CMS收集器，成为其专门收集新生代的部分。</p>
<p>​    ParNew收集器较Serial在多核cpu上效率更高。</p>
<h4 id="3-5-3-Parallel-Scavenge收集器"><a href="#3-5-3-Parallel-Scavenge收集器" class="headerlink" title="3.5.3 Parallel Scavenge收集器"></a>3.5.3 Parallel Scavenge收集器</h4><p>​    Parallel Scavenge收集器类似于ParNew，同为标记-复制算法、并行收集。</p>
<p><strong>不同点在于Parallel收集器更注重于达到一个可控制的吞吐量，吞吐量优先的情况下使用。</strong></p>
<p>PS收集器能更大限度分配处理器给用户线程，<strong>适合于在后台运算（例如批量处理、科学计算、业务处理）</strong>，而不需要太多交互的任务。</p>
<h4 id="3-5-4-Serial-Old收集器"><a href="#3-5-4-Serial-Old收集器" class="headerlink" title="3.5.4 Serial Old收集器"></a>3.5.4 Serial Old收集器</h4><p>​    Serial收集器的老年代版本，采用标记-整理算法。除桌面端应用，JDK5前还可与PS收集器搭配使用，<strong>或作为CMS发生失败时的后备预案</strong>。</p>
<h4 id="3-5-5-Parallel-Old收集器"><a href="#3-5-5-Parallel-Old收集器" class="headerlink" title="3.5.5 Parallel Old收集器"></a>3.5.5 Parallel Old收集器</h4><p>PS收集器的老年代版本，采用标记-整理算法。与PS收集器搭配使用，<strong>适用于处理器资源紧缺、吞吐量优先的场景。</strong></p>
<h4 id="3-5-6-CMS收集器"><a href="#3-5-6-CMS收集器" class="headerlink" title="3.5.6 CMS收集器"></a>3.5.6 CMS收集器</h4><p>​    CMS收集器（老年代），并发的垃圾收集器，不会STW。<strong>以最短停顿时间为目标，适合于用户交互场景</strong>。</p>
<p>​    CMS四个阶段：</p>
<p>(1)  初始标记：<strong>仅仅标记GC Roots能直接可达到的对象</strong>，追求时间效率，避免用户久等。</p>
<p>(2)  并发标记：从<strong>GC Roots直接关联对象开始遍历整个对象图（所以可达的对象）</strong>的过程（<strong>可与用户线程并发执行</strong>）</p>
<p>(3)  重新标记：针对并发标记过程中产生了变动的对象进行重新标记，修正并发标记的。</p>
<p>(4)  并发清除：标记-清除算法（可与用户线程并发执行）</p>
<p>初始标记和重新标记由于涉及对象很少，所以速度极快。而涉及大量对象的并发标记和并发清除阶段都不会耽误用户程序的运行。（选用标-清而非标-复正是因为标-清无需变动存活对象，可与用户程序并发）</p>
<p><img src="https://img-blog.csdnimg.cn/20200719103534693.png" alt="在这里插入图片描述"></p>
<p>​    优点：(1)低延迟，用户体验好，利于与用户交互，并发垃圾收集。</p>
<p>​    缺点：</p>
<p>​    (1)<strong>处理器资源敏感</strong>。特别是核心数少的处理器，因为GC占用线程，所以总吞吐量降低。</p>
<p>​    (2)<strong>难以应对“浮动垃圾”（即在标记完成后出现的新垃圾）</strong>，因为有并发标记的阶段，所以这阶段产生的垃圾不会被标记，这些垃圾只能等到下一次垃圾收集时清理。</p>
<p>​    同时，CMS不能等到老年代几乎填满后再启动，因为他必须留下足够的内存，在垃圾收集的同时给用户线程使用。预留过多会造成内存浪费以及回收频繁；预留过少会造成“并发失败”，并发失败发生后虚拟机会调用Serial Old重新收集，会使性能下降。</p>
<p>​    (3)由于标记-清除算法，而产生的<strong>空间碎片化</strong>问题，甚至可能会进行一次Full GC。</p>
<h4 id="3-5-7-G1收集器"><a href="#3-5-7-G1收集器" class="headerlink" title="3.5.7 G1收集器"></a>3.5.7 G1收集器</h4><p>​    G1是一款面向服务端的GC。<strong>在JDK8U40彻底完善</strong>，<strong>已替代PS组合，并在JDK9中替代CMS组合。</strong></p>
<ul>
<li>特点：既兼顾低延迟，也针对大吞吐量。</li>
</ul>
<p>​    G1在组建回收集时，不再根据新生代老年代衡量。而是把java堆划分为多个大小相等的Region，每个Region根据需要可以扮演新生代的Eden、Survivor区域或老年代区域。收集器再对不同Region采用不同策略进行收集。Humongous区域专门用来存放大对象（即超过Region一半大小的对象）。对于超过整个Region的对象，用多个连续Humongous存储。G1大多数行为将其视为老年代。</p>
<p>​    G1仍保有新生代老年代概念，但不划分固定区域，而是动态集合。G1将Region作为最小回收单元，因此停顿时间可预测。<strong>通过跟踪每个Region的回收价值大小（即回收所获得空间和回收所需时间的经验值），并维护一个优先级列表</strong>。回收时根据用户设定允许的回收停顿时间，优先处理价值高的Region。</p>
<p>​    G1流程：</p>
<p>(1)  初始标记：同CMS</p>
<p>(2)  并发标记：同CMS</p>
<p>(3)  重新标记：同CMS</p>
<p>(4)  筛选回收：局部可看做复制算法，将回收集中的Region中的存活对象复制到空Region，再清理回收集中的Region，整体上是标记-压缩算法。（涉及存活对象，需暂停用户线程）</p>
<p> <img src="https://img-blog.csdnimg.cn/20200719103540590.png" alt="在这里插入图片描述"></p>
<p>​    相较于CMS：</p>
<p>​    优点：</p>
<p>​    (1)可指定最大停顿时间。</p>
<p>​    (2)没有内存碎片产生，有利于程序长时间运行。</p>
<p>​    缺点：<strong>卡表占用过多的内存（10%-20%）</strong>，并且执行负载更高。</p>
<p>​    总结：小内存用CMS，大内存用G1。</p>
<h3 id="3-6-低延迟GC"><a href="#3-6-低延迟GC" class="headerlink" title="3.6 低延迟GC"></a>3.6 低延迟GC</h3><p>​    <strong>GC的三项指标：内存占用、吞吐量、延迟。</strong></p>
<p>​    硬件性能的增长，导致内存占用不再如此重要，吞吐量也随硬件上升，而延迟也由于内存的增加而增加。</p>
<p>​    所以降低延迟是GC的首要目标，采取并发的手段（不用STW，减少延迟，初始标记才需要STW，即标记GC ROOTS）</p>
<h4 id="3-6-1-Shenandoah收集器"><a href="#3-6-1-Shenandoah收集器" class="headerlink" title="3.6.1 Shenandoah收集器"></a>3.6.1 Shenandoah收集器</h4><p>​    Oracle JDK中未使用，相比于G1的改进：</p>
<p>(1)支持<strong>并发的整理算法</strong>。</p>
<p>(2)不使用分代收集。</p>
<p>(3)不使用记忆集，改用连接矩阵来记录跨Region的引用。</p>
<p>Shenandoah流程：</p>
<p>(1)  初始标记：同G1。</p>
<p>(2)  <strong>并发标记</strong>：同G1。</p>
<p>(3)  最终标记：同G1。</p>
<p>(4)  并发清理：用于清理不存在任何存活对象的Region。</p>
<p>(5)  <strong>并发回收</strong>：大致同G1，使用读屏障和转发指针，使得复制存活对象的过程可以与用户线程并发。</p>
<p>(6)  初始引用更新：并无具体操作，实际只是确保所有回收线程都已到达该阶段。</p>
<p>(7)  <strong>并发引用更新</strong>：实际更新引用。</p>
<p>(8)  最终引用更新：修正GC Roots中的引用。</p>
<p>(9)  并发清理：清理回收集中所有Region。</p>
<p>Brooks Pointer：基于转发指针实现的复制对象与用户线程并发的解决方案。在对象头处加一个引用指针指向自己。当该对象被复制时，改变旧对象的引用指针使其指向新地址，直到Region被清除。</p>
<h4 id="3-6-2-ZGC"><a href="#3-6-2-ZGC" class="headerlink" title="3.6.2 ZGC"></a>3.6.2 ZGC</h4><p>是一款基于Region内存布局的，不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法。</p>
<p>ZGC与前代GC相比的新技术：</p>
<ol>
<li><p>Region：具有动态性，动态创建和销毁，以及动态的区域容量大小。分为小型中型大型。小型2MB，放置小对象；中型32MB，放置中型对象；大型为2MB的整数倍，每个大型Region仅放置一个大型对象，大型Region不会被重分配。</p>
</li>
<li><p>染色指针技术：</p>
<p>ZGC把一些标记信息存储在引用中，使得访问这些信息仅通过引用即可，但也使得最大内存限制在4TB。</p>
</li>
<li><p>多重映射技术</p>
</li>
</ol>
<p>ZGC流程：</p>
<p>(1)  并发标记</p>
<p>(2)  并发预备重分配：针对全堆扫描标记，针对重分配集回收</p>
<p>(3)  并发重分配：染色指针会记录该对象是否在重分配集中；重分配集维护一个转发表，访问到在重分配集中的对象时，会去转发表寻找新地址，同时修正引用。</p>
<p>(4)  并发重映射</p>
<h3 id="3-7-内存分配策略"><a href="#3-7-内存分配策略" class="headerlink" title="3.7 内存分配策略"></a>3.7 内存分配策略</h3><p>针对不同年龄段（对象头中的age）的对象进行内存分配原则如下：</p>
<ul>
<li><p>优先分配到Eden</p>
</li>
<li><p>大对象直接分配到老年代</p>
<p>尽量避免程序中出现过多的大对象</p>
</li>
<li><p>长期存活的对象分配到老年代</p>
</li>
</ul>
<h2 id="四、Java内存模型与线程"><a href="#四、Java内存模型与线程" class="headerlink" title="四、Java内存模型与线程"></a>四、Java内存模型与线程</h2><h3 id="4-1-Java内存模型"><a href="#4-1-Java内存模型" class="headerlink" title="4.1 Java内存模型"></a>4.1 Java内存模型</h3><p>可以说是Java线程内存模型，它是基于CPU缓存模型来建造，主内存可类比物理上的主内存，工作内存可类比高速缓存。线程只能操作工作内存。</p>
<p><img src="https://img-blog.csdnimg.cn/20200723213228609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="4-1-1-主内存与工作内存"><a href="#4-1-1-主内存与工作内存" class="headerlink" title="4.1.1 主内存与工作内存"></a>4.1.1 主内存与工作内存</h4><p>Java内存模型的主要目的是定义程序中各种变量的访问规则（此处变量指堆、方法区中的线程共享变量）。</p>
<h4 id="4-1-2-内存间交互操作"><a href="#4-1-2-内存间交互操作" class="headerlink" title="4.1.2 内存间交互操作"></a>4.1.2 内存间交互操作</h4><p>8种原子操作：</p>
<p>(1)  Lock: 作用于主内存变量，把一个变量标识为一个线程独占的状态</p>
<p>(2)  Unlock：解锁一个资源</p>
<p><strong>(3)  Read：作用于主内存变量，把一个变量的值从主内存传输至工作内存，以便load</strong></p>
<p><strong>(4)  Load：作用于工作内存变量，把read来的值存入工作内存的变量副本中</strong></p>
<p><strong>(5)  Use：作用于工作内存变量，把工作内存中的一个变量值传给执行引擎</strong></p>
<p><strong>(6)  Assign：当虚拟机执行变量赋值操作，把执行引擎传回的值赋给工作内存的变量</strong></p>
<p><strong>(7)  Store：作用于工作内存变量，把一个变量的值从工作内存传输至主内存，以便write</strong></p>
<p><strong>(8)  Write：作用于主内存变量，把store的值放入主内存变量</strong></p>
<p>Assign store write必须成对出现；Lock会清空工作内存中该变量的值；Unlock前必须先同步</p>
<p><img src="https://img-blog.csdnimg.cn/20200723213613452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>总线（MESI缓存一致性协议）：</p>
<p>​    当在修改共享变量值后马上同步回主内存，其他cpu监听总线，然后监听到其他线程修改时，则会将工作内存的值失效，重新触发一次read，load，use操作进行修改执行引擎的值。</p>
</li>
</ul>
<h4 id="4-1-3-Volatile"><a href="#4-1-3-Volatile" class="headerlink" title="4.1.3 Volatile"></a>4.1.3 Volatile</h4><p>​    Use前必须load；assign后必须store；先被use的先read，先被assign的先store。</p>
<ul>
<li><p>Volatile缓存可见性实现原理：</p>
<p>​    <strong>底层实现通过汇编lock前缀指令，就会锁定这块内存区域的缓存（缓存行锁定），并写回到主内存中</strong></p>
<p><strong>lock指令解释：会将当前处理器缓存行的数据立即写回到系统内存中，这个操作会因此其他CPU缓存改内存地址数据失效（MESI协议，触发CPU总线嗅探机制）</strong></p>
</li>
<li><p>lock位置是在store前，然后write到主内存后unlock，这样的好处：</p>
<p>​    （1）锁的力度小，多个线程同时写内存时，<strong>解决了并发的问题</strong>，只加写不加读。</p>
<p>​    （2）不影响系统性能。</p>
</li>
<li><p>保证可见性、有序性、不保证原子性：</p>
<p>原因：若同时操作一个共享变量，则lock前缀指令触发另一个线程总线嗅探，会使它操作失效，再重新进行下一次操作。</p>
<p><strong>例如：两线程同时执行对同一变量++操作，则可能会使执行++次数不变，但加的值减少（失效了），需在操作方法上加Synchronized关键字保证原子性。</strong></p>
</li>
</ul>
<h3 id="4-2-线程"><a href="#4-2-线程" class="headerlink" title="4.2 线程"></a>4.2 线程</h3><h4 id="4-2-1-Java线程调度"><a href="#4-2-1-Java线程调度" class="headerlink" title="4.2.1 Java线程调度"></a>4.2.1 Java线程调度</h4><ul>
<li>协同式线程调度：一个线程执行结束再开始下一个线程。</li>
</ul>
<p>​    优点：<strong>实现简单；线程切换可控，无并发问题。</strong></p>
<p>​    缺点：执行时间不可控，容易造成阻塞。</p>
<ul>
<li>抢占式线程调度（Java调度方式）：系统决定执行时间。</li>
</ul>
<p>​    优点：执行时间可控。可以通过设置优先级，使线程更<strong>容易</strong>被唤醒。</p>
<h4 id="4-2-2-状态转换"><a href="#4-2-2-状态转换" class="headerlink" title="4.2.2 状态转换"></a>4.2.2 状态转换</h4><p><img src="https://img-blog.csdnimg.cn/20200722213121140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="五、JVM常用参数"><a href="#五、JVM常用参数" class="headerlink" title="五、JVM常用参数"></a>五、JVM常用参数</h2><h3 id="5-1-标准参数"><a href="#5-1-标准参数" class="headerlink" title="5.1 标准参数"></a>5.1 标准参数</h3><h4 id="Verbose"><a href="#Verbose" class="headerlink" title="Verbose"></a>Verbose</h4><p>-verbose:class </p>
<p>​    输出jvm载入类的相关信息，当jvm报告说找不到类或者类冲突时可此进行诊断。</p>
<p>-verbose:gc </p>
<p>​    输出每次GC的相关情况。</p>
<p>-verbose:jni </p>
<p>​    输出native方法调用的相关情况，一般用于诊断jni调用错误信息。</p>
<h3 id="5-2-扩展参数-X"><a href="#5-2-扩展参数-X" class="headerlink" title="5.2 扩展参数(-X)"></a>5.2 扩展参数(-X)</h3><h4 id="内存大小"><a href="#内存大小" class="headerlink" title="内存大小"></a>内存大小</h4><p>-Xms</p>
<p>​    指定初始堆大小（最小堆大小）</p>
<p>-Xmx</p>
<p>​    指定最大堆大小</p>
<p>-Xmn</p>
<p>​    指定新生代大小</p>
<p>-Xss</p>
<p>​    指定每个线程的栈大小</p>
<h3 id="5-3-非Stable参数-XX"><a href="#5-3-非Stable参数-XX" class="headerlink" title="5.3 非Stable参数(-XX)"></a>5.3 非Stable参数(-XX)</h3><p>-XX:PermSize</p>
<p>​    持久代（方法区）的初始内存大小</p>
<p>-XX:MaxPermSize</p>
<p>​    持久代（方法区）的最大内存大小</p>
<p>-XX:NewRadio</p>
<p>​    新生代与老年代的比值</p>
<p>-XX:SurvivorRadio</p>
<p>​    Eden与Survivor的比值</p>
<h2 id="六、锁"><a href="#六、锁" class="headerlink" title="六、锁"></a>六、锁</h2><h3 id="6-1-锁优化"><a href="#6-1-锁优化" class="headerlink" title="6.1 锁优化"></a>6.1 锁优化</h3><h4 id="6-1-1-自旋锁与自适应自旋"><a href="#6-1-1-自旋锁与自适应自旋" class="headerlink" title="6.1.1 自旋锁与自适应自旋"></a>6.1.1 自旋锁与自适应自旋</h4><p>​    <strong>多核机器中，对于阻塞锁，自动引入自旋（先不进行阻塞，进行几次循环），如果自旋成功（即持锁线程已经释放锁），就拿到锁继续执行，避免了阻塞影响性能。</strong></p>
<p>​    自旋的次数受之前在该锁的自旋情况影响，自适应调整。</p>
<h4 id="6-1-2-锁消除"><a href="#6-1-2-锁消除" class="headerlink" title="6.1.2 锁消除"></a>6.1.2 锁消除</h4><p>​    JVM经过逃逸分析，<strong>发现锁对象不会逸出线程的引用时（即其他线程没有使用该锁）</strong>，会消除掉锁。</p>
<h4 id="6-1-3-锁粗化"><a href="#6-1-3-锁粗化" class="headerlink" title="6.1.3 锁粗化"></a>6.1.3 锁粗化</h4><p>​    较短的间隔时间内，多次对同一资源加锁，JVM会将所有锁合并为一个“粗”锁。</p>
<h4 id="6-1-4-轻量级锁"><a href="#6-1-4-轻量级锁" class="headerlink" title="6.1.4 轻量级锁"></a>6.1.4 轻量级锁</h4><p>​    对于绝大部分锁，在同步周期内（一段时间内）是没有竞争发生的。</p>
<p>​    <strong>获取一个对象的锁时，使用CAS替换操作判定是否被占用。若替换成功（未占用），使用轻量级锁（即不映射到操作系统）。若已被占用，且是轻量级锁，则会锁膨胀升级为重量级锁。</strong></p>
<h4 id="6-1-5-偏向锁"><a href="#6-1-5-偏向锁" class="headerlink" title="6.1.5 偏向锁"></a>6.1.5 偏向锁</h4><p>​    锁会偏向于第一个获得它的线程。</p>
<p>​    只有第一次使用CAS将线程ID设置到对象Mark Word，在对象Mark Word中<strong>记录下第一个线程的id，并进入偏向锁模式</strong>。如果此后仍旧是这个线程获取该锁，则都没有任何同步操作。</p>
<p>​    <strong>直到出现第二个线程试图获取该锁，则进行锁撤销（撤销掉偏向锁），变成无锁状态或轻量级锁状态。</strong></p>
<p>​    计算过hash值的对象无法进入偏向锁状态，偏向锁状态下的对象收到hash计算请求时，会进入重量级锁状态。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">rnang0</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://rnang0.github.io/2020/07/13/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A06%EF%BC%9AJVM/">http://rnang0.github.io/2020/07/13/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A06%EF%BC%9AJVM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://rnang0.github.io" target="_blank">rnang0 Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%94%81/">锁</a><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java内存模型</a></div><div class="post_share"><div class="social-share" data-image="https://img-blog.csdnimg.cn/20201207121521698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/07/25/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A07%EF%BC%9AJava%E5%B9%B6%E5%8F%91/"><img class="prev_cover" src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=4060513360,1461496884&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">春招复习7：Java并发</div></div></a></div><div class="next-post pull_right"><a href="/2020/06/28/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A05%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><img class="next_cover" src="https://img-blog.csdnimg.cn/20200701112110271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">春招复习5：计算机网络</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/07/25/春招复习7：Java并发/" title="春招复习7：Java并发"><img class="relatedPosts_cover" src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=4060513360,1461496884&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-25</div><div class="relatedPosts_title">春招复习7：Java并发</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/23/春招复习4：操作系统/" title="春招复习4：操作系统"><img class="relatedPosts_cover" src="https://img-blog.csdnimg.cn/20200624114032370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-23</div><div class="relatedPosts_title">春招复习4：操作系统</div></div></a></div><div class="relatedPosts_item"><a href="/2020/12/07/春招面经：多线程并发/" title="春招面经：多线程并发"><img class="relatedPosts_cover" src="https://img-blog.csdnimg.cn/20201207121521698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-12-07</div><div class="relatedPosts_title">春招面经：多线程并发</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By rnang0</div><div class="footer_custom_text">Hi, welcome to my <a href="http://rnang0.github.io/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script></body></html>