<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java并发与多线程（2）_线程、同步 | rnang0 Blog</title><meta name="description" content="@toc 一、线程1、多线程原理我们已经写过一版多线程的代码，那么我们今天来体现一下多线程程序的执行原理。代码如下： &#x2F;** * 自定义一个线程类extends Thread * @author Mango *&#x2F;public class MainThread extends Thread&amp;#123;    &#x2F;**     * 利用继承的特点将 线程名字 设置     * @param name"><meta name="author" content="rnang0"><meta name="copyright" content="rnang0"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java并发与多线程（2）_线程、同步"><meta name="twitter:description" content="@toc 一、线程1、多线程原理我们已经写过一版多线程的代码，那么我们今天来体现一下多线程程序的执行原理。代码如下： &#x2F;** * 自定义一个线程类extends Thread * @author Mango *&#x2F;public class MainThread extends Thread&amp;#123;    &#x2F;**     * 利用继承的特点将 线程名字 设置     * @param name"><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Java并发与多线程（2）_线程、同步"><meta property="og:url" content="http://rnang0.github.io/2020/05/20/Java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%882%EF%BC%89_%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5/"><meta property="og:site_name" content="rnang0 Blog"><meta property="og:description" content="@toc 一、线程1、多线程原理我们已经写过一版多线程的代码，那么我们今天来体现一下多线程程序的执行原理。代码如下： &#x2F;** * 自定义一个线程类extends Thread * @author Mango *&#x2F;public class MainThread extends Thread&amp;#123;    &#x2F;**     * 利用继承的特点将 线程名字 设置     * @param name"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-05-20T07:22:58.001Z"><meta property="article:modified_time" content="2020-05-20T07:22:58.280Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="canonical" href="http://rnang0.github.io/2020/05/20/Java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%882%EF%BC%89_%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5/"><link rel="prev" title="Java并发与多线程（3）_线程池、等待唤醒" href="http://rnang0.github.io/2020/05/20/Java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%883%EF%BC%89_%E7%BA%BF%E7%A8%8B%E6%B1%A0%E3%80%81%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92/"><link rel="next" title="Java并发与多线程（1）_多线程" href="http://rnang0.github.io/2020/05/20/Java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%881%EF%BC%89_%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'none',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/autor.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">87</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">115</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-mars"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、线程"><span class="toc-text">一、线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、多线程原理"><span class="toc-text">1、多线程原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、Thread类"><span class="toc-text">2、Thread类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、Runnable创建线程"><span class="toc-text">3、Runnable创建线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、Thread和Runnable的区别"><span class="toc-text">4、Thread和Runnable的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、线程安全"><span class="toc-text">二、线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、线程安全"><span class="toc-text">1、线程安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、线程同步"><span class="toc-text">2、线程同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、同步代码块"><span class="toc-text">3、同步代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、同步方法"><span class="toc-text">4、同步方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、Lock锁（常用）"><span class="toc-text">5、Lock锁（常用）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、线程状态"><span class="toc-text">三、线程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、线程状态概述"><span class="toc-text">1、线程状态概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、Timed-Waiting（计时等待）"><span class="toc-text">2、Timed Waiting（计时等待）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、BLOCKED（锁阻塞）"><span class="toc-text">3、BLOCKED（锁阻塞）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、Waiting（无限等待）"><span class="toc-text">4、Waiting（无限等待）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、补充"><span class="toc-text">5、补充</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">rnang0 Blog</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-mars"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Java并发与多线程（2）_线程、同步</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-20 15:22:58"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-20</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-20 15:22:58"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-20</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>@<a href="Java并发与多线程（2）:线程、同步">toc</a></p>
<h1 id="一、线程"><a href="#一、线程" class="headerlink" title="一、线程"></a>一、线程</h1><h2 id="1、多线程原理"><a href="#1、多线程原理" class="headerlink" title="1、多线程原理"></a>1、多线程原理</h2><p>我们已经写过一版多线程的代码，那么我们今天来体现一下<strong>多线程程序的执行原理</strong>。<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义一个线程类extends Thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mango</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用继承的特点将 线程名字 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MainThread(String name) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写的run方法，线程要执行的语句</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//getName()来自Thread</span></span><br><span class="line">            System.out.println(getName() + <span class="string">"：正在执行！"</span>+ i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mango</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dome1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"这里是Main线程"</span>);</span><br><span class="line">        </span><br><span class="line">        MainThread mainThread = <span class="keyword">new</span> MainThread(<span class="string">"新线程"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启一个新线程</span></span><br><span class="line">        mainThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main线程"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序启动运行main时候，<strong>JVM启动一个进程，主线程main在main()调用时候被创建</strong>。随着调用mainThread的对象的start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。</p>
<p>多线程的执行流程，那么为什么可以完成并发执行呢？我们再来讲一讲原理。<br>多线程执行时，到底在内存中是如何运行的呢？以上个程序为例，进行图解说明：</p>
<p><img src="https://img-blog.csdnimg.cn/20191001213426892.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>多线程执行时，在栈内存中，其实<strong>每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。</strong></p>
<p>当执行线程的任务结束了，<strong>线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。</strong></p>
<h2 id="2、Thread类"><a href="#2、Thread类" class="headerlink" title="2、Thread类"></a>2、Thread类</h2><p>API中该类中定义了有关线程的一些方法，具体如下：<br>（1）构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> :分配一个新的线程对象。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(String name)</span> :分配一个指定名字的新的线程对象。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> :分配一个带有指定目标新的线程对象。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target,String name)</span> :分配一个带有指定目标新的线程对象并指定名字。</span></span><br></pre></td></tr></table></figure>

<p>（2）常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> :获取当前线程名称。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> :导致此线程开始执行</span>; Java虚拟机调用此线程的run方法。</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> :此线程要执行的任务在此处定义代码。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span> :返回对当前正在执行的线程对象的引用。</span></span><br></pre></td></tr></table></figure>
<p>创建线程的方式总共有两种，<strong>一种是继承Thread类方式，一种是实现Runnable接口方式</strong>。<br>方式一已经明白，接下来讲解方式二实现的方式。</p>
<h2 id="3、Runnable创建线程"><a href="#3、Runnable创建线程" class="headerlink" title="3、Runnable创建线程"></a>3、Runnable创建线程</h2><p>采用java.lang.Runnable （<strong>通过实现runnable接口，来作为参数传递</strong>）也是非常常见的一种，我们只需要重写run方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个Runnable接口的实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mango</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DomeRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写接口的run方法，设置线程任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + i );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mango</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dome1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个Runnable接口实现类对象</span></span><br><span class="line">        DomeRunnable runnable = <span class="keyword">new</span> DomeRunnable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//采用传递runnable的构造方法创建</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启新的线程run方法</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + i );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过实现Runnable接口，使得该类有了多线程类的特征。<strong>run()方法是多线程程序的一个执行目标</strong>。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。</p>
<p>在启动的多线程的时候，<strong>需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。</strong></p>
<p>实际上所有的多线程代码都是通过运行Thread的<strong>start()方法来运行的</strong>。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。</p>
<p>tips:Runnable对象仅仅作为Thread对象的target，<strong>Runnable实现类里包含的run()方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。</strong></p>
<h2 id="4、Thread和Runnable的区别"><a href="#4、Thread和Runnable的区别" class="headerlink" title="4、Thread和Runnable的区别"></a>4、Thread和Runnable的区别</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。</span><br></pre></td></tr></table></figure>
<p><strong>实现Runnable接口比继承Thread类所具有的优势：</strong></p>
<ol>
<li>适合多个相同的程序代码的线程去共享同一个资源。</li>
<li>可以避免java中的单继承的局限性。</li>
<li>增加程序的健壮性，<strong>实现解耦操作，代码可以被多个线程共享（作参数被多个thread调用），代码和线程独立。</strong></li>
<li><strong>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。</strong></li>
</ol>
<p>扩充：<strong>在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程</strong>。因为每当使用<br>java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进<br>程。</p>
<h1 id="二、线程安全"><a href="#二、线程安全" class="headerlink" title="二、线程安全"></a>二、线程安全</h1><h2 id="1、线程安全"><a href="#1、线程安全" class="headerlink" title="1、线程安全"></a>1、线程安全</h2><p>如果有多个线程在同时运行，而这些线程<strong>可能会同时运行这段代码</strong>。程序每次运行结果和单线程运行的结果是一样<br>的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<p>我们通过一个案例，实现多个窗口同时卖电影票。演示线程的安全问题：<br><img src="https://img-blog.csdnimg.cn/20191001213528422.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（1）需要票，Runnable接口子类来模拟</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟票</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mango</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//线程共享的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 卖票操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                String name = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name + <span class="string">"正在卖"</span> + ticket--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）需要窗口，采用线程对象来模拟；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mango</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dome1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">		<span class="comment">//同时开启线程，执行run方法</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(ticket,<span class="string">"窗口1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(ticket,<span class="string">"窗口2"</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(ticket,<span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果中有一部分这样现象，发现程序出现了两个问题：</p>
<ol>
<li>相同的票数,比如5这张票被卖了两回。</li>
<li>不存在的票，比如0票与-1票，是不存在的。</li>
</ol>
<p><strong>这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。</strong><br><img src="https://img-blog.csdnimg.cn/20190930163330996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>线程安全问题都是由<strong>全局变量及静态变量</strong>引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；<strong>若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</strong><br><img src="https://img-blog.csdnimg.cn/20191001213551961.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="2、线程同步"><a href="#2、线程同步" class="headerlink" title="2、线程同步"></a>2、线程同步</h2><p>当我们使用多个线程访问同一资源的时候，且<strong>多个线程中对资源有写的操作，就容易出现线程安全问题</strong>。</p>
<p>要解决上述<strong>多线程并发</strong>访问一个资源（ticket）的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制(synchronized) 来解决。</p>
<p><img src="https://img-blog.csdnimg.cn/20191003103337734.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU<br>资源，完成对应的操作，<strong>保证了数据的同步性</strong>，解决了线程不安全的现象。为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。</p>
<p>有三种方式完成同步操作：</p>
<ol>
<li>同步代码块。</li>
<li>同步方法。</li>
<li><strong>锁机制。</strong></li>
</ol>
<h2 id="3、同步代码块"><a href="#3、同步代码块" class="headerlink" title="3、同步代码块"></a>3、同步代码块</h2><p><strong>synchronized 关键字</strong>可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。<br>格式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同步代码块</span></span><br><span class="line"> <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">     <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     String name = Thread.currentThread().getName();</span><br><span class="line">     System.out.println(name + <span class="string">"正在卖"</span> + ticket--);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>同步锁:<br><strong>对象的同步锁</strong>只是一个概念,可以想象为在对象上标记了一个锁.</p>
<ol>
<li>锁对象 可以是任意类型。</li>
</ol>
<p><strong>2. 多个线程对象 要使用同一把锁</strong>。</p>
<p><strong>注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。</strong></p>
<p>使用同步代码块解决代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟票</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mango</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多线程共享数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个锁对象</span></span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 卖票操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//同步代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                String name = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name + <span class="string">"正在卖"</span> + ticket--);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、同步方法"><a href="#4、同步方法" class="headerlink" title="4、同步方法"></a>4、同步方法</h2><p>同步方法:<strong>使用synchronized修饰的方法</strong>,就叫做同步方法,<strong>保证A线程执行该方法的时候,其他线程只能在方法外等着。</strong><br>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">	可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同步锁是谁?<br>对于非static方法,同步锁就是this。<br>对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟票</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mango</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多线程共享数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 卖票操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">           sellTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 谁调用这个方法就是锁对象</span></span><br><span class="line"><span class="comment">     * 隐含锁对象就是这个this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">//同步方法</span></span><br><span class="line">        <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(name + <span class="string">"正在卖"</span> + ticket--);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、Lock锁（常用）"><a href="#5、Lock锁（常用）" class="headerlink" title="5、Lock锁（常用）"></a>5、Lock锁（常用）</h2><p>java.util.concurrent.locks.Lock 机制提供了比synchronized代码块和synchronized方法<strong>更广泛的锁定操作</strong>,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。</p>
<p><strong>Lock锁也称同步锁</strong>，加锁与释放锁 方法化了，如下：<br><strong>public void lock() :加同步锁。<br>public void unlock() :释放同步锁。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟票</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mango</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多线程共享数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个lock锁对象</span></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 卖票操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//同步方法</span></span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                String name = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name + <span class="string">"正在卖"</span> + ticket--);</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、线程状态"><a href="#三、线程状态" class="headerlink" title="三、线程状态"></a>三、线程状态</h1><h2 id="1、线程状态概述"><a href="#1、线程状态概述" class="headerlink" title="1、线程状态概述"></a>1、线程状态概述</h2><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在<strong>线程的生命周期</strong>中这各个<strong>线程状态</strong>发生的条件，下面将会对每种状态进行详细解析：<br><img src="https://img-blog.csdnimg.cn/20191007120702449.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（1）Runnable(可运行)<br>线程可以在java虚拟机中运行的状态，<strong>可能正在运行自己代码，也可能没有，这取决于操作系统处理器（cpu）</strong>。</p>
<p>（2）Blocked(锁阻塞)<br>当一个线程试图获取一个对象锁，<strong>而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。</strong></p>
<p>（3）Waiting(无限等待)<br>一个线程在<strong>等待另一个线程执行一个（唤醒）动作时</strong>，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，<strong>必须等待另一个线程调用notify或者notifyAll方法才能够唤醒</strong>。</p>
<p>我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几个状态呢，新建与被终止还是很容易理解的，我们就研究一下<strong>线程从Runnable（可运行）状态与非运行状态之间的转换问题</strong>。</p>
<h2 id="2、Timed-Waiting（计时等待）"><a href="#2、Timed-Waiting（计时等待）" class="headerlink" title="2、Timed Waiting（计时等待）"></a>2、Timed Waiting（计时等待）</h2><p>Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。在我们写卖票的案例中，<strong>为了减少线程执行太快，现象不明显等问题</strong>，我们在run方法中添加了<strong>sleep语句</strong>，这样就<strong>强制当前正在执行的线程休眠（暂停执行），以“减慢线程”</strong>。</p>
<p><strong>sleep就是等待。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 卖票操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//开启线程锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                String name = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name + <span class="string">"正在卖"</span> + ticket--);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//关闭线程锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们需要记住下面几点：</p>
<ol>
<li>进入 TIMED_WAITING 状态的一种常见情形是<strong>调用的 sleep 方法</strong>，单独的线程也可以调用，不一定非要有协<br>作关系。</li>
<li>为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程<br>中会睡眠</li>
<li><strong>sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态</strong>。<br><img src="https://img-blog.csdnimg.cn/20191007121725479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="3、BLOCKED（锁阻塞）"><a href="#3、BLOCKED（锁阻塞）" class="headerlink" title="3、BLOCKED（锁阻塞）"></a>3、BLOCKED（锁阻塞）</h2>Blocked状态在API中的介绍为：一个正在阻塞<strong>等待一个监视器锁（锁对象）的线程</strong>处于这一状态。<br>比如，线程A与线程B代码中使用同一锁，<strong>如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。</strong><br><img src="https://img-blog.csdnimg.cn/20191007121939722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="4、Waiting（无限等待）"><a href="#4、Waiting（无限等待）" class="headerlink" title="4、Waiting（无限等待）"></a>4、Waiting（无限等待）</h2>一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。<br><img src="https://img-blog.csdnimg.cn/20191007123214690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入了Waiting（无限等待）状态，同时失去了同步锁。<strong>假如这个时候B线程获取到了同步锁，在运行状态中调用了notify()方法，那么就会将无限等待的A线程唤醒</strong>。注意是唤醒，如果A获取到锁对象，那么A线程唤醒后就进入Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。<h2 id="5、补充"><a href="#5、补充" class="headerlink" title="5、补充"></a>5、补充</h2>线程状态整体概括：<br><img src="https://img-blog.csdnimg.cn/20191007123300449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">rnang0</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://rnang0.github.io/2020/05/20/Java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%882%EF%BC%89_%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5/">http://rnang0.github.io/2020/05/20/Java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%882%EF%BC%89_%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://rnang0.github.io" target="_blank">rnang0 Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/7894478?v=3" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/20/Java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%883%EF%BC%89_%E7%BA%BF%E7%A8%8B%E6%B1%A0%E3%80%81%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92/"><img class="prev_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java并发与多线程（3）_线程池、等待唤醒</div></div></a></div><div class="next-post pull_right"><a href="/2020/05/20/Java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%881%EF%BC%89_%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><img class="next_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java并发与多线程（1）_多线程</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By rnang0</div><div class="footer_custom_text">Hi, welcome to my <a href="http://rnang0.github.io/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script></body></html>