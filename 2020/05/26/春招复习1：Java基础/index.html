<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>春招复习1：Java基础 | rnang0 Blog</title><meta name="description" content="Java基础加强重点学习内容 面向对象 字符串 接口 容器 异常 泛型 反射 注解 I&#x2F;O  一、面向对象特性1. 面向对象​    面向对象是一种编程思想，是使用类或对象作为组织代码的基本单元，具有继承、封装、多态三大特性。  封装就是控制类的访问权限，只开放出对外的方法，并抽象出接口类，供使用者操作。一方面，让数据更安全，另一方面，也提高了易用性。 继承子类可以使用父类的非私有变量和方法，主要"><meta name="keywords" content="Java基础,String,反射,异常,I/O"><meta name="author" content="rnang0"><meta name="copyright" content="rnang0"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="春招复习1：Java基础"><meta name="twitter:description" content="Java基础加强重点学习内容 面向对象 字符串 接口 容器 异常 泛型 反射 注解 I&#x2F;O  一、面向对象特性1. 面向对象​    面向对象是一种编程思想，是使用类或对象作为组织代码的基本单元，具有继承、封装、多态三大特性。  封装就是控制类的访问权限，只开放出对外的方法，并抽象出接口类，供使用者操作。一方面，让数据更安全，另一方面，也提高了易用性。 继承子类可以使用父类的非私有变量和方法，主要"><meta name="twitter:image" content="data:image/png;base64,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"><meta property="og:type" content="article"><meta property="og:title" content="春招复习1：Java基础"><meta property="og:url" content="http://rnang0.github.io/2020/05/26/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A01%EF%BC%9AJava%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="rnang0 Blog"><meta property="og:description" content="Java基础加强重点学习内容 面向对象 字符串 接口 容器 异常 泛型 反射 注解 I&#x2F;O  一、面向对象特性1. 面向对象​    面向对象是一种编程思想，是使用类或对象作为组织代码的基本单元，具有继承、封装、多态三大特性。  封装就是控制类的访问权限，只开放出对外的方法，并抽象出接口类，供使用者操作。一方面，让数据更安全，另一方面，也提高了易用性。 继承子类可以使用父类的非私有变量和方法，主要"><meta property="og:image" content="data:image/png;base64,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"><meta property="article:published_time" content="2020-05-25T16:00:00.000Z"><meta property="article:modified_time" content="2021-03-02T08:41:40.280Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="canonical" href="http://rnang0.github.io/2020/05/26/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A01%EF%BC%9AJava%E5%9F%BA%E7%A1%80/"><link rel="prev" title="春招复习2：Java集合类（上）" href="http://rnang0.github.io/2020/06/09/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A02%EF%BC%9AJava%E9%9B%86%E5%90%88%E7%B1%BB%EF%BC%88%E4%B8%8A%EF%BC%89/"><link rel="next" title="Mybatis中Mapper的实现原理" href="http://rnang0.github.io/2019/12/26/Mybatis%E7%9A%84Mapper%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'none',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/autor.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">68</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">94</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-mars"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java基础加强"><span class="toc-text">Java基础加强</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#重点学习内容"><span class="toc-text">重点学习内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一、面向对象特性"><span class="toc-text">一、面向对象特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-面向对象"><span class="toc-text">1. 面向对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-重载和重写"><span class="toc-text">2. 重载和重写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-重载"><span class="toc-text">2.1 重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-重写"><span class="toc-text">2.2 重写</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-public，protect，private修饰符及默认default"><span class="toc-text">3. public，protect，private修饰符及默认default</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-static，final"><span class="toc-text">4. static，final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-接口和抽象类的区别"><span class="toc-text">5. 接口和抽象类的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、String字符串"><span class="toc-text">二、String字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-存储结构"><span class="toc-text">1. 存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-不可变性"><span class="toc-text">2. 不可变性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结："><span class="toc-text">总结：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-String对象性能优化"><span class="toc-text">3.  String对象性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-字符串的拼接"><span class="toc-text">3.1 字符串的拼接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-toString方法"><span class="toc-text">3.2 toString方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-StringBuilder概述"><span class="toc-text">3.3 StringBuilder概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-循环拼接"><span class="toc-text">3.4 循环拼接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-intern-方法"><span class="toc-text">3.5 intern()方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-String、StringBuffer、StringBuilder"><span class="toc-text">4. String、StringBuffer、StringBuilder</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、异常"><span class="toc-text">三、异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-分类"><span class="toc-text">1. 分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-异常Exception分类"><span class="toc-text">2. 异常Exception分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-异常的处理"><span class="toc-text">3. 异常的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-try-catch-finally"><span class="toc-text">3.1 try-catch-finally</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-throws"><span class="toc-text">3.2 throws</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-throws与throw的区别"><span class="toc-text">4. throws与throw的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、泛型"><span class="toc-text">四、泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-为什么使用泛型"><span class="toc-text">1. 为什么使用泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-泛型的实现"><span class="toc-text">2. 泛型的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、语法糖"><span class="toc-text">五、语法糖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-数据类型"><span class="toc-text">1. 数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-泛型"><span class="toc-text">2. 泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-自动拆箱、装箱"><span class="toc-text">3. 自动拆箱、装箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-foreach"><span class="toc-text">4. foreach</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-equels与"><span class="toc-text">5. equels与&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、反射"><span class="toc-text">六、反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-过程"><span class="toc-text">1. 过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-常用API"><span class="toc-text">2. 常用API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-平时使用用途"><span class="toc-text">3. 平时使用用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-动态代理"><span class="toc-text">4. 动态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-两种动态代理区别"><span class="toc-text">5. 两种动态代理区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、注解"><span class="toc-text">七、注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-原理"><span class="toc-text">1. 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-元注解"><span class="toc-text">2.元注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-自定义注解"><span class="toc-text">3. 自定义注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、I-O"><span class="toc-text">八、I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-I-O-分类"><span class="toc-text">1. I&#x2F;O 分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-对象流"><span class="toc-text">2. 对象流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-序列化"><span class="toc-text">2.1 序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-Serializable"><span class="toc-text">2.2 Serializable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-transient"><span class="toc-text">2.3 transient</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-NIO"><span class="toc-text">3. NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-IO模型"><span class="toc-text">3.1 IO模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-BIO、NIO、AIO适用场景"><span class="toc-text">3.2 BIO、NIO、AIO适用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-NIO三大核心组件"><span class="toc-text">3.3 NIO三大核心组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-缓冲区Buffer"><span class="toc-text">3.4 缓冲区Buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-通道Channel"><span class="toc-text">3.5 通道Channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-选择器Selector"><span class="toc-text">3.6 选择器Selector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-NIO网络编程"><span class="toc-text">3.7 NIO网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-7-1-SelectionKey"><span class="toc-text">3.7.1 SelectionKey</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-7-2-ServerSocketChannel"><span class="toc-text">3.7.2 ServerSocketChannel</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-7-3-SocketChannel通道"><span class="toc-text">3.7.3 SocketChannel通道</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-零拷贝"><span class="toc-text">3.8 零拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-8-1-mmap优化"><span class="toc-text">3.8.1 mmap优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-8-2-sendfile优化"><span class="toc-text">3.8.2 sendfile优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-8-3-mmap-和-sendFile-的区别"><span class="toc-text">3.8.3 mmap 和 sendFile 的区别</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#补充"><span class="toc-text">补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-序列化"><span class="toc-text">1. 序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JDK与JRE"><span class="toc-text">2. JDK与JRE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-java8新特性"><span class="toc-text">3. java8新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-深浅拷贝"><span class="toc-text">4. 深浅拷贝</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(data:image/png;base64,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)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">rnang0 Blog</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-mars"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">春招复习1：Java基础</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-26 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-26</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-03-02 16:41:40"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-03-02</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/">春招复习</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Java基础加强"><a href="#Java基础加强" class="headerlink" title="Java基础加强"></a>Java基础加强</h1><h2 id="重点学习内容"><a href="#重点学习内容" class="headerlink" title="重点学习内容"></a>重点学习内容</h2><ul>
<li>面向对象</li>
<li>字符串</li>
<li>接口</li>
<li>容器</li>
<li>异常</li>
<li>泛型</li>
<li>反射</li>
<li>注解</li>
<li>I/O</li>
</ul>
<h2 id="一、面向对象特性"><a href="#一、面向对象特性" class="headerlink" title="一、面向对象特性"></a>一、面向对象特性</h2><h3 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="1. 面向对象"></a>1. 面向对象</h3><p>​    面向对象是一种编程思想，是使用类或对象作为组织代码的基本单元，具有继承、封装、多态三大特性。</p>
<ul>
<li>封装就是控制类的访问权限，只开放出对外的方法，并抽象出接口类，供使用者操作。一方面，让数据更安全，另一方面，也提高了易用性。</li>
<li>继承<strong>子类可以使用父类的非私有变量和方法</strong>，主要作用就是实现<strong>代码复用</strong>。</li>
<li><strong>多态提高了代码的可拓展性和复用性</strong>，是指<strong>一个类实例的相同方法在不同情形有不同表现形式。</strong>通过同一个上级引用指向不同的子类，使得对同一消息做出不同回应。</li>
</ul>
<h3 id="2-重载和重写"><a href="#2-重载和重写" class="headerlink" title="2. 重载和重写"></a>2. 重载和重写</h3><p>​    重载和重写是面向对象<strong>多态性的体现</strong>，重载指的是同一个类中的同名方法可以根据不同的参数列表来区分，重写也称覆写，指的是子类可以重写父类的方法。</p>
<h4 id="2-1-重载"><a href="#2-1-重载" class="headerlink" title="2.1 重载"></a>2.1 重载</h4><p>​    在Java中，<strong>重载是在编译期确定的</strong>，下面的例子可以说明，<strong>在编译期，编译器并不知道对象的实际类型</strong>，所以在调用方法的时候通过静态类型判断来选择重载的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"guy say hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man man)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"man say hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman woman)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"woman say hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// Man和Woman继承了Human</span></span><br><span class="line">    Human man = <span class="keyword">new</span> Man();</span><br><span class="line">    Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">    StaticDispatch sd = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">    sd.sayHello(man); <span class="comment">// guy say hello</span></span><br><span class="line">    sd.sayHello(woman);<span class="comment">// guy say hello</span></span><br><span class="line">    sd.sayHello((Man)man);<span class="comment">// man say hello</span></span><br><span class="line">    sd.sayHello((Woman)woman);<span class="comment">// woman say hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-2-重写"><a href="#2-2-重写" class="headerlink" title="2.2 重写"></a>2.2 重写</h4><p>​    <strong>重写是在运行期确定的</strong>，通过下面的例子可以看到。</p>
<p>​    首先根据编译期的重载，两个方法选择了Father.hardChoice(_360()); Father.hardChoice(QQ()); 。在运行时，虚方法表中存放着各个方法的实际入口地址，<strong>如果没有重写，子类的方法表中方法的地址就是父类方法表中方法的地址</strong>，<strong>重写之后子类的方法表中方法的地址就会替换为子类重写的方法的地址。</strong>所以在运行期，Son的方法表指向的是Son.hardChoice(QQ());</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_360</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose qq"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose 360"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose qq"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose 360"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Father son = <span class="keyword">new</span> Son();</span><br><span class="line"></span><br><span class="line">        father.hardChoice(<span class="keyword">new</span> _360()); <span class="comment">// father choose 360</span></span><br><span class="line">        son.hardChoice(<span class="keyword">new</span> QQ());<span class="comment">// son choose qq</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-public，protect，private修饰符及默认default"><a href="#3-public，protect，private修饰符及默认default" class="headerlink" title="3. public，protect，private修饰符及默认default"></a>3. public，protect，private修饰符及默认default</h3><p>​    public可以被任何类调用，<strong>protect区别主要是不同包的话，就必须是子类才能访问。（即同包、不同包子类）</strong>，private呢就只能自己才能访问。</p>
<p>​    default：就默认的访问权限，自己和<strong>同包</strong>下访问。</p>
<h3 id="4-static，final"><a href="#4-static，final" class="headerlink" title="4. static，final"></a>4. static，final</h3><p>​    static用于修饰属性，使的<strong>属性属于类，只实例化一次，类及其实例化对象都使用这一个；</strong>也可以修饰方法，<strong>可以修饰内部类来做静态代码块。</strong></p>
<p>​    <strong>final修饰的类不能继承</strong>，修饰的<strong>变量值不能改变</strong>，final修饰的<strong>引用地址不能改，但地址对应的内部内容可以改。</strong></p>
<h3 id="5-接口和抽象类的区别"><a href="#5-接口和抽象类的区别" class="headerlink" title="5. 接口和抽象类的区别"></a>5. 接口和抽象类的区别</h3><ol>
<li><strong>接口的方法都是抽象的</strong>，抽象类的方法可以是抽象的，也可以是非抽象的；</li>
<li><strong>只要不是抽象类abstract，实现接口必须实现所有的类，同时继承抽象类时，必须实现abstract抽象方法。</strong></li>
<li><strong>接口</strong>成员函数都是<strong>默认public</strong>，抽象类有多种修饰符；</li>
<li>在Java中类是多实现，单继承的，所以<strong>继承抽象类的方法调用比实现类实现接口的方法调用快；</strong></li>
</ol>
<p><strong>抽象类是用来实现子类的通用特性</strong>，有利于代码复用。<strong>接口实现不同的模块间的方法名的统一</strong>或者涉及多继承的情况都用接口，大部分情况下也都使用的是接口，利于多态的实现。</p>
<h2 id="二、String字符串"><a href="#二、String字符串" class="headerlink" title="二、String字符串"></a>二、String字符串</h2><p>下面是我们的案例：进入String，查看源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> rnang0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/5/26 18:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"abc"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    进入到java.lang.String中</p>
<p><img src="https://img-blog.csdnimg.cn/20200526211205280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="1"></p>
<h3 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h3><p>​    <strong>String实际上是char数组，final声明不可继承</strong>。其实这在我们c语言中，是显然的，c语言就没有字符串的概念，全是字符数组，在C++中才被引入String字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure>

<p>​    存储结构的变更：<strong>jdk8为char[]数组，而9之后就开始使用的是byte[]字节数组</strong>，原因如下：</p>
<p>​    <strong>一个char两个字节（16位），7之后String字符串占据了堆空间的主要区域，而字符串中一些拉丁文的编码字符占大多数，它们是只需要一个字节即可存储，这样就会有一半空间浪费，所以采用byte数组来分类存储：中文，UTF-16占2个字节，一些拉丁文的编码字符采用一个字节存储。</strong></p>
<h3 id="2-不可变性"><a href="#2-不可变性" class="headerlink" title="2. 不可变性"></a>2. 不可变性</h3><p>​    我们发现，String类本身以及其属性都是final（不可继承）的，这是为什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//String实际是字符数组value[]</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure>

<p>String 申请后不可再变，这样做</p>
<ol>
<li>因为可以节约堆空间，<strong>多个字符串变量都会指向字符串常量池中同一个字符串；</strong></li>
<li>在多线程环境下，那么不能变的话就<strong>保证了线程安全</strong>；</li>
<li>在类加载时描述符都是字符串形式的，不可变就提高了安全性；</li>
<li>最后就是字符串的不变性让他很适合做hash映射的键，<strong>由于本身不变化，所以hashcode也不会变化，那么可以缓存字符串的hashcode提高效率。</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="string">"abc"</span>;</span><br><span class="line"><span class="comment">// 内存中只有一个"abc"对象被创建，同时被s1和s2共享。</span></span><br></pre></td></tr></table></figure>

<p>面试题：str指向的是堆空间中的String对象，而由于<strong>不可变性</strong>，在change方法中局部变量str开始是指向堆空间中的String对象，然后又指向字符串常量池中”test ok”，出来后str不变，<strong>而数组是可以改变值的。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTransmit</span> </span>&#123;</span><br><span class="line">    String str = <span class="keyword">new</span> String(<span class="string">"good"</span>);</span><br><span class="line">    <span class="keyword">char</span> [] ch = &#123;<span class="string">'t'</span>,<span class="string">'e'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str,<span class="keyword">char</span> ch[])</span></span>&#123;</span><br><span class="line">        str = <span class="string">"test ok"</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">'b'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringTransmit ex = <span class="keyword">new</span> StringTransmit();</span><br><span class="line">        ex.change(ex.str,ex.ch);</span><br><span class="line">        System.out.println(ex.str); <span class="comment">//good</span></span><br><span class="line">        System.out.println(ex.ch); <span class="comment">//best</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>​    String直接用引号创建时会在<strong>字符串常量池（jdk7之前在方法区，后面在堆中）</strong>查看是否已经存在，有的话直接返回内存地址，没有的话创建后返回；</p>
<p>​    new String创建时<strong>会在堆上创建对象并返回</strong>，然后会在常量池中看有没有一样的字符串，有就指向它，没有的话在字符串中创建一个并指向它；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String a = <span class="string">"abc"</span>;</span><br><span class="line">    String b = <span class="string">"abc"</span>;</span><br><span class="line">    System.out.println(a == b); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    String c = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">    String d = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">    System.out.println(c == d); <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-String对象性能优化"><a href="#3-String对象性能优化" class="headerlink" title="3.  String对象性能优化"></a>3.  String对象性能优化</h3><h4 id="3-1-字符串的拼接"><a href="#3-1-字符串的拼接" class="headerlink" title="3.1 字符串的拼接"></a>3.1 字符串的拼接</h4><p>​    ‘’abc”+”def”这种在编译期优化，等价于 ‘’abcdef”，所以这样效率最高。而带有变量的str + “abc”这种方式就不一样了，</p>
<p>​    由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是<strong>会在内存中创建一个新的对象。</strong>虽然拼接时带有变量的<strong>使用 “+” 和StringBuilder拼接，底层都是使用StringBuilder方式</strong>，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间，效率都是一样。</p>
<h4 id="3-2-toString方法"><a href="#3-2-toString方法" class="headerlink" title="3.2 toString方法"></a>3.2 toString方法</h4><p>​    <strong>StringBuilder的toString方法，约等于new String（“xxx”），区别是字符串常量池中没有。</strong></p>
<p>​    所以，<code>new StringBuilder(&quot;abc&quot;).toString().intern();</code>这等价于在字符串常量池中新建了abc，返回其引用。</p>
<h4 id="3-3-StringBuilder概述"><a href="#3-3-StringBuilder概述" class="headerlink" title="3.3 StringBuilder概述"></a>3.3 StringBuilder概述</h4><p>​    查阅<code>java.lang.StringBuilder</code>的API，StringBuilder又称为<strong>可变字符序列</strong>，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p>
<p>​    原来<strong>StringBuilder是个字符串的缓冲区</strong>，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p>
<p>​    <strong>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。</strong>StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)</p>
<p><img src="https://img-blog.csdnimg.cn/20200529210917733.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt=""></p>
<h4 id="3-4-循环拼接"><a href="#3-4-循环拼接" class="headerlink" title="3.4 循环拼接"></a>3.4 循环拼接</h4><p>​    但对于循环拼接，则<strong>必须使用StringBuilder的append方法</strong>进行拼接。如果不使用append，则<strong>会创建n个StrignBuilder对象</strong>，则显示是损耗性能的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"abcdef"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">      str = str + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译优化</span></span><br><span class="line">String str = <span class="string">"abcdef"</span>;</span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(String.valueOf(str));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    str = stringBuilder.append(i).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>在阿里巴巴Java开发手册1.4节17条明确规定，在循环体内的连接方式要使用StringBuilder的append方法进行拓展。</strong></p>
<h4 id="3-5-intern-方法"><a href="#3-5-intern-方法" class="headerlink" title="3.5 intern()方法"></a>3.5 intern()方法</h4><p>​    String类的存储不可变性是为了实现常量池，实现字符串的复用。</p>
<p>​    a指向常量池中的字符串引用，而b创建了两个对象，一个指向的是<strong>堆中新建的String对象</strong>，另一个是字符串常量池里还有。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">"abc"</span>; </span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>​    我们可以看到intern是个本地方法，返回该字符串的引用。</p>
<ol>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">"abc"</span>;</span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">"abc"</span>).intern();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>​    所以a和c都指向常量池中的同一个字符串（c是去常量池中找abc的引用，无创建，有返回），而<strong>b指向堆中的String对象</strong>，但是<strong>三者的value属性都是指向同一个char数组的</strong>。</p>
<ol start="2">
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串复用</span></span><br><span class="line">String a = <span class="string">"abc"</span>;</span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">"abc"</span>).intern();</span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">"efg"</span>).intern();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>如果常量池中有相同的值，就返回常量池中字符串对象的引用。</p>
</li>
<li><p>没有，就把<strong>字符串添加到常量池中</strong>，返回常量池中该字符串的引用。</p>
<p>所以a和b都指向常量池中的同一个字符串 a == b，而c指向常量池中的“efg”。</p>
</li>
</ul>
<h3 id="4-String、StringBuffer、StringBuilder"><a href="#4-String、StringBuffer、StringBuilder" class="headerlink" title="4. String、StringBuffer、StringBuilder"></a>4. String、StringBuffer、StringBuilder</h3><p>​    开始讲了StringBuilder，而StringBuffer与其类似，他们都是<strong>可变的字符序列</strong>，底层依然是char数组/byte数组。</p>
<p>StringBuffer与StringBuilder扩容机制：</p>
<p>​    <strong>默认的容量都是为16，扩容是扩容为原来的2倍 + 2，同时复制，所以频繁的扩容会使效率变低，则初始化时建议指定大小。</strong></p>
<p>异同：</p>
<ol>
<li>String为不可变的字符序列，1.8及之前底层为char数组，9位byte数组</li>
<li>StringBuffer为可变的字符序列，线程安全的，因为底层上所有的方法相对于StringBuilder都使用synchronized修饰了，所以它滴性能就低，底层依然是char数组/byte数组</li>
<li>StringBuilder为可变的字符序列，不是线程安全的，性能高，底层依然是char数组/byte数组</li>
</ol>
<p><strong>效率：StringBuilder &gt; StringBuffer &gt; String</strong></p>
<h2 id="三、异常"><a href="#三、异常" class="headerlink" title="三、异常"></a>三、异常</h2><h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a>1. 分类</h3><p>​    异常分为Error和Exception</p>
<ul>
<li>Error：JVM无法处理的严重问题，例如资源耗尽。<ul>
<li>StackOverflowError栈溢出，OOM（OutOfMemoryError）堆溢出</li>
</ul>
</li>
<li>Exception：这就是我们常说的异常，偶然因素引起，可以用针对性的代码处理。<ul>
<li>数组越界ArrayIndexOutOfBound，空指针异常NullPointException，网络连接中断等</li>
</ul>
</li>
</ul>
<h3 id="2-异常Exception分类"><a href="#2-异常Exception分类" class="headerlink" title="2. 异常Exception分类"></a>2. 异常Exception分类</h3><p>​    Exception才是我们常说的异常，因为Error我们无法通过代码处理。</p>
<p>​    <strong>Exception分为编译期异常（javac.exe）、运行时异常（java.exe）</strong></p>
<ul>
<li>编译时（受检）异常：<ul>
<li>FileNotFoundException，I/O异常，ClassNotFound等</li>
</ul>
</li>
<li>运行时（不受检）异常：<ul>
<li>ArrayIndexOutOfBound，NullPointException，ClassCastException（类型转换异常）</li>
<li>NumberFormatException（数字转换异常，例如字符串通过Interger的方法想转成数字）</li>
<li>ArithmeticException数学异常，例如除以0</li>
</ul>
</li>
</ul>
<h3 id="3-异常的处理"><a href="#3-异常的处理" class="headerlink" title="3. 异常的处理"></a>3. 异常的处理</h3><h4 id="3-1-try-catch-finally"><a href="#3-1-try-catch-finally" class="headerlink" title="3.1 try-catch-finally"></a>3.1 try-catch-finally</h4><p>​    catch中要明确异常的种类，通过e.printStackTrace()来打印异常，但是<strong>它处理的是编译期异常，可能会在运行时发生异常。</strong></p>
<h4 id="3-2-throws"><a href="#3-2-throws" class="headerlink" title="3.2 throws"></a>3.2 throws</h4><p>​    throws + 异常类型，在方法上抛出。</p>
<p>​    与try-catch-finally的区别：try-catch-finally是真滴处理了，throws而是抛给调用者处理。</p>
<p>如何选择？<strong>在当前方法中可以使用try-catch-finally，如果方法与其他方法之前存在递进关系（例如web中的controller-&gt;service-&gt;dao），则可以使用throws抛出去处理。</strong></p>
<h3 id="4-throws与throw的区别"><a href="#4-throws与throw的区别" class="headerlink" title="4. throws与throw的区别"></a>4. throws与throw的区别</h3><p>​    throws 是异常处理的一种方式，声明在方法声明外</p>
<p>​    throw 是我们<strong>自己手动生成抛出</strong>的异常对象，声明在方法体内，一个生成一个处理。</p>
<h2 id="四、泛型"><a href="#四、泛型" class="headerlink" title="四、泛型"></a>四、泛型</h2><h3 id="1-为什么使用泛型"><a href="#1-为什么使用泛型" class="headerlink" title="1. 为什么使用泛型"></a>1. 为什么使用泛型</h3><ol>
<li>不指定存储的数据类型，会导致存入其他的数据类型出现<strong>安全问题</strong>，则泛型进行编译时强类型检查，排查隐患。</li>
<li><strong>避免了强制类型转换</strong>，可能会出现ClassCastExcpetion。</li>
<li>可以实现<strong>通用的算法</strong>，处理不同的类型集合，<strong>不必纠结于具体的数据类型</strong>，易于阅读。</li>
</ol>
<h3 id="2-泛型的实现"><a href="#2-泛型的实现" class="headerlink" title="2. 泛型的实现"></a>2. 泛型的实现</h3><p>​    泛型的实现时采用了<strong>类型擦除</strong>的机制，<strong>任何的具体数据类型都会在编译后被擦除。</strong></p>
<ol>
<li><p>将所有的类型参数，替换为object（若指定边界，例extend xxx，则xxx来替换），字节码仅包括类，方法，接口。</p>
<p>例如：<code>ArrayList&lt;Object&gt;</code>与<code>ArrayList&lt;String&gt;</code>字节码中一样，JVM视为同一类型。</p>
</li>
<li><p>类型的擦除不会创建新类，也就不会产生运行时的开销。</p>
</li>
</ol>
<h2 id="五、语法糖"><a href="#五、语法糖" class="headerlink" title="五、语法糖"></a>五、语法糖</h2><p>​    语法糖是指为了<strong>方便程序员使用的一种语法结构</strong>，在<strong>编译期间会被转换为基础的语法</strong>结构。其实我们每天都在和语法糖打交道，只是我们自己不了解。下面我们看看在Java中都有哪些语法糖。</p>
<p>Java中的语法糖有很多，我这只举例几个常见的例子。</p>
<h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h3><p>​    Java虽然号称完全面向对象，但是他还是有8种基本类型 + String字符串对象，为了照顾性能。</p>
<ol>
<li>byte: 字节，8位，最大存储数据量是255,存放的数据范围是-128~127之间。</li>
<li>boolean: 只有true和false两个取值。</li>
<li>char: 16位，2字节，存储Unicode码，用单引号赋值。</li>
<li>short: 16位，2字节，最大数据存储量是65536，数据范围是 -32768~32767 之间</li>
<li>int: 32位，4字节最大数据存储容量是2的32次方减1,数据范围是负的2的31次方到正的2的31次方减1。</li>
<li>float: 32位，数据范围在3 4e 45~1 4e38,直接赋值时必须在数字后加上f或F。</li>
<li>long: 64位，8字节最大数据存储容量是2的64次方减1,数据范围为负的2的63次方到正的2的63次方减1</li>
<li>double: 64位，数据范围在4 .9e-324~1 .8e308,赋值时可以加d或D也可以不加。</li>
</ol>
<h3 id="2-泛型"><a href="#2-泛型" class="headerlink" title="2. 泛型"></a>2. 泛型</h3><p>​    我们知道，处理泛型有两种方法：</p>
<ol>
<li><p>Code specialization：在实例化一个泛型类或泛型方法时都产生一份新的目标代码。 C++就是使用这种方式。C++编译器会为每一个泛型类实例生成一份执行代码。执行代码中integer list和string list是两种不同的类型。</p>
</li>
<li><p>Code sharing：对每个泛型类<strong>只生成唯一的一份目标代码；Java就是使用这种方式。</strong>将多种泛型类形实例映射到唯一的字节码表示是<strong>通过类型擦除实现</strong>的，在编译期就会擦除类型。<strong>（相当于在编译后直接将数据类型擦去），但是引用的类型还在。</strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParadigmDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParadigmDemo</span> </span>&#123;</span><br><span class="line">        ParadigmDemo() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          	<span class="comment">// 可以看到后面ArrayList的类型已经去掉，但是引用的类型还在。</span></span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            list.add(<span class="number">1</span>);</span><br><span class="line">            list.add(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    所以方法重载是<strong>不能用带范型的参数进行区分</strong>的，因为编译过后，<strong>相当于擦除了new的数据类型，他们的函数签名是相同的</strong>，编译器会报错，如下图。</p>
<p><img src="https://img-blog.csdnimg.cn/2019112515341545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NvdWdvdV8xMzIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="3-自动拆箱、装箱"><a href="#3-自动拆箱、装箱" class="headerlink" title="3. 自动拆箱、装箱"></a>3. 自动拆箱、装箱</h3><p>​    Java对于每种基本类型，都有对应的包装类型，来适应面向对象的思想，方便和其他类进行交互。装箱就是int 转化成 Integer 等等。反之就是拆箱。</p>
<p>原始类型:boolean、char、byte、short、int、long、float、double</p>
<p>封装类型:Boolean、Character、Byte、Short、Integer、Long、Float、Double</p>
<p>装箱和拆箱其实是一种语法糖，是Java在编译期自动完成的，并不需要程序员做什么额外的工作。<strong>从代码上来讲就是调用valueOf方法。</strong></p>
<p>（1）基本数值—-&gt;包装对象</p>
<p>​    就是<strong>包装对象.valueOf(基本数值);</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer iii = Integer.valueOf(<span class="number">4</span>);<span class="comment">//使用包装类中的valueOf方法</span></span><br></pre></td></tr></table></figure>

<p>（2）包装对象—-&gt;基本数值</p>
<p>​    基本数值 = 包装对象实例.基本数值Value();</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = i.intValue();</span><br></pre></td></tr></table></figure>

<h3 id="4-foreach"><a href="#4-foreach" class="headerlink" title="4. foreach"></a>4. foreach</h3><p>​    其实我们经常使用的foreach，其实也是一种语法糖。他编译后，<strong>底层是用迭代器来实现的。（集合只能通过迭代器实现遍历）</strong>例如下面这个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : list)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForDemo</span> </span>&#123;</span><br><span class="line">  ForDemo() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    list.add(<span class="number">4</span>);</span><br><span class="line">    Iterator var2 = list.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">      <span class="keyword">int</span> i = (Integer)var2.next();</span><br><span class="line">      System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-equels与"><a href="#5-equels与" class="headerlink" title="5. equels与=="></a>5. equels与==</h3><p>​    ==<strong>基本变量比较的是值</strong>，而<strong>引用比较的是地址</strong>是否相等</p>
<p>​    equels只能比较引用，默认和==一样比较地址，<strong>但一般都会重写来比较引用对象的内容是否相等。</strong></p>
<h2 id="六、反射"><a href="#六、反射" class="headerlink" title="六、反射"></a>六、反射</h2><h3 id="1-过程"><a href="#1-过程" class="headerlink" title="1. 过程"></a>1. 过程</h3><p>​    类加载过程：当编译一个新类时，会产生一个同名的<code>.class</code>文件，该字节码类加载进入内存生成对应的 Class 对象。类在第一次使用时才动态加载到 JVM 中。</p>
<p>​    而反射是在<strong>编译时不确定那个类被加载</strong>了，而是在<strong>运行时才加载类信息。</strong></p>
<p>​    使用 1.`Class.forName(全限定类名) 2. 类名.class 3. 实例对象.getClass()。 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p>
<h3 id="2-常用API"><a href="#2-常用API" class="headerlink" title="2. 常用API"></a>2. 常用API</h3><p>​    Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p>
<ul>
<li><strong>Field</strong> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li>
<li><strong>Method</strong> ：可以使用 <strong>invoke() 方法调用与 Method 对象关联的方法</strong>；</li>
<li><strong>Constructor</strong> ：可以用 Constructor 的 <strong>newInstance()</strong> 创建新的对象。</li>
</ul>
<h3 id="3-平时使用用途"><a href="#3-平时使用用途" class="headerlink" title="3. 平时使用用途"></a>3. 平时使用用途</h3><p>​    <strong>反射最重要的用途就是开发各种通用框架</strong>，很多框架其实都是配置化（例如：Spring 通过XML文件来配置Bean）的，所以为了保证框架的通用性，<strong>它们可能需要根据配置文件来加载不同的对象和类，调用不同的方法，这时候就需要用到反射，运行时动态加载需要的对象。</strong></p>
<p>​    比如我们发请求 <code>/login</code>，那么后端就会去解析XML配置文件，<strong>检索对应映射Map中name为login，创建对应的Servlet实例，并用invoke方法来调用被代理对象的方法，这个过程离不开反射。</strong></p>
<h3 id="4-动态代理"><a href="#4-动态代理" class="headerlink" title="4. 动态代理"></a>4. 动态代理</h3><ul>
<li>JDK动态代理：利用<strong>反射机制</strong>生成一个实现代理接口的匿名类，在调用具体方法前<strong>调用InvokeHandler来处理</strong>。</li>
</ul>
<figure class="highlight plain"><figcaption><span>targetObject.getClass().getInterfaces(), new InvokeHandler);```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">​	**InvokeHandler必须实现InvocationHandler**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">public class ProxyHandle implements InvocationHandler &#123;</span><br><span class="line">    &#x2F;&#x2F; invoke方法</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        &#x2F;*-------------------------------*&#x2F;</span><br><span class="line">        &#x2F;&#x2F; 调用invoke方法</span><br><span class="line">        ret &#x3D; method.invoke(targetObject, args);</span><br><span class="line">        return ret;</span><br><span class="line">        &#x2F;*-------------------------------*&#x2F;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>特点：JDK动态代理机制是委托机制，具体说动态实现接口类，在动态生成的实现类里面委托hanlder去调用原始实现类方法，代理类跟被代理类必须实现一样的接口，属于平级关系</strong></p>
<ul>
<li><strong>CGlib动态代理</strong>：通过将代理对象类的class文件加载进来，<strong>通过修改其字节码生成子类来处理。被代理类和代理类是继承关系，所以代理类是可以赋值给被代理类的。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">createProxyObject</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.targetObject = obj;</span><br><span class="line">    <span class="comment">// setSuperclass通过修改字节码来进行赋值给被代理类</span></span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    enhancer.setSuperclass(obj.getClass());</span><br><span class="line">    enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// proxyObj是代理对象</span></span><br><span class="line">    Object proxyObj = enhancer.create();</span><br><span class="line">    <span class="keyword">return</span> proxyObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    实现MethodInterceptor接口生成方法拦截器，通过<strong>拦截器来拦截方法，进行动态代理逻辑。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 拦截方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"addUser"</span>.equals(method.getName())) &#123;</span><br><span class="line">        <span class="comment">// 检查权限</span></span><br><span class="line">        checkPopedom();</span><br><span class="line">    &#125;</span><br><span class="line">    Object obj = method.invoke(targetObject, args);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-两种动态代理区别"><a href="#5-两种动态代理区别" class="headerlink" title="5. 两种动态代理区别"></a>5. 两种动态代理区别</h3><p>​    动态代理指的是，客户通过代理类来调用其他对象的方法，是在<strong>程序运行时</strong>根据需求动态创建目标类的代理对象。</p>
<p>区别：</p>
<ol>
<li><strong>JDK代理使用的是反射机制，CGLIB使用的继承机制，通过修改字节码生成子类，代理类是可以赋值给被代理类的</strong>。</li>
<li><strong>JDK动态代理的方式创建代理对象效率较高，执行效率较低，而cglib创建效率较低，执行效率高。</strong></li>
</ol>
<h2 id="七、注解"><a href="#七、注解" class="headerlink" title="七、注解"></a>七、注解</h2><p>​    Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，<strong>起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</strong></p>
<h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h3><p>​    注解的本质实际是一个<strong>继承了Annotation的特殊接口</strong>，其具体的实现类是Java运行时生成的动态代理类，而我们可以通过反射来获取注解，返回代理对象proxy1，<strong>通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler 的invoke 方法</strong>。该方法会从<strong>memberValues 这个Map 中索引出对应的值。而memberValues 的来源是Java 常量池。</strong></p>
<h3 id="2-元注解"><a href="#2-元注解" class="headerlink" title="2.元注解"></a>2.元注解</h3><p>@Documented – 注解是否将包含在JavaDoc中<br>@Retention – 定义该注解的生命周期</p>
<p> ●  RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在<strong>编译结束之后</strong>就不再有任何意义，所以<strong>它们不会写入字节码</strong>。<strong>@Override</strong>, @SuppressWarnings都属于这类注解。<br> ●  RetentionPolicy.CLASS : <strong>在类加载的时候丢弃。</strong>在字节码文件的处理中有用。注解<strong>默认</strong>使用这种方式<br> ●  RetentionPolicy.RUNTIME : 始终不会丢弃，<strong>运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。</strong></p>
<p>@Target – 注解用于什么地方<br>@Inherited – 是否允许子类继承该注解</p>
<h3 id="3-自定义注解"><a href="#3-自定义注解" class="headerlink" title="3. 自定义注解"></a>3. 自定义注解</h3><p>​    自定义注解类编写的一些规则:</p>
<ol>
<li><p>Annotation 型<strong>定义为@interface, 所有的Annotation 会自动继承java.lang.Annotation这一接口</strong>,并且不能再去继承别的类或是接口.</p>
</li>
<li><p>参数成员只能用public 或默认(default) 这两个访问权修饰</p>
</li>
<li><p>参数成员只能用基本类型byte、short、char、int、long、float、double、boolean八种基本数据类型和String、Enum、Class、annotations等数据类型，以及这一些类型的数组.</p>
</li>
<li><p>要获<strong>取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation 对象</strong>，因为你除此之外也没有别的获取注解对象的方法</p>
</li>
<li><p>注解也可以没有定义成员,，不过这样注解就没啥用了</p>
<p>PS:自定义注解需要使用到元注解</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME) <span class="comment">// 生命周期</span></span><br><span class="line"><span class="meta">@Documented</span> <span class="comment">// 注解标明</span></span><br><span class="line"><span class="comment">// 类型为@interface</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FruitName &#123;</span><br><span class="line">     <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------------------------注解反射获取举例-------------------------------------*/</span></span><br><span class="line"><span class="comment">// field.getAnnotation(FruitName.class);</span></span><br><span class="line">Field[] fields = clazz.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span>(Field field :fields)&#123;</span><br><span class="line">    <span class="keyword">if</span>(field.isAnnotationPresent(FruitName<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">        FruitName fruitName = (FruitName) field.getAnnotation(FruitName<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        strFruitName=strFruitName+fruitName.value();</span><br><span class="line">        System.out.println(strFruitName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、I-O"><a href="#八、I-O" class="headerlink" title="八、I/O"></a>八、I/O</h2><h3 id="1-I-O-分类"><a href="#1-I-O-分类" class="headerlink" title="1. I/O 分类"></a>1. I/O 分类</h3><ul>
<li>磁盘操作：File</li>
<li>字节操作：InputStream 和 OutputStream</li>
<li>字符操作：Reader 和 Writer</li>
<li>对象操作：Serializable</li>
<li>网络操作：Socket</li>
<li>非阻塞的输入/输出：NIO</li>
</ul>
<p>Java I/O 使用了装饰者模式来实现。 InputStream 为例，</p>
<ul>
<li>InputStream 是抽象组件；</li>
<li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；</li>
<li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，<strong>为组件提供额外的功能</strong>。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(fileInputStream);</span><br></pre></td></tr></table></figure>

<h3 id="2-对象流"><a href="#2-对象流" class="headerlink" title="2. 对象流"></a>2. 对象流</h3><h4 id="2-1-序列化"><a href="#2-1-序列化" class="headerlink" title="2.1 序列化"></a>2.1 序列化</h4><p>序列化就是将一个对象转换成字节序列，方便存储和传输。</p>
<ul>
<li><p>序列化：ObjectOutputStream.writeObject()</p>
</li>
<li><p>反序列化：ObjectInputStream.readObject()</p>
<p>不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。</p>
</li>
</ul>
<h4 id="2-2-Serializable"><a href="#2-2-Serializable" class="headerlink" title="2.2 Serializable"></a>2.2 Serializable</h4><p>​    序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> String y;</span><br><span class="line"></span><br><span class="line">    A(<span class="keyword">int</span> x, String y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x = "</span> + x + <span class="string">"  "</span> + <span class="string">"y = "</span> + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-transient"><a href="#2-3-transient" class="headerlink" title="2.3 transient"></a>2.3 transient</h4><p>​    transient 关键字可以使一些属性不会被序列化。</p>
<p>​    ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>

<h3 id="3-NIO"><a href="#3-NIO" class="headerlink" title="3. NIO"></a>3. NIO</h3><h4 id="3-1-IO模型"><a href="#3-1-IO模型" class="headerlink" title="3.1 IO模型"></a>3.1 IO模型</h4><p>​    IO模型就是用<strong>什么样的通道进行数据的发送和接收</strong>，很大程度上决定了程序<strong>通信的性能。</strong></p>
<p>​    Java共支持3种网络编程模型/IO模式：BIO、NIO、AIO</p>
<p>​    1) Java BIO ： 同步阻塞IO(<strong>传统阻塞型</strong>)，服务器实现模式为一个连接一个线程，即<strong>客户端有连接请求时服务器端就需要启动一个线程进行处理</strong>，如果这个连接不执行会造成不必要的线程开销。</p>
<p><img src="https://img-blog.csdnimg.cn/20200908202509786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​    <strong>BIO编程简单流程</strong></p>
<ol>
<li><p>服务器端启动一个ServerSocket</p>
</li>
<li><p><strong>客户端启动Socket对服务器进行通信</strong>，默认情况下服务器端需要对每个客户 建立一个线程与之通讯</p>
</li>
<li><p>客户端<strong>发出请求后, 先咨询服务器是否有线程响应，如果没有则会等待（阻塞），或者被拒绝</strong></p>
</li>
<li><p>如果有响应，客户端线程会等待请求结束后，在继续执行（同步）。</p>
</li>
</ol>
<p>   2) Java NIO ： <strong>同步非阻塞</strong>，NIO是多路复用的，在内核设立了<strong>专门的线程selector去轮询访问所有的socket</strong>，而不需要具体操作的线程阻塞等待</p>
<p>​    NIO是 面向<strong>缓冲区。数据读取到一个它稍后处理的缓冲区，</strong>需要时可在缓冲区中前后移动<strong>，这就增加了处理过程中的灵活性，使用它可以提供</strong>非阻塞式的高伸缩性网络。HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</p>
<p>​    <strong>BIO和NIO的比较：</strong></p>
<ol>
<li><p>效率：BIO 以流的方式处理数据,而 NIO 以块的方式处理数据,<strong>块 I/O 的效率比流 I/O 高很多</strong></p>
</li>
<li><p>阻塞：BIO 是阻塞的，NIO 则是非阻塞的</p>
</li>
<li><p>BIO基于字节流和字符流进行操作，而 <strong>NIO 基于 Channel(通道)和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。</strong>Selector(选择器)用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用<strong>单个线程就可以监听多个客户端</strong>通道 </p>
</li>
</ol>
<p>   3) Java AIO(NIO.2 了解即可) ： <strong>异步非阻塞</strong>，AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</p>
<h4 id="3-2-BIO、NIO、AIO适用场景"><a href="#3-2-BIO、NIO、AIO适用场景" class="headerlink" title="3.2 BIO、NIO、AIO适用场景"></a>3.2 BIO、NIO、AIO适用场景</h4><p><img src="https://img-blog.csdnimg.cn/20200909193654510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​    1)BIO方式适用于<strong>连接数目比较小且固定</strong>的架构，这种方式<strong>当并发数较大时，需要创建大量线程来处理连接，</strong>系统资源占用较大，且线程会阻塞，造成线程资源的浪费，JDK1.4以前的唯一选择，但程序简单易理解。</p>
<p>​    2)NIO方式适用于<strong>连接数目多且连接比较短</strong>（轻操作）的架构，比如<strong>聊天服务器</strong>，弹幕系统，<strong>服务器间通讯</strong>等。编程比较复杂，JDK1.4开始支持。</p>
<p>​    3)AIO方式使用于<strong>连接数目多且连接比较长</strong>（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p>
<h4 id="3-3-NIO三大核心组件"><a href="#3-3-NIO三大核心组件" class="headerlink" title="3.3 NIO三大核心组件"></a>3.3 NIO三大核心组件</h4><p>​    NIO 有三大核心部分：<strong>Channel(通道)</strong>，<strong>Buffer(缓冲区)</strong>, <strong>Selector(选择器)</strong> </p>
<p><img src="https://img-blog.csdnimg.cn/20200908202539104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​    关系图解读：</p>
<p>1)每个channel 都会对应一个Buffer</p>
<p>2)Selector 对应一个线程， <strong>一个线程对应多个channel(连接)</strong></p>
<p>3)该图反应了有三个<strong>channel 注册到 该selector</strong> //程序</p>
<p>4)程序切换到哪个channel 是有<strong>事件决定</strong>的, Event 就是一个重要的概念</p>
<p>5)Selector 会根据不同的事件，在各个通道上切换</p>
<p>6)Buffer 就是一个内存块 ， 底层是有一个数组</p>
<p>7)<strong>数据的读取写入是通过Buffer, 这个和BIO , BIO 中要么是输入流，或者是输出流, 不能双向，但是NIO的Buffer 是可以读也可以写, 需要 flip 方法切换</strong></p>
<p>8)<strong>channel 是双向的</strong>, 可以返回底层操作系统的情况, 比如Linux ， 底层的操作系统通道就是双向的</p>
<h4 id="3-4-缓冲区Buffer"><a href="#3-4-缓冲区Buffer" class="headerlink" title="3.4 缓冲区Buffer"></a>3.4 缓冲区Buffer</h4><p>​    缓存的本质就是一个<strong>可以读写的数据块（底层是个数组）</strong>，有ByteBuffer，ShortBuffer，CharBuffer，IntBuffer，LongBuffer，DoubleBuffer，FloatBuffer类型对具体的数据类型进行读写，提高了速率。</p>
<p>​    Channel读取和写入数据必须经过Buffer，<strong>避免了阻塞</strong>，因为Buffer中的数据达到一个规模时才会通过Channel进行读写。</p>
<p><img src="https://img-blog.csdnimg.cn/20200909111052285.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="3-5-通道Channel"><a href="#3-5-通道Channel" class="headerlink" title="3.5 通道Channel"></a>3.5 通道Channel</h4><p>​    Channel通道类似于流，但有些区别，并且NIO 还支持 通过多个Buffer (即 Buffer 数组) 完成读写操作。</p>
<ul>
<li><p><strong>通道是双向的，可以同时进行读写，而流只能读或者只能写</strong></p>
</li>
<li><p><strong>通道可以从缓冲读数据，也可以写数据到缓冲:</strong> </p>
</li>
<li><p>通道可以实现异步读写数据</p>
<p>常见的API：<strong>读写都是针对缓冲区（内存）而言，它进行读写</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>)read(ByteBuffer dst) ，<span class="comment">// 从通道读取数据并放到缓冲区中</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="comment">// 把缓冲区的数据写到通道中</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">3)<span class="keyword">public</span> <span class="keyword">long</span> <span class="title">transferFrom</span><span class="params">(ReadableByteChannel src, <span class="keyword">long</span> position, <span class="keyword">long</span> count)</span><span class="comment">// 从目标通道中复制数据到当前通道</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">4)<span class="keyword">public</span> <span class="keyword">long</span> <span class="title">transferTo</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> count, WritableByteChannel target)</span><span class="comment">// 把数据从当前通道复制给目标通道</span></span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3-6-选择器Selector"><a href="#3-6-选择器Selector" class="headerlink" title="3.6 选择器Selector"></a>3.6 选择器Selector</h4><p>​    NIO使用一个线程，来处理多个客户端Channel请求（提高了并发度），就会用到Selector选择器（又叫多路复用器），<strong>多个Channel以事件的方式可以注册到同一个Selector，Selector能够检测多个注册的通道中是否有事件发生。</strong></p>
<p>​    只有在轮询了注册Channel真正有读写事件发生时，才会进行读写，没有数据可用的话，该线程就会进行其他任务，就大大地减少了系统开销，<strong>不用去维护多线程，避免了多线程之间的上下文切换导致的开销。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200909111757652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="3-7-NIO网络编程"><a href="#3-7-NIO网络编程" class="headerlink" title="3.7 NIO网络编程"></a>3.7 NIO网络编程</h4><p>​    Selector、SelectionKey、ServerScoketChannel和SocketChannel关系图：</p>
<p><strong>注意：（1）NIO中的 ServerSocketChannel功能类似ServerSocket，SocketChannel功能类似Socket</strong><br>           <strong>（2）且ServerSocketChannel和SocketChannel都是注册到Selector上</strong></p>
<p><img src="https://img-blog.csdnimg.cn/2020090911292743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol>
<li><p>当客户端连接时，会通过ServerSocketChannel 得到 SocketChannel</p>
</li>
<li><p>Selector 进行监听 select 方法, 返回有事件发生的通道的个数</p>
</li>
<li><p>将<strong>SocketChannel注册到Selector上</strong>, register(Selector sel, <strong>int</strong> ops), 一个selector上可以注册多个SocketChannel</p>
</li>
<li><p><strong>注册后返回一个 SelectionKey, 会和该Selector关联(存进一个Set集合)，可以同SelectionKey来反向获取通道SocketChannel</strong></p>
</li>
<li><p>还可以得到各个 SelectionKey (有事件发生)</p>
</li>
<li><p>可以通过得到的 channel  , 完成业务处理</p>
</li>
</ol>
<h5 id="3-7-1-SelectionKey"><a href="#3-7-1-SelectionKey" class="headerlink" title="3.7.1 SelectionKey"></a>3.7.1 SelectionKey</h5><p>​    SelectionKey，表示 Selector 和Channel的注册关系，因为是<strong>SocketChannel注册后返回的</strong>对应值。</p>
<p>常见API：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Selector <span class="title">selector</span><span class="params">()</span></span>; <span class="comment">//得到与之关联的 Selector 对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectableChannel <span class="title">channel</span><span class="params">()</span></span>; <span class="comment">//得到与之关联的通道</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">attachment</span><span class="params">()</span></span>; <span class="comment">//得到与之关联的共享数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectionKey <span class="title">interestOps</span><span class="params">(<span class="keyword">int</span> ops)</span></span>; <span class="comment">//设置或改变监听事件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isAcceptable</span><span class="params">()</span></span>; <span class="comment">//是否可以 accept</span></span><br></pre></td></tr></table></figure>

<h5 id="3-7-2-ServerSocketChannel"><a href="#3-7-2-ServerSocketChannel" class="headerlink" title="3.7.2 ServerSocketChannel"></a>3.7.2 ServerSocketChannel</h5><p>​    ServerSocketChannel，在<strong>服务器端监听新的客户端Socket通道连接。</strong>还可以<strong>注册一个选择器Selector</strong>并设置监听事件，register(Selector sel, int ops) 。</p>
<p>常见API:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">open</span><span class="params">()</span> <span class="comment">//得到一个 ServerSocketChannel 通道</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ServerSocketChannel <span class="title">bind</span><span class="params">(SocketAddress local)</span> <span class="comment">//设置服务器端端口号</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span> <span class="comment">//设置阻塞或非阻塞模式，取值 false 表示采用非阻塞模式</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SocketChannel <span class="title">accept</span><span class="params">()</span> <span class="comment">//接受一个连接，返回代表这个连接的通道对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops)</span> <span class="comment">//注册到选择器并设置监听事件</span></span></span><br></pre></td></tr></table></figure>

<h5 id="3-7-3-SocketChannel通道"><a href="#3-7-3-SocketChannel通道" class="headerlink" title="3.7.3 SocketChannel通道"></a>3.7.3 SocketChannel通道</h5><p>​    SocketChannel，网络 IO 通道，<strong>具体负责进行读写操作</strong>。NIO 把<strong>缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</strong></p>
<p>常见API:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span><span class="params">()</span></span>; <span class="comment">//得到一个 SocketChannel 通道</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span></span>; <span class="comment">//设置阻塞或非阻塞模式，取值 false 表示采用非阻塞模式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connect</span><span class="params">(SocketAddress remote)</span></span>; <span class="comment">//连接服务器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">finishConnect</span><span class="params">()</span></span>; <span class="comment">//如果上面的方法连接失败，接下来就要通过该方法完成连接操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span></span>; <span class="comment">//将缓冲区中数据往通道里写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span></span>; <span class="comment">//从通道里读数据到缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops, Object att)</span></span>; <span class="comment">//注册到选择器并设置监听事件，最后一个参数可以设置共享数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>; <span class="comment">//关闭通道</span></span><br></pre></td></tr></table></figure>

<h4 id="3-8-零拷贝"><a href="#3-8-零拷贝" class="headerlink" title="3.8 零拷贝"></a>3.8 零拷贝</h4><p>​    在 Java 程序中，常用的零拷贝有 <strong>mmap(内存映射)</strong> 和 <strong>sendFile</strong>。</p>
<p><strong>注意：零拷贝是指没有CPU拷贝。</strong></p>
<p>​    在传统的IO和网络编程操作中，要拷贝文件，必然会经过如下过程：（DMA直接内存拷贝不使用CPU）</p>
<p><img src="https://img-blog.csdnimg.cn/20200909132440952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​    需要要文件系统（硬件）到网络协议栈，即需要经过<strong>一次DMA拷贝从硬件驱动到内核缓冲，然后再从内核缓冲经过两次CPU拷贝到用户缓冲、socket buffer，最后再DMA拷贝到协议栈</strong>传输。</p>
<p>​    需要进行<strong>四次上下文切换</strong>，即内核态到用户态的切换。</p>
<h5 id="3-8-1-mmap优化"><a href="#3-8-1-mmap优化" class="headerlink" title="3.8.1 mmap优化"></a>3.8.1 mmap优化</h5><p>​    mmap即内存映射，将<strong>文件映射到内核缓冲区</strong>，同时 <strong>用户缓冲和 内核缓冲可以共享数据</strong>。这样进行网络传输<strong>减少拷贝次数。</strong></p>
<p>​    内核缓冲可以直接拷贝到socket 缓冲中，减少拷贝次数。</p>
<p><img src="https://img-blog.csdnimg.cn/20200909192707379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="3-8-2-sendfile优化"><a href="#3-8-2-sendfile优化" class="headerlink" title="3.8.2 sendfile优化"></a>3.8.2 sendfile优化</h5><p>​    数据根本不经过用户态，直接从<strong>内核缓冲区进入到 Socket Buffer</strong>，同时，由于和用户态完全无关，不仅减少拷贝的次数，还<strong>减少了一次上下文切换。</strong></p>
<p>​    注意：这里其实有 一次cpu 拷贝 kernel buffer -&gt; socket buffer但是，拷贝的信息很少，比如lenght , offset , 消耗低，可以忽略。</p>
<p><img src="https://img-blog.csdnimg.cn/20200909192853957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="3-8-3-mmap-和-sendFile-的区别"><a href="#3-8-3-mmap-和-sendFile-的区别" class="headerlink" title="3.8.3 mmap 和 sendFile 的区别"></a>3.8.3 mmap 和 sendFile 的区别</h5><ol>
<li><p>mmap 需要 4 次上下文切换，3 次数据拷贝，即<strong>硬件到内核缓冲，到socket缓冲，到协议栈。</strong></p>
<p>sendFile 需要 3 次上下文切换，最少 2 次数据拷贝，即<strong>硬件到内核缓冲，（内核缓冲到socket buffer，socket buffer 到协议栈）内核缓冲到协议栈。</strong></p>
</li>
<li><p>sendFile 可以利用 DMA 方式，减少 CPU 拷贝，mmap 则不能<strong>（必须从内核拷贝到 Socket 缓冲区）</strong>。</p>
</li>
<li><p>mmap 适合小数据量读写，sendFile 适合大文件传输。</p>
</li>
</ol>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="1-序列化"><a href="#1-序列化" class="headerlink" title="1. 序列化"></a>1. 序列化</h3><p>​    序列化：内存中的数据对象只有转换为<strong>二进制流</strong>的形式，才能进行网络间的进程传输，以及数据的持久化。</p>
<p>序列化方式：</p>
<ol>
<li>Java原生的序列化，实现了Serializable接口（标识作用），需要显示的<strong>创建SerialVersionUID（根据类的内部实现，类名，方法名，属性等生成）</strong>，如果不设置则自动生成，这就会使代码修改后，同一个类取值不同</li>
<li>Json序列化：数据对象转换成Json的类型，不需要提供类型信息，所以反序列化时就需要提供类型信息（xxx.class）</li>
</ol>
<p><strong>注意：类中的字段如若为敏感的信息，不需要序列化，加transient避免序列化。</strong></p>
<p><strong>静态变量也不能序列化，反序列化后可以得到结果是因为其从jvm中获得的，而不是反序列化的结果。</strong></p>
<h3 id="2-JDK与JRE"><a href="#2-JDK与JRE" class="headerlink" title="2. JDK与JRE"></a>2. JDK与JRE</h3><p>​    JDK = JRE（运行环境）+ 工具</p>
<ul>
<li>JRE：Java Runtime Environment，<strong>Java 运行环境的简称</strong>，为 Java 的运行提供了所需的环境。它是一个 JVM 程序，主要包括了 JVM 的标准实现和一些 Java 基本类库。</li>
<li>JDK：Java Development Kit，<strong>Java 开发工具包，提供了 Java 的开发及运行环境</strong>。JDK 是 Java 开发的核心，集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac 等。</li>
</ul>
<h3 id="3-java8新特性"><a href="#3-java8新特性" class="headerlink" title="3. java8新特性"></a>3. java8新特性</h3><p>Lambda表达式和Functional接口：Lambda表达式可以允许把函数作为参数传参可以用（类型 参数）-&gt;{方法体}替代以前的匿名内部类，方法体中可以调用参数与成员变量和局部变量（隐式转换为final），一般使用参数数组结合forEach或sort等方法时使用，传参也可以不指定类型，参数类型和返回值类型是编译器推测出来的。Functional接口使用@FunctionalInterface注解修饰接口，使得这样的接口可以被隐式转换为lambda表达式。</p>
<p>default修饰符修饰接口中的方法，可以为接口中的方法写默认实现，实现类可以自己决定是否覆盖这个方法</p>
<p>方法引用：直接引用已有Java类或对象（实例）的方法（Class名::method）或构造器（Class名::new）。与lambda联合使用<br>重复注解</p>
<p>Stream ，函数式编程风格，集合的批处理和流式操作，搭配lambda 表达式进行去重（distinct ）、分类（Collectors.groupingBy）、过滤（filter），加和，最大最小等函数操作。</p>
<p>新的Date-Time API ：Clock，LocaleDate与LocalTime<br>jdk1.8中JVM的新特性：抛弃了永久代，数据转移到堆中，引入元空间，元空间作用与永久代类似，都是方法区的实现，元空间不在虚拟机中，而是在本地内存下，字符串不存在元空间，存在字符串常量池里面。</p>
<h3 id="4-深浅拷贝"><a href="#4-深浅拷贝" class="headerlink" title="4. 深浅拷贝"></a>4. 深浅拷贝</h3><p>浅拷贝中二者的属性中的<strong>同一个对象引用指向的是同一个区域</strong>，只拷贝了地址引用，clone方法默认为浅拷贝。</p>
<p>而<strong>深拷贝会把对象引用对应的实际内容在堆中再建一份</strong>，并指向，所以深拷贝时，基本数据类型，和对象引用全部不是一样的。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">rnang0</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://rnang0.github.io/2020/05/26/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A01%EF%BC%9AJava%E5%9F%BA%E7%A1%80/">http://rnang0.github.io/2020/05/26/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A01%EF%BC%9AJava%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://rnang0.github.io" target="_blank">rnang0 Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</a><a class="post-meta__tags" href="/tags/String/">String</a><a class="post-meta__tags" href="/tags/%E5%8F%8D%E5%B0%84/">反射</a><a class="post-meta__tags" href="/tags/%E5%BC%82%E5%B8%B8/">异常</a><a class="post-meta__tags" href="/tags/I-O/">I/O</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/rnang0/blogimage/raw/master/20210512182016.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/06/09/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A02%EF%BC%9AJava%E9%9B%86%E5%90%88%E7%B1%BB%EF%BC%88%E4%B8%8A%EF%BC%89/"><img class="prev_cover" src="https://img-blog.csdnimg.cn/20191126222856847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NvdWdvdV8xMzIz,size_16,color_FFFFFF,t_70" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">春招复习2：Java集合类（上）</div></div></a></div><div class="next-post pull_right"><a href="/2019/12/26/Mybatis%E7%9A%84Mapper%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"><img class="next_cover" src="https://img-blog.csdnimg.cn/20200727121420246.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Mybatis中Mapper的实现原理</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By rnang0</div><div class="footer_custom_text">Hi, welcome to my <a href="http://rnang0.github.io/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script></body></html>