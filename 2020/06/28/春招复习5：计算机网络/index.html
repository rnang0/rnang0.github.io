<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>春招复习5：计算机网络 | rnang0 Blog</title><meta name="description" content="计算机网络重点学习内容 应用层 WEB应用 Http连接类型 Http消息格式 Cookie技术 WEB缓存技术     传输层 UDP 可靠信道 滑动窗口协议   TCP TCP超时重传机制 流量控制 三次握手四次挥手 拥塞控制 TCP拥塞控制原理      一、 计算机网络体系结构   1. OSI 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 表"><meta name="keywords" content="计算机网络,TCP/IP,HTTP/HTTPS"><meta name="author" content="rnang0"><meta name="copyright" content="rnang0"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="春招复习5：计算机网络"><meta name="twitter:description" content="计算机网络重点学习内容 应用层 WEB应用 Http连接类型 Http消息格式 Cookie技术 WEB缓存技术     传输层 UDP 可靠信道 滑动窗口协议   TCP TCP超时重传机制 流量控制 三次握手四次挥手 拥塞控制 TCP拥塞控制原理      一、 计算机网络体系结构   1. OSI 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 表"><meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200701112110271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70"><meta property="og:type" content="article"><meta property="og:title" content="春招复习5：计算机网络"><meta property="og:url" content="http://yoursite.com/2020/06/28/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A05%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><meta property="og:site_name" content="rnang0 Blog"><meta property="og:description" content="计算机网络重点学习内容 应用层 WEB应用 Http连接类型 Http消息格式 Cookie技术 WEB缓存技术     传输层 UDP 可靠信道 滑动窗口协议   TCP TCP超时重传机制 流量控制 三次握手四次挥手 拥塞控制 TCP拥塞控制原理      一、 计算机网络体系结构   1. OSI 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 表"><meta property="og:image" content="https://img-blog.csdnimg.cn/20200701112110271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70"><meta property="article:published_time" content="2020-06-27T16:00:00.000Z"><meta property="article:modified_time" content="2020-07-13T13:00:26.950Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="canonical" href="http://yoursite.com/2020/06/28/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A05%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><link rel="next" title="春招复习4：操作系统" href="http://yoursite.com/2020/06/23/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A04%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'none',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/autor.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">62</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">87</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-mars"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#计算机网络"><span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#重点学习内容"><span class="toc-text">重点学习内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一、-计算机网络体系结构"><span class="toc-text">一、 计算机网络体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-OSI"><span class="toc-text">1. OSI</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-TCP-IP"><span class="toc-text">2. TCP&#x2F;IP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-五层协议"><span class="toc-text">3. 五层协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-数据在各层之间的传递过程"><span class="toc-text">4. 数据在各层之间的传递过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、应用层"><span class="toc-text">*二、应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-域名系统"><span class="toc-text">2.1 域名系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-常用端口"><span class="toc-text">2.2 常用端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-WEB应用（重点）"><span class="toc-text">*2.3 WEB应用（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-Http连接类型"><span class="toc-text">2.3.1 Http连接类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-Http消息格式"><span class="toc-text">2.3.2 Http消息格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-HTTP-请求页面"><span class="toc-text">2.3.3 HTTP 请求页面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-Cookie技术"><span class="toc-text">2.3.4 Cookie技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-5-WEB缓存技术"><span class="toc-text">2.3.5 WEB缓存技术</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、传输层"><span class="toc-text">*三、传输层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-UDP"><span class="toc-text">3.1 UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-可靠信道"><span class="toc-text">3.1.1 可靠信道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-滑动窗口协议"><span class="toc-text">3.1.2 滑动窗口协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-TCP"><span class="toc-text">3.3 TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1TCP超时重传机制"><span class="toc-text">3.2.1TCP超时重传机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2流量控制"><span class="toc-text">3.2.2流量控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-三次握手四次挥手"><span class="toc-text">3.2.3 三次握手四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-拥塞控制"><span class="toc-text">3.2.4 拥塞控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-TCP拥塞控制原理"><span class="toc-text">3.2.5 TCP拥塞控制原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、面试问题（重重重重点！！！！）"><span class="toc-text">**四、面试问题（重重重重点！！！！）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-各层的结构与功能-都有哪些协议"><span class="toc-text">4.1 各层的结构与功能,都有哪些协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-TCP三次握手与四次挥手（面试常客）"><span class="toc-text">4.2 TCP三次握手与四次挥手（面试常客）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-为什么要三次握手"><span class="toc-text">4.2.1 为什么要三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-为什么要四次挥手"><span class="toc-text">4.2.2 为什么要四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-拓展"><span class="toc-text">4.2.3 拓展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-TCP-UDP-协议的区别"><span class="toc-text">4.3 TCP,UDP 协议的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-在浏览器中输入url地址-gt-gt-显示主页的过程-面试常客"><span class="toc-text">4.4 在浏览器中输入url地址 -&gt;&gt; 显示主页的过程(面试常客)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-HTTP长连接-短连接"><span class="toc-text">4.5 HTTP长连接,短连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-HTTP是不保存状态的协议-如何保存用户状态"><span class="toc-text">4.6 HTTP是不保存状态的协议,如何保存用户状态?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-HTTP-1-0和1-1的主要区别"><span class="toc-text">4.7 HTTP 1.0和1.1的主要区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-URI和URL的区别是什么"><span class="toc-text">4.8 URI和URL的区别是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-HTTP-和-HTTPS-的区别？"><span class="toc-text">4.9 HTTP 和 HTTPS 的区别？</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://img-blog.csdnimg.cn/20200701112110271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">rnang0 Blog</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-mars"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">春招复习5：计算机网络</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-28 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-06-28</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-13 21:00:26"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-07-13</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/">春招复习</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="重点学习内容"><a href="#重点学习内容" class="headerlink" title="重点学习内容"></a>重点学习内容</h2><ul>
<li>应用层<ul>
<li>WEB应用<ul>
<li>Http连接类型</li>
<li>Http消息格式</li>
<li>Cookie技术</li>
<li>WEB缓存技术</li>
</ul>
</li>
</ul>
</li>
<li>传输层<ul>
<li>UDP<ul>
<li>可靠信道</li>
<li>滑动窗口协议</li>
</ul>
</li>
<li>TCP<ul>
<li>TCP超时重传机制</li>
<li>流量控制</li>
<li>三次握手四次挥手</li>
<li>拥塞控制</li>
<li>TCP拥塞控制原理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="一、-计算机网络体系结构"><a href="#一、-计算机网络体系结构" class="headerlink" title="一、 计算机网络体系结构"></a>一、 计算机网络体系结构</h2><img src="https://img-blog.csdnimg.cn/20200712211200104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="img"  />


<h4 id="1-OSI"><a href="#1-OSI" class="headerlink" title="1. OSI"></a>1. OSI</h4><ul>
<li><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</li>
<li><strong>表示层</strong> ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li>
<li><strong>会话层</strong> ：建立及管理会话。</li>
<li><strong>传输层</strong> ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li>
<li><strong>网络层</strong> ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li>
<li><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li>
<li><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li>
</ul>
<h4 id="2-TCP-IP"><a href="#2-TCP-IP" class="headerlink" title="2. TCP/IP"></a>2. TCP/IP</h4><p>它只有四层，相当于数据链路层和物理层合并为网络接口层。</p>
<p>TCP/IP 体系结构不严格遵循 OSI 分层概念，<strong>应用层可能会直接使用 IP 层或者网络接口层。</strong></p>
<h4 id="3-五层协议"><a href="#3-五层协议" class="headerlink" title="3. 五层协议"></a>3. 五层协议</h4><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p>
<ul>
<li><strong>应用层</strong> ：为<strong>特定应用程序提供数据传输服务</strong>，例如 HTTP、DNS 等协议。数据单位为报文。</li>
<li><strong>传输层</strong> ：为进程提供<strong>通用数据传输</strong>服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li>
<li><strong>网络层</strong> ：<strong>为主机提供数据传输服务</strong>。而传输层协议是为主机中的进程提供数据传输服务。<strong>网络层把传输层传递下来的报文段或者用户数据报封装成分组。</strong></li>
<li><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li>
<li><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li>
</ul>
<p>[<img src="https://img-blog.csdnimg.cn/20200712211221327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="img" style="zoom:150%;" /></p>
<h4 id="4-数据在各层之间的传递过程"><a href="#4-数据在各层之间的传递过程" class="headerlink" title="4. 数据在各层之间的传递过程"></a>4. 数据在各层之间的传递过程</h4><p>在向下的过程中，<strong>需要添加下层协议所需要的首部或者尾部（进行的是分组交换）</strong>，而在向上的过程中不断拆开首部和尾部。</p>
<p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p>
<h2 id="二、应用层"><a href="#二、应用层" class="headerlink" title="*二、应用层"></a>*二、应用层</h2><h3 id="2-1-域名系统"><a href="#2-1-域名系统" class="headerlink" title="2.1 域名系统"></a>2.1 域名系统</h3><p>DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。</p>
<p>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p>
<p>[<img src="https://img-blog.csdnimg.cn/20200712211240423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="img" style="zoom:150%;" /></p>
<p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：</p>
<ul>
<li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li>
<li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li>
</ul>
<h3 id="2-2-常用端口"><a href="#2-2-常用端口" class="headerlink" title="2.2 常用端口"></a>2.2 常用端口</h3><table>
<thead>
<tr>
<th>应用</th>
<th>应用层协议</th>
<th>端口号</th>
<th>传输层协议</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>域名解析</td>
<td>DNS</td>
<td>53</td>
<td>UDP/TCP</td>
<td>长度超过 512 字节时使用 TCP</td>
</tr>
<tr>
<td>动态主机配置协议</td>
<td>DHCP</td>
<td>67/68</td>
<td>UDP</td>
<td></td>
</tr>
<tr>
<td>简单网络管理协议</td>
<td>SNMP</td>
<td>161/162</td>
<td>UDP</td>
<td></td>
</tr>
<tr>
<td>文件传送协议</td>
<td>FTP</td>
<td>20/21</td>
<td>TCP</td>
<td>控制连接 21，数据连接 20</td>
</tr>
<tr>
<td>远程终端协议</td>
<td>TELNET</td>
<td>23</td>
<td>TCP</td>
<td></td>
</tr>
<tr>
<td>超文本传送协议</td>
<td>HTTP</td>
<td>80</td>
<td>TCP</td>
<td></td>
</tr>
<tr>
<td>简单邮件传送协议</td>
<td>SMTP</td>
<td>25</td>
<td>TCP</td>
<td></td>
</tr>
<tr>
<td>邮件读取协议</td>
<td>POP3</td>
<td>110</td>
<td>TCP</td>
<td></td>
</tr>
<tr>
<td>网际报文存取协议</td>
<td>IMAP</td>
<td>143</td>
<td>TCP</td>
<td></td>
</tr>
</tbody></table>
<h3 id="2-3-WEB应用（重点）"><a href="#2-3-WEB应用（重点）" class="headerlink" title="*2.3 WEB应用（重点）"></a>*2.3 WEB应用（重点）</h3><p>Http协议是无状态协议（服务器不维护任何客户端过去所发请求信息）</p>
<h4 id="2-3-1-Http连接类型"><a href="#2-3-1-Http连接类型" class="headerlink" title="2.3.1 Http连接类型"></a>2.3.1 Http连接类型</h4><p>非持久连接（Http1.0）：每个TCP连接最多传输一个对象</p>
<p>持久连接（Http1.1）：每个TCP连接可以传输多个对象</p>
<h4 id="2-3-2-Http消息格式"><a href="#2-3-2-Http消息格式" class="headerlink" title="2.3.2 Http消息格式"></a>2.3.2 Http消息格式</h4><p>Http有两类消息：请求消息和响应消息</p>
<p>请求：</p>
<img src="https://img-blog.csdnimg.cn/20200712211646358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" style="zoom:150%;" />

<img src="https://img-blog.csdnimg.cn/2020071221165399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" style="zoom: 150%;" />

<p>响应：</p>
<img src="https://img-blog.csdnimg.cn/20200712211818423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" style="zoom:150%;" />

<h4 id="2-3-3-HTTP-请求页面"><a href="#2-3-3-HTTP-请求页面" class="headerlink" title="2.3.3 HTTP 请求页面"></a>2.3.3 HTTP 请求页面</h4><ul>
<li>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</li>
<li>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</li>
<li>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</li>
<li>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</li>
<li>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</li>
<li>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</li>
</ul>
<h4 id="2-3-4-Cookie技术"><a href="#2-3-4-Cookie技术" class="headerlink" title="2.3.4 Cookie技术"></a>2.3.4 Cookie技术</h4><p>网站为了辨别用户身份、进行session跟踪而存储在用户本地的数据</p>
<p>Cookie组件：</p>
<ol>
<li><p>请求中的cookie头部行</p>
</li>
<li><p>响应中的cookie头部行</p>
</li>
<li><p>保存在客户主机的cookie文件，由浏览器管理（清理垃圾时的那个）</p>
</li>
<li><p>Web服务器端的后台数据库（保存数据）</p>
</li>
</ol>
<h4 id="2-3-5-WEB缓存技术"><a href="#2-3-5-WEB缓存技术" class="headerlink" title="2.3.5 WEB缓存技术"></a>2.3.5 WEB缓存技术</h4><p>流程：</p>
<ol>
<li><p>用户设定浏览器通过web缓存进行web访问</p>
</li>
<li><p>浏览器向代理服务器发送http请求</p>
<p>a)    如果请求对象在缓存中，返回对象</p>
<p>b)   如果不在，缓存服务器向原始web服务器发送http请求，缓存保存并将请求对象返回给客户端</p>
</li>
</ol>
<p>条件性GET方法：</p>
<p>​    Web缓存在Http请求中声明所持有的版本的信息</p>
<p>​    如果缓存所持有的版本是最新的，返回304，否则返回200+最新数据</p>
 <img src="https://img-blog.csdnimg.cn/20200712211943474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70"  />

<h2 id="三、传输层"><a href="#三、传输层" class="headerlink" title="*三、传输层"></a>*三、传输层</h2><h3 id="3-1-UDP"><a href="#3-1-UDP" class="headerlink" title="3.1 UDP"></a>3.1 UDP</h3><p>优点：</p>
<ol>
<li><p>无需建立连接（减少延迟）</p>
</li>
<li><p>实现简单</p>
</li>
<li><p>头部开销小</p>
</li>
<li><p>没有拥塞控制</p>
</li>
</ol>
<p>在UDP上实现可靠数据传输:</p>
<ol>
<li><p>在应用层<strong>增加可靠性机制</strong></p>
</li>
<li><p>应用特定的<strong>错误恢复机制</strong></p>
</li>
</ol>
<img src="https://img-blog.csdnimg.cn/20200712212313365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" style="zoom: 200%;" />

<h4 id="3-1-1-可靠信道"><a href="#3-1-1-可靠信道" class="headerlink" title="3.1.1 可靠信道"></a>3.1.1 可靠信道</h4><p>Rdt1.0完全可靠信道（不切实际的）</p>
<p>Rdt2.0（符合实际的某一种信道，产生位错误的信道）：</p>
<p>解决位错误：ARQ协议，利用校验和检测位错误</p>
<p>正确发送ACK，错误发送NAK，所以当发送方收到NAK后，重传分组。</p>
<p>Rdt2.1若ACK/NAK坏掉：</p>
<p>​    发送方重传分组。（发送方给每个分组增加序列号，接收方丢弃重复分组）</p>
<p>Rdt2.2改进：只使用ACK：</p>
<p>​    通过ACK告知最后一个被正确接收的分组。发送方收到重复序列号的ACK，视为NAK。（例如0正确接收，1没有正确接收，则返回0的ACK，跟上次返回重复（上次0成功也是返回0），所以判定是NAK）</p>
<p>Rdt3.0解决丢失分组：</p>
<p>​    发送方等待合理时间（需要一个定时器），未收到ACK，重传</p>
<p>总结：构建可靠信道：</p>
<ol>
<li><p>发送方发送一个分组，附<strong>带序列号</strong></p>
</li>
<li><p>接收方根据检验和检验接收的分组是否正确。若正确，发送ACK+当前序列号；若错误，发送ACK+上一序列号</p>
</li>
<li><p>发送方若收到ACK，则准备传输ACK序列号+1的分组。若在合理等待时间内未收到ACK或ACK被损坏，则重传上一分组。</p>
</li>
</ol>
<h4 id="3-1-2-滑动窗口协议"><a href="#3-1-2-滑动窗口协议" class="headerlink" title="3.1.2 滑动窗口协议"></a>3.1.2 滑动窗口协议</h4><p>同时可以传输等待<strong>多个分组</strong>（前面都是一个个的发，单个分组），减少RTT（往返时间）对网络吞吐量的影响。</p>
<p> <img src="https://img-blog.csdnimg.cn/20200712212506246.png" alt=""></p>
<p><strong>GBN</strong>：连续发生多个分组，<strong>累计确认</strong></p>
<p>接收方只同时等待一个分组。乱序到达的分组直接丢弃。</p>
<p><strong>累计确认：每个ACK可确认多个分组</strong>（即ACK(N)确认该ACK N序号之前的所有分组）。</p>
 <img src="https://img-blog.csdnimg.cn/20200712212623449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70"  />

<p>1、如果未收到（即图中pkt2），后序发送的分组就会一直返回最高序列号的ACK（即图中的ACK1）</p>
<p>2、后序发送的分组还会重新发送一遍（即pkt2~pkt5都会重传一遍）</p>
<p><strong>SR</strong>：连续发生多个分组，不采用累积确认，缓存乱序的分组</p>
<p>每个ACK确认一个分组，不累积确认</p>
<p>接收方<strong>需缓存乱序到达的分组，最后正序到达后一起连同缓存的一起发</strong></p>
<p> <img src="https://img-blog.csdnimg.cn/20200712212718160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt=""></p>
<h3 id="3-3-TCP"><a href="#3-3-TCP" class="headerlink" title="3.3 TCP"></a>3.3 TCP</h3><p>TCP采用流水线机制、ACK累计确认（<strong>按序到达的最后一个分组发送确认</strong>）机制，对于乱序分组的处理没有作规范。</p>
<p>TCP序列号是传输的<strong>第一个字节的序列号。</strong></p>
<h4 id="3-2-1TCP超时重传机制"><a href="#3-2-1TCP超时重传机制" class="headerlink" title="3.2.1TCP超时重传机制"></a>3.2.1TCP超时重传机制</h4><p>触发重传的事件：超时、收到重复ACK，只会重传超时的段（类似SR）</p>
 <img src="https://img-blog.csdnimg.cn/20200712213024523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" style="zoom:150%;" />

<p>设置定时器超时时间：测量多个RTT，<strong>求平均值ERTT，同时ERTT不断修正。</strong></p>
<p>定时器超时时间=ERTT+安全边界（ERTT变化越大，边界越大）</p>
<p><strong>快速重传机制：在超时之前进行重传</strong></p>
<p>如果触发重传，会导致超时时间加倍。<strong>为减小重传延迟，发送方连续收到3个相同序列号ACK即立刻重传。</strong></p>
<h4 id="3-2-2流量控制"><a href="#3-2-2流量控制" class="headerlink" title="3.2.2流量控制"></a>3.2.2流量控制</h4><p>原因：Buffer溢出，防止发送方传输太多太快，以至淹没接收方。</p>
<p>做法：</p>
<ul>
<li><p>接收方在段头部将剩余空间告诉发送方，</p>
</li>
<li><p>发送方限制已发送但未ACK的大小不超过接收方剩余空闲空间。</p>
</li>
</ul>
<h4 id="3-2-3-三次握手四次挥手"><a href="#3-2-3-三次握手四次挥手" class="headerlink" title="3.2.3 三次握手四次挥手"></a>3.2.3 三次握手四次挥手</h4><p>三次握手：</p>
<p>第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入<strong>SYN_SENT</strong>状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入<strong>SYN_RECV</strong>状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入<strong>ESTABLISHED</strong>（TCP连接成功）状态，完成三次握手。</p>
<img src="https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" style="zoom:150%;" />

<p>四次挥手：</p>
<p>1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。<br>2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。<br>3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。<br>4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。<br>5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。<br>6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>
<p>总结：</p>
<ol>
<li><p>客户端向服务端发送FIN报文段。头部FIN位置1。</p>
</li>
<li><p>服务端返回一个ACK。</p>
</li>
<li><p>服务端发送一个FIN。</p>
</li>
<li><p>客户端返回一个ACK。</p>
<img src="https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" style="zoom: 150%;" />

</li>
</ol>
<h4 id="3-2-4-拥塞控制"><a href="#3-2-4-拥塞控制" class="headerlink" title="3.2.4 拥塞控制"></a>3.2.4 拥塞控制</h4><p>定义：不要让中间网络传输处理不了，区别于流量控制</p>
<p>拥塞控制的方法：</p>
<ol>
<li><p><strong>端到端</strong>拥塞控制（TCP采用）：网络层不需要提供支持；</p>
<p>端系统host通过观察loss和delay等判断是否发生了拥塞。</p>
</li>
<li><p>网络辅助的拥塞控制：<strong>路由器</strong>向发送方显式的反馈网络拥塞，指示发送方应采取何种速率发送。（最近的tcpip也可选择性实现该方法）</p>
<p>a)    直接网络反馈：发生拥塞的路由器直接向发送方反馈</p>
<p>b)   经由接收方的网络反馈：发送方发出一个测试分组至接收方，接收方再传回。途中经过拥塞路由器，标记拥塞。</p>
</li>
</ol>
<h4 id="3-2-5-TCP拥塞控制原理"><a href="#3-2-5-TCP拥塞控制原理" class="headerlink" title="3.2.5 TCP拥塞控制原理"></a>3.2.5 TCP拥塞控制原理</h4><ol>
<li><p>限制发送流量的速率</p>
</li>
<li><p>感知路径上存在拥塞</p>
</li>
<li><p>感知到拥塞后使用何种算法降低速率？</p>
</li>
<li><p>拥塞窗口：类似于流量控制的接收窗口。</p>
</li>
</ol>
<p>已发送但未ACK的分组数 &lt; min(拥塞窗口, 接收窗口)</p>
<ol>
<li><p>丢失意味着拥塞，收到ACK意味着可以增加速率。</p>
</li>
<li><p>慢启动；<strong>加性增乘性减</strong></p>
<img src="https://img-blog.csdnimg.cn/20200712213324421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" style="zoom:150%;" />
</li>
</ol>
<ul>
<li><p>启动时初始速率极低，但拥塞窗口指数增长。</p>
</li>
<li><p>达到Threshold（loss时间发生前的拥塞值的一半）时，变为线性增长。</p>
</li>
<li><p>当出现loss时：</p>
</li>
</ul>
<ol>
<li><p>出现三个重复ACK，拥塞窗口大小减半 + 3（3个ack）。</p>
</li>
<li><p><strong>出现timeout时，代表网络拥堵极为严重，拥塞窗口回归初始值1。Threshold设置为当前拥塞窗口大小的1/2。</strong>（早期版本tcp无快速恢复，出现loss即回归初始值）</p>
</li>
</ol>
<h2 id="四、面试问题（重重重重点！！！！）"><a href="#四、面试问题（重重重重点！！！！）" class="headerlink" title="**四、面试问题（重重重重点！！！！）"></a>**四、面试问题（重重重重点！！！！）</h2><h3 id="4-1-各层的结构与功能-都有哪些协议"><a href="#4-1-各层的结构与功能-都有哪些协议" class="headerlink" title="4.1 各层的结构与功能,都有哪些协议"></a>4.1 各层的结构与功能,都有哪些协议</h3><ul>
<li>应用层</li>
</ul>
<p>应用层(application-layer）的任务是通过<strong>应用进程间</strong>的交互来完成特定网络应用。</p>
<ul>
<li><p>域名系统DNS：它作为可以将域名和IP地址相互映射的一个分布式数据库</p>
</li>
<li><p>HTTP协议：超文本传输协议</p>
</li>
<li><p>传输层</p>
</li>
</ul>
<p>传输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的<strong>数据传输服务</strong>。</p>
<p>应用进程利用该服务传送应用层报文，多种应用可以通过<strong>复用和分用</strong>使用同一个运输层服务。</p>
<ul>
<li><p>TCP（Transmission Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠</strong>的数据传输服务。</p>
</li>
<li><p>UDP（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</p>
</li>
<li><p>网络层</p>
</li>
</ul>
<p>在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多<strong>通信子网</strong>。网络层的任务就是<strong>选择合适的网间路由和交换结点， 确保数据及时传送。</strong> </p>
<ul>
<li>数据链路层</li>
</ul>
<p>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<ul>
<li>物理层</li>
</ul>
<p>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，使其上面的数据链路层不必考虑网络的具体传输介质是什么。</p>
<h3 id="4-2-TCP三次握手与四次挥手（面试常客）"><a href="#4-2-TCP三次握手与四次挥手（面试常客）" class="headerlink" title="4.2 TCP三次握手与四次挥手（面试常客）"></a>4.2 TCP三次握手与四次挥手（面试常客）</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B2.png" alt=""></p>
<h4 id="4-2-1-为什么要三次握手"><a href="#4-2-1-为什么要三次握手" class="headerlink" title="4.2.1 为什么要三次握手"></a>4.2.1 为什么要三次握手</h4><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p>
<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p>
<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p>
<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<h4 id="4-2-2-为什么要四次挥手"><a href="#4-2-2-为什么要四次挥手" class="headerlink" title="4.2.2 为什么要四次挥手"></a>4.2.2 为什么要四次挥手</h4><ul>
<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li>
<li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</li>
<li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li>
<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</li>
</ul>
<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>
<h4 id="4-2-3-拓展"><a href="#4-2-3-拓展" class="headerlink" title="4.2.3 拓展"></a>4.2.3 拓展</h4><ul>
<li>为什么连接的时候是三次握手，关闭的时候却是四次握手？</li>
</ul>
<p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<ul>
<li>为什么不能用两次握手进行连接？</li>
</ul>
<p>答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</p>
<p>现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p>
<ul>
<li>为什么要传回 SYN</li>
</ul>
<p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p>
<p>SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p>
<ul>
<li>传了 SYN,为啥还要传 ACK</li>
</ul>
<p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="TCP四次挥手"></p>
<ul>
<li>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</li>
</ul>
<p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p>
<ul>
<li>如果已经建立了连接，但是客户端突然出现故障了怎么办？</li>
</ul>
<p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h3 id="4-3-TCP-UDP-协议的区别"><a href="#4-3-TCP-UDP-协议的区别" class="headerlink" title="4.3 TCP,UDP 协议的区别"></a>4.3 TCP,UDP 协议的区别</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/tcp-vs-udp.jpg" alt="TCP、UDP协议的区别"></p>
<p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p>
<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
<h3 id="4-4-在浏览器中输入url地址-gt-gt-显示主页的过程-面试常客"><a href="#4-4-在浏览器中输入url地址-gt-gt-显示主页的过程-面试常客" class="headerlink" title="4.4 在浏览器中输入url地址 -&gt;&gt; 显示主页的过程(面试常客)"></a>4.4 在浏览器中输入url地址 -&gt;&gt; 显示主页的过程(面试常客)</h3><p>打开一个网页，整个过程会使用哪些协议，总体来说分为以下几个过程:</p>
<ol>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/url%E8%BE%93%E5%85%A5%E5%88%B0%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt="img"></p>
<h3 id="4-5-HTTP长连接-短连接"><a href="#4-5-HTTP长连接-短连接" class="headerlink" title="4.5 HTTP长连接,短连接"></a>4.5 HTTP长连接,短连接</h3><p>总结：</p>
<p>非持久连接（Http1.0）：每个TCP连接最多传输一个对象</p>
<p>持久连接（Http1.1）：每个TCP连接可以传输多个对象</p>
<ul>
<li><p>在HTTP/1.0中默认使用短连接。客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器每访问一个Web资源时，浏览器就会重新建立一个HTTP会话。</p>
</li>
<li><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于<strong>传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</strong></p>
</li>
</ul>
<p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>
<h3 id="4-6-HTTP是不保存状态的协议-如何保存用户状态"><a href="#4-6-HTTP是不保存状态的协议-如何保存用户状态" class="headerlink" title="4.6 HTTP是不保存状态的协议,如何保存用户状态?"></a>4.6 HTTP是不保存状态的协议,如何保存用户状态?</h3><p>HTTP 是一种不保存状态，即无状态协议。保存用户状态一般使用Cookie和Session。</p>
<p><strong>Cookie 一般用来保存用户信息，Session 在服务端记录用户的状态。</strong> </p>
<p>Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。</p>
<ul>
<li>Cookie与Session区别</li>
</ul>
<ol>
<li><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
</li>
<li><p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
</li>
</ol>
<h3 id="4-7-HTTP-1-0和1-1的主要区别"><a href="#4-7-HTTP-1-0和1-1的主要区别" class="headerlink" title="4.7 HTTP 1.0和1.1的主要区别"></a>4.7 HTTP 1.0和1.1的主要区别</h3><ol>
<li>长连接 : 在HTTP/1.0中，默认使用的是短连接，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。HTTP 1.1起，默认使用长连接 ,默认开启Connection： keep-alive。 HTTP/1.1的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li>
<li>错误状态响应码 :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li>缓存处理 :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
<li>带宽优化及网络连接的使用 :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
</ol>
<h3 id="4-8-URI和URL的区别是什么"><a href="#4-8-URI和URL的区别是什么" class="headerlink" title="4.8 URI和URL的区别是什么?"></a>4.8 URI和URL的区别是什么?</h3><ul>
<li>URI 是统一资源标志符，可以唯一标识一个资源。</li>
<li>URL是统一资源定位符，<strong>可以提供该资源的路径</strong>。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>
</ul>
<p>URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<h3 id="4-9-HTTP-和-HTTPS-的区别？"><a href="#4-9-HTTP-和-HTTPS-的区别？" class="headerlink" title="4.9 HTTP 和 HTTPS 的区别？"></a>4.9 HTTP 和 HTTPS 的区别？</h3><ol>
<li><p>端口 ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</p>
</li>
<li><p>安全性和资源消耗： </p>
<p>HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。</p>
<p>HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</p>
<ul>
<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li>
<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li>
</ul>
</li>
</ol>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">rnang0</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/06/28/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A05%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">http://yoursite.com/2020/06/28/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A05%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">rnang0 Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/TCP-IP/">TCP/IP</a><a class="post-meta__tags" href="/tags/HTTP-HTTPS/">HTTP/HTTPS</a></div><div class="post_share"><div class="social-share" data-image="https://img-blog.csdnimg.cn/20200701112110271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/06/23/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A04%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><img class="next_cover" src="https://img-blog.csdnimg.cn/20200624114032370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">春招复习4：操作系统</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By rnang0</div><div class="footer_custom_text">Hi, welcome to my <a href="http://rnang0.github.io/" target="_blank" rel="noopener">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script></body></html>