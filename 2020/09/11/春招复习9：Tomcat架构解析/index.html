<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>春招复习9：Tomcat架构解析 | rnang0 Blog</title><meta name="description" content="Tomcat架构解析​    参考书籍《Tomcat架构解析》 一、Tomcat基础1. 静态&#x2F;动态资源​    浏览器只能解析静态资源（html，css，js，jpg），而动态资源（例如Servlet，jsp等）需要转换成静态资源再返回给浏览器。 2. Web服务器软件​    Tomcat作为一款Web服务器软件，需要兼备 服务器 和 服务器软件 的功能。 ​    具有：接收用户的请求，处理"><meta name="keywords" content="Tomcat,Servlet"><meta name="author" content="rnang0"><meta name="copyright" content="rnang0"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="春招复习9：Tomcat架构解析"><meta name="twitter:description" content="Tomcat架构解析​    参考书籍《Tomcat架构解析》 一、Tomcat基础1. 静态&#x2F;动态资源​    浏览器只能解析静态资源（html，css，js，jpg），而动态资源（例如Servlet，jsp等）需要转换成静态资源再返回给浏览器。 2. Web服务器软件​    Tomcat作为一款Web服务器软件，需要兼备 服务器 和 服务器软件 的功能。 ​    具有：接收用户的请求，处理"><meta name="twitter:image" content="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2864077756,2277292526&amp;fm=26&amp;gp=0.jpg"><meta property="og:type" content="article"><meta property="og:title" content="春招复习9：Tomcat架构解析"><meta property="og:url" content="http://rnang0.github.io/2020/09/11/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A09%EF%BC%9ATomcat%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/"><meta property="og:site_name" content="rnang0 Blog"><meta property="og:description" content="Tomcat架构解析​    参考书籍《Tomcat架构解析》 一、Tomcat基础1. 静态&#x2F;动态资源​    浏览器只能解析静态资源（html，css，js，jpg），而动态资源（例如Servlet，jsp等）需要转换成静态资源再返回给浏览器。 2. Web服务器软件​    Tomcat作为一款Web服务器软件，需要兼备 服务器 和 服务器软件 的功能。 ​    具有：接收用户的请求，处理"><meta property="og:image" content="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2864077756,2277292526&amp;fm=26&amp;gp=0.jpg"><meta property="article:published_time" content="2020-09-10T16:00:00.000Z"><meta property="article:modified_time" content="2020-09-26T03:03:51.613Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="canonical" href="http://rnang0.github.io/2020/09/11/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A09%EF%BC%9ATomcat%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/"><link rel="prev" title="春招复习10：Netty底层机制" href="http://rnang0.github.io/2020/09/27/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A011%EF%BC%9ANetty%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%E5%92%8C%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"><link rel="next" title="春招复习8：数据库与缓存" href="http://rnang0.github.io/2020/08/03/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A08%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'none',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/autor.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">23</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">41</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-mars"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Tomcat架构解析"><span class="toc-text">Tomcat架构解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、Tomcat基础"><span class="toc-text">一、Tomcat基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-静态-动态资源"><span class="toc-text">1. 静态&#x2F;动态资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Web服务器软件"><span class="toc-text">2. Web服务器软件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Tomcat主要目录结构"><span class="toc-text">3. Tomcat主要目录结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Http工作原理"><span class="toc-text">4. Http工作原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、Tomcat总体架构"><span class="toc-text">二、Tomcat总体架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Servlet容器"><span class="toc-text">1. Servlet容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Servlet容器工作流程"><span class="toc-text">2. Servlet容器工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Tomcat整体架构"><span class="toc-text">3. Tomcat整体架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Connector和Container"><span class="toc-text">4. Connector和Container</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Container容器"><span class="toc-text">1. Container容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Pipeline和Valve（针对Container组件）"><span class="toc-text">2. Pipeline和Valve（针对Container组件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Connector连接器"><span class="toc-text">3. Connector连接器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Bootstrap和Catalina"><span class="toc-text">5. Bootstrap和Catalina</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、Coyote连接器"><span class="toc-text">三、Coyote连接器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-协议与I-O模型"><span class="toc-text">1. 协议与I&#x2F;O模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-连接器组件"><span class="toc-text">2. 连接器组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-EndPoint监听点"><span class="toc-text">1. EndPoint监听点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Processor处理接口"><span class="toc-text">2. Processor处理接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-ProtocolHandler协议处理器"><span class="toc-text">3. ProtocolHandler协议处理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Adapter适配器"><span class="toc-text">4. Adapter适配器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-线程池"><span class="toc-text">3. 线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、Catalina容器"><span class="toc-text">四、Catalina容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Catalina结构"><span class="toc-text">1. Catalina结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Catalina组件"><span class="toc-text">2. Catalina组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Container容器"><span class="toc-text">3. Container容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-server-xml结构"><span class="toc-text">4. server.xml结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、Tomcat启动流程"><span class="toc-text">五、Tomcat启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-启动流程分析"><span class="toc-text">1. 启动流程分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Lifecycle"><span class="toc-text">2. Lifecycle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-组件的默认实现"><span class="toc-text">3. 组件的默认实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-源码解析"><span class="toc-text">4. 源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-BootStrap启动类"><span class="toc-text">1. BootStrap启动类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Catalina类load方法"><span class="toc-text">2. Catalina类load方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-组件的init初始化"><span class="toc-text">3.组件的init初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-组件的start启动"><span class="toc-text">4. 组件的start启动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-启动总结"><span class="toc-text">5. 启动总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、Tomcat请求处理流程（执行）"><span class="toc-text">六、Tomcat请求处理流程（执行）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Mapper组件"><span class="toc-text">1. Mapper组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-请求处理流程分析"><span class="toc-text">2. 请求处理流程分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-源码分析"><span class="toc-text">3. 源码分析</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2864077756,2277292526&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">rnang0 Blog</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-mars"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">春招复习9：Tomcat架构解析</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-09-11 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-09-11</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-09-26 11:03:51"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-09-26</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/">春招复习</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Tomcat架构解析"><a href="#Tomcat架构解析" class="headerlink" title="Tomcat架构解析"></a>Tomcat架构解析</h1><p>​    参考书籍《Tomcat架构解析》</p>
<h2 id="一、Tomcat基础"><a href="#一、Tomcat基础" class="headerlink" title="一、Tomcat基础"></a>一、Tomcat基础</h2><h3 id="1-静态-动态资源"><a href="#1-静态-动态资源" class="headerlink" title="1. 静态/动态资源"></a>1. 静态/动态资源</h3><p>​    浏览器只能解析静态资源（html，css，js，jpg），而<strong>动态资源（例如Servlet，jsp等）需要转换成静态资源再返回给浏览器。</strong></p>
<h3 id="2-Web服务器软件"><a href="#2-Web服务器软件" class="headerlink" title="2. Web服务器软件"></a>2. Web服务器软件</h3><p>​    Tomcat作为一款Web服务器软件，<strong>需要兼备 服务器 和 服务器软件 的功能</strong>。</p>
<p>​    <strong>具有：接收用户的请求，处理请求，做出响应，同时可以部署Web应用，让用户通过浏览器来访问这些项目。</strong>但Tomcat作为一个中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。</p>
<h3 id="3-Tomcat主要目录结构"><a href="#3-Tomcat主要目录结构" class="headerlink" title="3. Tomcat主要目录结构"></a>3. Tomcat主要目录结构</h3><p><img src="https://img-blog.csdnimg.cn/20200917171910457.png#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p>bin目录，存放Tomcat启动、停止的<strong>脚本</strong></p>
<p>startup.bat ,startup.sh：用于在windows和linux下的启动脚本<br>shutdown.bat ,shutdown.sh：用于在windows和linux下的停止脚本</p>
<p><strong>还有Tomcat的startup启动时，实际调用的Catalina脚本</strong></p>
</li>
<li><p>conf目录，用于存放Tomcat的相关配置文件</p>
<p>Catalina：用于存储针对<strong>每个虚拟机的Context配置</strong><br>context.xml：用于定义<strong>所有web应用</strong>均需加载的Context配置，如果web应用指定了自己的context.xml，该文件将被覆盖<br>catalina.properties：Tomcat 的环境变量配置<br>catalina.policy：Tomcat 运行的安全策略配置<br>logging.properties：Tomcat 的日志配置文件， 可以通过该文件修改Tomcat 的日志级别及日志路径等<br><strong>server.xml：Tomcat 服务器的核心配置文件</strong><br>tomcat-users.xml：定义Tomcat默认的用户及角色映射信息配置<br><strong>web.xml：Tomcat 中所有应用默认的部署描述文件，主要定义了基础Servlet和MIME映射。</strong></p>
</li>
</ul>
<p><strong>注意：Tomcat就是根据<code>conf</code>路径下的<code>server.xml</code>的配置文件信息，来创建的服务器实例。</strong></p>
<ul>
<li>lib：Tomcat 服务器的依赖包</li>
<li>logs：Tomcat 默认的日志存放目录</li>
<li><strong>webapps</strong>：Tomcat 默认的<strong>Web应用部署目录</strong></li>
<li>work：Web 应用JSP代码生成和编译的临时目录</li>
</ul>
<h3 id="4-Http工作原理"><a href="#4-Http工作原理" class="headerlink" title="4. Http工作原理"></a>4. Http工作原理</h3><p>​    HTTP协议是浏览器与服务器之间的数据传送协议。<strong>作为应用层协议，HTTP是基于TCP/IP协议来传递数据的（HTML文件、图片、查询结果等）</strong>，HTTP协议<strong>不涉及数据包（Packet）传输，只是一种规定的通信格式。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200917174003592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​    浏览器向服务端<strong>发出TCP连接请求</strong>，服务程序接受浏览器的连接请求，并经过<strong>TCP三次握手建立连接。</strong>浏览器将请求数据打包成一个HTTP协议格式的数据包，浏览器将该数据包<strong>推入网络，数据包经过网络传输，最终达到端服务程序。</strong>服务端到客户端亦然，浏览器将HTML文件展示在页面上，则Tomcat的功能步骤就分析出来了。</p>
<p>​    <strong>Tomcat作为一个Web应用服务器，主要是接受连接、解析请求数据、处理请求、发出响应这四个步骤。</strong></p>
<h2 id="二、Tomcat总体架构"><a href="#二、Tomcat总体架构" class="headerlink" title="二、Tomcat总体架构"></a>二、Tomcat总体架构</h2><h3 id="1-Servlet容器"><a href="#1-Servlet容器" class="headerlink" title="1. Servlet容器"></a>1. Servlet容器</h3><p>​    容器：是一类组件的总称，例如后面的引擎Engine容器，应用Context容器，作用：处理请求返回响应数据。</p>
<p>​    Http服务器请求处理的过程：</p>
<p>​    浏览器发给服务端的是一个HTTP格式的请求，服务器收到这个请求后，需要调用服务端程序来处理，<strong>所谓的服务端程序就是你写的Java类（servlet）</strong>，一般来说不同的请求需要由不同的Java类（servlet）来处理。</p>
<p>​    <img src="https://img-blog.csdnimg.cn/20200917192505156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​    Tomcat不直接调用业务类，而是把<strong>请求交给容器来处理</strong>，从而达到解耦合的目的。Servlet容器通过Servlet接口调用业务类，Tomcat按照Servlet规范的要求实现了Servlet容器，同时它们也具有HTTP服务器的功能。作为Java程序员，如果<strong>我们要实现新的业务功能，只需要实现一个Servlet，并把它注册到Tomcat（Servlet容器）中，</strong>剩下的事情就由Tomcat帮我们处理了。</p>
<p>​    Servlet接口和Servlet容器这一整套规范叫作Servlet规范。</p>
<h3 id="2-Servlet容器工作流程"><a href="#2-Servlet容器工作流程" class="headerlink" title="2. Servlet容器工作流程"></a>2. Servlet容器工作流程</h3><p>​    把请求交给Servlet容器来处理，那么Servlet容器工作步骤为：</p>
<ol>
<li>当客户请求某个资源时，请求信息发送给HTTP服务器一个Request对象数据，然后<strong>服务器会用一个ServletRequest对象把客户的请求信息封装起来。</strong></li>
<li>调用Servlet容器的service方法，然后<strong>根据Web应用配置文件中的请求的Url路径和Servlet的映射关系，找到Servlet，没有就根据反射机制动态创建这个Servlet，</strong>调用init方法完成初始化，接着调用servlet的service方法处理请求（根据get，或者post来进行处理），然后将封装好的ServletResponse对象返回给HTTP服务器，然后服务器再返回给客户端Response对象。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200918145807834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​    综上所述，我们就了解了需求，了解了Tomcat服务器的核心功能：<strong>处理连接</strong> 和 <strong>加载Servlet处理Requst请求</strong></p>
<h3 id="3-Tomcat整体架构"><a href="#3-Tomcat整体架构" class="headerlink" title="3. Tomcat整体架构"></a>3. Tomcat整体架构</h3><p>​    Tomcat要实现两个核心功能：<br><strong>1） 开启Socket连接，监听服务器端口，负责网络字节流与Request和Response对象的转化。</strong><br><strong>2） 加载和管理Servlet，以及具体处理Request请求。</strong></p>
<p>​    为了方便解耦，例如适配多种网络协议但请求处理却相同的时候，Tomcat设计了两个组件来实现这两个功能，<strong>连接器（Connector）和容器（Container）。</strong></p>
<p>​    <strong>连接器负责对外交流，处理Socket连接，容器（引擎Engine）负责加载和管理Servlet，和内部逻辑处理。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200918150222708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​    <strong>注意：Tomcat架构的重点便是连接器和容器内部的具体架构和源码分析。</strong></p>
<h3 id="4-Connector和Container"><a href="#4-Connector和Container" class="headerlink" title="4. Connector和Container"></a>4. Connector和Container</h3><h4 id="1-Container容器"><a href="#1-Container容器" class="headerlink" title="1. Container容器"></a>1. Container容器</h4><p>​    容器只是个统称，其实下面是继承实现了Engine、Host、Context、Wrapper（Servlet）。Container可以添加并且维护这些个子容器，并且是弱依赖的关系，根据不同级别来加入处理请求的组件，例如8.56之前直接由Service维护一个Context。</p>
<p>​    <strong>Lifecycle：所有的组件均存在初始化、启动、停止等生命周期方法，拥有生命周期的性质，所以我们又可以进行一次接口抽象。</strong></p>
<p>​    Tomcat核心的组件默认实现均是继承自LifecycleMBeanBase抽象类，可以进行组件状态转换和维护（自身注册为MBean，通过管理工具维护）。</p>
<p><img src="https://img-blog.csdnimg.cn/20200918154546877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="2-Pipeline和Valve（针对Container组件）"><a href="#2-Pipeline和Valve（针对Container组件）" class="headerlink" title="2. Pipeline和Valve（针对Container组件）"></a>2. Pipeline和Valve（针对Container组件）</h4><p>​    在增强组件灵活性和可扩展性方面，Tomcat采用了<strong>职责链模式来实现客户端请求的处理，这也是职责链模式的经典应用场景。</strong></p>
<p>每次请求通过执行一个职责链来完成具体的请求处理，Tomcat定义了Pipeline管道和Valve阀两个接口，前者构建职责链，后者代表职责链上每个处理器。</p>
<p><strong>Pipeline中维护了一个基础的Valve，始终位于末端，负责后序组件管道调用，封装了请求处理和输出响应，然后addValve通过头插法，添加到它之前，每次按照顺序执行。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200918161342531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="3-Connector连接器"><a href="#3-Connector连接器" class="headerlink" title="3. Connector连接器"></a>3. Connector连接器</h4><p>​    接下来我们来细化一下连接器这个组件——Connector，连接器的功能包括：</p>
<ul>
<li><strong>监听服务器的端口</strong>，例如http协议则为8080端口，读取来自客户端的请求</li>
<li>将请求的数据<strong>按照对应的指定协议进行解析</strong></li>
<li><strong>重点：将请求地址匹配到正确的容器进行处理</strong></li>
<li>返回响应</li>
</ul>
<p><strong>只有这样才能保证接收的客户端请求交由请求地址匹配的容器处理。</strong></p>
<ul>
<li>ProtocolHandler协议处理器</li>
</ul>
<p>在Tomcat中，ProtocolHandler表示一个协议处理器，针对不同的协议和I/O方式，提供了不同的实现，例如Http11NioProtocol表示基于NIO的HTTP协议处理器。</p>
<p>在Connector启动时，<strong>Endpoint</strong>启动线程来<strong>监听服务器端口</strong>，接收到请求后<strong>调用Processor进行数据读取，根据请求地址映射（Servlet规范定义）通过Mapper实现到具体的容器进行处理。</strong></p>
<ul>
<li>CoyoteAdapter：适配器模式下Tomcat默认的Connector实现。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200918184813832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="5-Bootstrap和Catalina"><a href="#5-Bootstrap和Catalina" class="headerlink" title="5. Bootstrap和Catalina"></a>5. Bootstrap和Catalina</h3><p>​    1. Tomcat有几个重要的配置文件，其中最核心的就是<code>server.xml</code>。通过这个文件，可以修改Tomcat组件的配置参数，甚至添加组件，后序展开。</p>
<p>​    2. Tomcat通过Catalina中的<strong>Digester</strong>来解析XML文件，包括<code>server.xml</code>和<code>web.xml</code>等等，最后提供了<strong>Bootstrap作为了应用服务器的启动入口，负责创建Catalina实例，根据Catalina来完成服务器的操作。</strong></p>
<p><strong>注意：Bootstrap在bin目录下，与Tomcat服务器完全的松耦合，通过反射来创建Catalina实例，用于构造整个服务器。好处：Bootstrap实现了启动入口与核心环节的解耦，简化启动（避免各种依赖），更加灵活的组织我们的中间件产品结构。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/2020091819140267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="三、Coyote连接器"><a href="#三、Coyote连接器" class="headerlink" title="三、Coyote连接器"></a>三、Coyote连接器</h2><p>​    <strong>Coyote 封装了底层的网络通信（Socket 请求及响应处理）</strong>，为Servlet容器Catalina提供了统一的接口。</p>
<p>​    Coyote 作为独立的模块，只负责具体协议和IO的相关操作， 与Servlet 规范实现没有直接关系，因此即便是 Request 和 Response 对象也并未实现Servlet规范对应的接口， 而是在<strong>Catalina 中将他们进一步封装为ServletRequest 和 ServletResponse。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200918192226760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="1-协议与I-O模型"><a href="#1-协议与I-O模型" class="headerlink" title="1. 协议与I/O模型"></a>1. 协议与I/O模型</h3><p>​    在Coyote中支持多种应用层协议和I/O模型：</p>
<p><img src="https://img-blog.csdnimg.cn/2020091910060568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​    在 8.0 之前，Tomcat 默认采用的I/O方式为 BIO，之后改为 NIO。无论 NIO、NIO2 还是 APR，在性能方面均优于以往的BIO。</p>
<p><img src="https://img-blog.csdnimg.cn/20200919102011107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​    Tomcat支持多种协议与I/O，则<strong>一个容器对接多个连接器，多个连接器和容器组装后成为一个Service组件，同时Tomcat可以配置多个Service，来使得更加灵活。</strong>实现通过不同的端口号来访问同一台机器上部署的不同应用。</p>
<h3 id="2-连接器组件"><a href="#2-连接器组件" class="headerlink" title="2. 连接器组件"></a>2. 连接器组件</h3><p>​    连接器各个组件的作用如下图，如二、Tomcat总体架构中的Connector连接器所述：</p>
<p><strong>连接器内部维护一个ProtocolHandler协议处理器和Adapter适配器，来分别进行请求监听和处理和封装request对象成容器能够解析的servletRequest。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200919102527790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="1-EndPoint监听点"><a href="#1-EndPoint监听点" class="headerlink" title="1. EndPoint监听点"></a>1. EndPoint监听点</h4><p>​    监听即通信监听，EndPoint作为Coyote的通信端点，即通信监听的端口。</p>
<p>​    <strong>注意：EndPoint是具体Socket接受和发送处理器，是对传输层的一层抽象，用TCP/IP协议来实现的。</strong></p>
<p>​    Tomcat提供的是抽象类AbstractEndpoint ， 里面定义了两个内部类：Acceptor和SocketProcessor。</p>
<ul>
<li><p>Acceptor用于<strong>监听Socket连接请求</strong>，继承了Runnable，<strong>本质就是个线程，一直死循环监听连接</strong>。</p>
</li>
<li><p>SocketProcessor用于处理接收到的Socket请求，<strong>它实现Runnable接口，在Run方法里调用协议处理组件Processor进行处理。</strong></p>
<p>为了提高处理能力，SocketProcessor被提交到线程池来执行。而这个线程池叫作执行器（Executor)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> AcceptorState &#123;</span><br><span class="line">        NEW, RUNNING, PAUSED, ENDED</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> AcceptorState state = AcceptorState.NEW;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AcceptorState <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setThreadName</span><span class="params">(<span class="keyword">final</span> String threadName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadName = threadName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> String <span class="title">getThreadName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Processor处理接口"><a href="#2-Processor处理接口" class="headerlink" title="2. Processor处理接口"></a>2. Processor处理接口</h4><p>​    Coyote的协议处理的接口，如果说EndPoint是出来TCP/IP协议的，那么Processor用来<strong>实现Http协议的，是对应用层的抽象。</strong></p>
<p>功能：接收前者的Socket -&gt; 转换成字节流解析成为Request，然后<strong>将Requst对象通过适配器Adapter将其提交到容器来处理。</strong></p>
<h4 id="3-ProtocolHandler协议处理器"><a href="#3-ProtocolHandler协议处理器" class="headerlink" title="3. ProtocolHandler协议处理器"></a>3. ProtocolHandler协议处理器</h4><p>​    在第二、Tomcat总体架构中，我们知道了ProtocolHandler是对 <strong>EndPoint监听点 和 Processor协议 处理的一层封装</strong>，根据协议和I/O提供了实现类：</p>
<p>AjpNioProtocol ， AjpAprProtocol， AjpNio2Protocol ， Http11NioProtocol ，Http11Nio2Protocol ， Http11AprProtocol。</p>
<p>​    一般我们在配置文件<code>server.xml</code>中进行配置，指定对应的协议名称，默认使用<strong>Http11NioProtocol</strong> 。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">	   <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-Adapter适配器"><a href="#4-Adapter适配器" class="headerlink" title="4. Adapter适配器"></a>4. Adapter适配器</h4><p>​    Tomcat定义了自己的Request类来“存放”各种各样的请求信息，前面讲到的ProtocolHandler解析请求，然后生成Tomcat的Requst类，但是容器中需要的是ServletRequest对象。</p>
<p>​    Tomcat解决方案：<strong>引入CoyoteAdapter，这是适配器模式的经典运用，连接器调用CoyoteAdapter的Sevice方法，传入的是Tomcat Request对象，CoyoteAdapter负责将Tomcat Request转成ServletRequest，再调用容器的Service方法。</strong></p>
<p>​    <strong>功能：将协议处理器解析出的Tomcat Request对象，适配成ServletRequest，再调用ServletRequest的Service方法，同理容器给的ServletResponse转换成Response。</strong></p>
<h3 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3. 线程池"></a>3. 线程池</h3><p>​    Tomcat的线程池，是在连接器Connector部分的用到的，下图是Tomcat线程池的执行流程</p>
<p><img src="https://img-blog.csdnimg.cn/2020092609410712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>监听：</p>
<ul>
<li>LimitLatch（类似于JUC里面的信号量Semaphore）：顾名思义，是用来限流的，用来控制最大的连接数，防止服务器被压垮。</li>
<li>Acceptor 只负责 <strong>接收新的Socket连接</strong>，本质就是个线程，<strong>一直死循环执行监听Socket连接</strong>。</li>
<li>Poller也是个线程，也是一直<strong>死循环监听SocketChannel通道</strong>是否有 <strong>可读的I/O事件（现在是服务器端，所以读就是浏览器传数据过来）</strong>，发现有，则将其<strong>封装成任务对象socketProcessor</strong>，交给线程池处理。</li>
</ul>
<p>处理：</p>
<ul>
<li>Executor线程池中的 <strong>worker工作线程最终负责 处理请求。</strong></li>
</ul>
<h2 id="四、Catalina容器"><a href="#四、Catalina容器" class="headerlink" title="四、Catalina容器"></a>四、Catalina容器</h2><p>​    Catalina 是<strong>Servlet 容器</strong>实现，包含了之前讲到的所有的容器组件。</p>
<p><img src="https://img-blog.csdnimg.cn/20200920203139521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​    Tomcat <strong>本质上就是一款 Servlet 容器， 因此Catalina 才是 Tomcat 的核心</strong> ， 其他模块都是为Catalina 提供支撑的。 比如 ： 通过Coyote 模块提供链接通信，Jasper 模块提供JSP引擎。其实在Tomcat源码中也有体现：</p>
<p>​    在java.org.apache包下</p>
<p><img src="https://img-blog.csdnimg.cn/2020092020341380.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="1-Catalina结构"><a href="#1-Catalina结构" class="headerlink" title="1. Catalina结构"></a>1. Catalina结构</h3><p>​    Catalina的主要组件结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200920203553904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​    Catalina管理这Server，而Server是表示整个服务器的，每个Server下面都有很多个Service服务，每个服务都包含着多个连接器组件Connector（Coyote实现的）和一个容器组件Container。<strong>在Tomcat启动时，就会初始化一个Catalina的实例。</strong></p>
<p>​    <strong>总结：所以Servlet容器Catalina = 1个Server（Server下面有多个Service，每个Service下面又有多个连接器Connector + 容器Container）</strong></p>
<h3 id="2-Catalina组件"><a href="#2-Catalina组件" class="headerlink" title="2. Catalina组件"></a>2. Catalina组件</h3><p><img src="https://img-blog.csdnimg.cn/2020091819140267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​    Catalina容器各个组件的功能：</p>
<ul>
<li>Catalina：负责<strong>解析Tomcat的配置文件</strong> , 以此来创建服务器Server组件，并根据命令来对其进行管理</li>
<li>Server：整个Catalina Servlet容器以及其它组件，负责组装并<strong>启动</strong>Servlet引擎,Tomcat连接器。Server通过实现Lifecycle接口，<strong>提供了一种优雅的启动和关闭整个系统的方式（职责链模式）</strong></li>
<li>Service：服务是Server内部的组件，一个Server包含多个Service。它将<strong>若干个Connector组件绑定到一个Container（Engine）上（多个连接器 —— 一个容器）</strong></li>
<li>Connector：处理与客户端的通信，它负责<strong>监听接收客户请求</strong>，然后转给相关的容器处理，最后向客户返回响应结果</li>
<li>Container：负责<strong>处理</strong>用户的servlet请求，并返回对象给web用户的模块</li>
</ul>
<h3 id="3-Container容器"><a href="#3-Container容器" class="headerlink" title="3. Container容器"></a>3. Container容器</h3><p>​    Tomcat设计了4种容器：分别是<strong>Engine，Host，Context 和 Wrapper（Container是他们的盖称）。但是这四种容器是父子继承关系，</strong>Tomcat通过一种分层的架构，使得Servlet容器具有很好的灵活性：</p>
<p><img src="https://img-blog.csdnimg.cn/20200921101120269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​    Container各个组件的含义 ：</p>
<ul>
<li><p>Engine：Catalina的<strong>Servlet引擎</strong>，来管理多个虚拟的主机，每个Service一个Engine，但是<strong>可以包含多个虚拟主机Host</strong></p>
</li>
<li><p>Host：代表一个虚拟主机，或者说一个站点，可以<strong>给Tomcat配置多个虚拟主机地址</strong>，而一个虚拟主机下可包含多个Context</p>
</li>
<li><p>Context：表示一个<strong>Web应用程序</strong>， 一个Web应用可包含多个Wrapper</p>
</li>
<li><p>Wrapper：Servlet的别名，Wrapper 作为容器中的最底层，不能包含子容器</p>
</li>
</ul>
<h3 id="4-server-xml结构"><a href="#4-server-xml结构" class="headerlink" title="4. server.xml结构"></a>4. server.xml结构</h3>  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Service</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connector</span>&gt;</span>......<span class="tag">&lt;/<span class="name">connector</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">        <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">context</span>&gt;</span>......<span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">        <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们也可以再通过Tomcat的<code>server.xml</code>配置文件来加深对Tomcat容器的理解。<strong>Tomcat采用了组件化的设计，它的构成组件都是可配置的，其中最外层的是Server，其他组件按照一定的格式要求配置在这个顶层容器中。</strong>Tomcat用<strong>组合模式</strong>来管理这些容器的。</p>
<p><img src="https://img-blog.csdnimg.cn/20200918154546877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​    具体实现方法是，所有<strong>容器组件都实现了Container接口</strong>，因此组合模式可以使得用户对Wrapper和Context、Host或者Engine的使用具有一致性。</p>
<p>​    Container接口扩展了LifeCycle接口，LifeCycle接口用来统一管理各组件的生命周期.</p>
<p><img src="https://img-blog.csdnimg.cn/20200921102631201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="五、Tomcat启动流程"><a href="#五、Tomcat启动流程" class="headerlink" title="五、Tomcat启动流程"></a>五、Tomcat启动流程</h2><h3 id="1-启动流程分析"><a href="#1-启动流程分析" class="headerlink" title="1. 启动流程分析"></a>1. 启动流程分析</h3><p>​    前面我们已经讲到<strong>Tomcat的启动入口Bootstrap（来创建Catalina实例）</strong>、Shell程序Catalina的以及各个组件的关系。</p>
<p><img src="https://img-blog.csdnimg.cn/20200921105356690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>所以Tomcat的启动步骤：</p>
<p>（1）启动Tomcat，需要调用的是<strong><code>bin</code>路径下面的<code>startup.bat</code>（linux是<code>startup.sh</code>），启动脚本后调用了<code>Catalina.bat</code></strong></p>
<p><strong>（2）在<code>Catalina.bat</code>脚本中是调用了Bootstrap里面的main方法。</strong></p>
<p>（3）main方法调用<code>init</code>方法来<strong>初始化Catalina和类加载器。</strong></p>
<p>（4）main方法然后调用<code>load</code>方法，在其中<strong>调用Catalina的load方法。</strong></p>
<p><strong>（5）Catalina的load需要对组件进行初始化，这时就要用到里面的一个内部类Digester对象来解析server.xml</strong></p>
<p>（6）然后调用<strong>后序组件的init初始化操作</strong>，加载Tomcat的配置文件，初始化容器组件，监听端口号，准备接受客户端的请求。</p>
<h3 id="2-Lifecycle"><a href="#2-Lifecycle" class="headerlink" title="2. Lifecycle"></a>2. Lifecycle</h3><p>​    二、Tomcat总体架构 中，我们提到了Lifecycle这个接口，因为组件均存在初始化、启动、停止等生命周期方法，所以要拥有生命周期管理</p>
<p>包括组件 Server、Service、Container、Executor、Connector，都实现了一个生命周期的接口，从而具有了以下生命周期中的核心方法：</p>
<p><img src="https://img-blog.csdnimg.cn/20200921123816792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="3-组件的默认实现"><a href="#3-组件的默认实现" class="headerlink" title="3. 组件的默认实现"></a>3. 组件的默认实现</h3><p>​    对于Endpoint而言，Tomcat没有对应的Endpoint接口，但有一个抽象类AbstractEndpoint，有NioEndpoint、 Nio2Endpoint、AprEndpoint，分别对应着Coyote连接器中支持的三种IO模型：NIO、NIO2、APR，默认是NioEndpoint。</p>
<p><img src="https://img-blog.csdnimg.cn/2020092112435134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​    ProtocolHandler ： Coyote协议接口，通过<strong>封装Endpoint和Processor</strong> ， 实现针对具体协议的处理功能。Tomcat按照协议和IO提供了6个实现类。</p>
<p><strong>注意：实际上Tomcat的默认组件 = ProtocolHandler默认实现（例如Http11NioProtocol） + Standard组件（例如StandardServer、StandardEngine、StandardContext）</strong></p>
<p>1）    AjpNioProtocol ：采用NIO的IO模型。<br>2）    AjpNio2Protocol：采用NIO2的IO模型。<br>3）    AjpAprProtocol ：采用APR的IO模型，需要依赖于APR库。</p>
<p>1）    Http11NioProtocol ：采用NIO的IO模型，默认使用的协议（如果服务器没有安装APR）。<br>2）    Http11Nio2Protocol：采用NIO2的IO模型。<br>3）    Http11AprProtocol ：采用APR的IO模型，需要依赖于APR库。</p>
<p><img src="https://img-blog.csdnimg.cn/20200921124509867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="4-源码解析"><a href="#4-源码解析" class="headerlink" title="4. 源码解析"></a>4. 源码解析</h3><p>​    分析源码先从启动脚本<code>startup.bat</code>开始分析</p>
<p>（1）<code>startup.bat</code>实际上是调用的<strong>catalina的启动脚本</strong><code>catalina.bat</code></p>
<p><img src="https://img-blog.csdnimg.cn/20200921110801598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>（2）在<code>catalina.bat</code>中调用的是<strong>BootStrap的Main方法</strong>，MainClass：BootStrap —-&gt; main(String[] args)，所以我们去看源码</p>
<p><img src="https://img-blog.csdnimg.cn/20200921110930288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="1-BootStrap启动类"><a href="#1-BootStrap启动类" class="headerlink" title="1. BootStrap启动类"></a>1. BootStrap启动类</h4><p>​    查看Tomcat的源代码：BootStrap先进行init方法，然后<strong>通过反射创建Catalina对象和调用load方法，实际上是Catalina的load方法，对组件进行初始化，都是通过反射执行。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main method and entry point when starting Tomcat via the provided</span></span><br><span class="line"><span class="comment"> * scripts.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args Command line arguments to be processed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (daemon == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Don't set daemon until init() has completed</span></span><br><span class="line">        <span class="comment">//1. 先初始化Bootstrap对象，调用init方法</span></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2.通过反射创建了一个Catalina对象</span></span><br><span class="line">            bootstrap.init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">/*...................................................................*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        daemon = bootstrap;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*...................................................................*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 命令参数</span></span><br><span class="line">        String command = <span class="string">"start"</span>;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            command = args[args.length - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*...................................................................*/</span></span><br><span class="line">        <span class="comment">// 如果是启动（start）</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">"start"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 3.进入此，调用bootstrap的load和start方法</span></span><br><span class="line">            daemon.setAwait(<span class="keyword">true</span>);</span><br><span class="line">        	<span class="comment">//调用load方法，对组件进行初始化</span></span><br><span class="line">            daemon.load(args);</span><br><span class="line">            daemon.start();</span><br><span class="line">            <span class="comment">/*...................................................................*/</span></span><br><span class="line">        &#125; </span><br><span class="line">    	<span class="comment">/*...................................................................*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Load daemon.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(String[] arguments)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the load() method</span></span><br><span class="line">    String methodName = <span class="string">"load"</span>;</span><br><span class="line">    Object param[];</span><br><span class="line">    Class&lt;?&gt; paramTypes[];</span><br><span class="line">    <span class="keyword">if</span> (arguments==<span class="keyword">null</span> || arguments.length==<span class="number">0</span>) &#123;</span><br><span class="line">        paramTypes = <span class="keyword">null</span>;</span><br><span class="line">        param = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        paramTypes = <span class="keyword">new</span> Class[<span class="number">1</span>];</span><br><span class="line">        paramTypes[<span class="number">0</span>] = arguments.getClass();</span><br><span class="line">        param = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">        param[<span class="number">0</span>] = arguments;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过反射执行Catalina的load方法</span></span><br><span class="line">    Method method =</span><br><span class="line">        catalinaDaemon.getClass().getMethod(methodName, paramTypes);</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">        log.debug(<span class="string">"Calling startup class "</span> + method);</span><br><span class="line">    <span class="comment">// methodName是load</span></span><br><span class="line">    <span class="comment">// 4.调用catalina的load方法</span></span><br><span class="line">    method.invoke(catalinaDaemon, param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Catalina类load方法"><a href="#2-Catalina类load方法" class="headerlink" title="2. Catalina类load方法"></a>2. Catalina类load方法</h4><p>​    直接进入Catalina类的load方法：<strong>先是通过Digerster解析核心的配置文件（因为这样才能去加载Server后面的组件）</strong>，然后调用<strong>Server的init，然后逐级init。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Start a new server instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*...................................................................*/</span></span><br><span class="line">    <span class="comment">// Before digester - it may be needed</span></span><br><span class="line">    initNaming();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create and execute our Digester</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Digester是Tomcat的XML配置文件解析工具</span></span><br><span class="line">    <span class="comment">// 5.使用Digester去解析server.xml</span></span><br><span class="line">    Digester digester = createStartDigester();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...................................................................*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the new server</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 6.调用server的init方法</span></span><br><span class="line">        getServer().init();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">        <span class="comment">/*...................................................................*/</span></span><br><span class="line">    &#125;</span><br><span class="line">       <span class="comment">/*...................................................................*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-组件的init初始化"><a href="#3-组件的init初始化" class="headerlink" title="3.组件的init初始化"></a>3.组件的init初始化</h4><p>​    组件们在实现类中，都是调用了<strong>Standard组件名 或者是Standard组件名 的initInternal。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Invoke a pre-startup initialization. This is used to allow connectors</span></span><br><span class="line"><span class="comment">* to bind to restricted ports under Unix operating environments.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line">	<span class="comment">/*...................................................................*/</span></span><br><span class="line">    <span class="comment">// Initialize our defined Services</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; services.length; i++) &#123;</span><br><span class="line">        <span class="comment">// services进行初始化</span></span><br><span class="line">        services[i].init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在Service的实现类里面也是用到了模板方法设计模式，<strong>调用initInternal()，然后初始化了engine、executor、connector。</strong></p>
<p><strong>然后Engine再去初始化后序的host，context，Connector再去初始化后序的Adapter、ProtocolHandler的init，然后继续下去EndPoint的init。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoke a pre-startup initialization. This is used to allow connectors</span></span><br><span class="line"><span class="comment"> * to bind to restricted ports under Unix operating environments.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (engine != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用engine的init方法</span></span><br><span class="line">        engine.init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize any Executors</span></span><br><span class="line">        <span class="keyword">for</span> (Executor executor : findExecutors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> JmxEnabled) &#123;</span><br><span class="line">                ((JmxEnabled) executor).setDomain(getDomain());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 线程池</span></span><br><span class="line">            executor.init();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize mapper listener</span></span><br><span class="line">        mapperListener.init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize our defined Connectors</span></span><br><span class="line">        <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Connector connector : connectors) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// connector的init</span></span><br><span class="line">                    connector.init();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    String message = sm.getString(</span><br><span class="line">                        <span class="string">"standardService.connector.initFailed"</span>, connector);</span><br><span class="line">                    log.error(message, e);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">"org.apache.catalina.startup.EXIT_ON_INIT_FAILURE"</span>))</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-组件的start启动"><a href="#4-组件的start启动" class="headerlink" title="4. 组件的start启动"></a>4. 组件的start启动</h4><p>​    当Bootstrap启动类的init以及后序组件的init初始化后，Bootstrap启动类再调用start方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.进入此，调用bootstrap的load和start方法</span></span><br><span class="line">daemon.setAwait(<span class="keyword">true</span>);</span><br><span class="line">daemon.load(args);</span><br><span class="line">daemon.start();</span><br></pre></td></tr></table></figure>

<p>​    Server和Service都是<strong>调用了StandardServer或者是StandardService的initInternal或者startInternal</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200921131520488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200921131516209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="5-启动总结"><a href="#5-启动总结" class="headerlink" title="5. 启动总结"></a>5. 启动总结</h3><p>​    从启动流程图中以及源码中，我们可以看出Tomcat的启动过程<strong>非常标准化</strong>， 统一按照生命周期管理接口Lifecycle的定义进行启动。首先<strong>调用init() 方法进行组件的逐级初始化操作</strong>，然后<strong>再调用start()方法</strong>进行启动。</p>
<p>​    <strong>每一级的组件除了完成自身的处理外，还要负责调用子组件响应的生命周期管理方法，组件与组件之间是松耦合的，因为我们可以很容易的通过配置文件进行修改和替换。</strong></p>
<h2 id="六、Tomcat请求处理流程（执行）"><a href="#六、Tomcat请求处理流程（执行）" class="headerlink" title="六、Tomcat请求处理流程（执行）"></a>六、Tomcat请求处理流程（执行）</h2><p>​    Tomcat的层次很多，那么<strong>确定每一个请求应该由哪个Wrapper容器里的Servlet来处理，</strong>这就是一个问题。也就是<strong>连接器生成的servletrequest是如何找到容器中对应的servlet来处理，Tomcat是用Mapper组件来完成这个任务的。</strong></p>
<h3 id="1-Mapper组件"><a href="#1-Mapper组件" class="headerlink" title="1. Mapper组件"></a>1. Mapper组件</h3><p>Mapper组件里保存了Web应用的配置信息，其实就是<strong>容器组件与请求URL里的域名和路径的映射关系</strong>，比如Host容器里配置的域名、Context容器里的Web应用路径，以及Wrapper容器里Servlet映射的路径，你可以想象这些配置信息就是一个多层次的Map。</p>
<p>​    下面的示意图中，就描述了当用户请求链接 <a href="http://www.itcast.cn/bbs/findAll" target="_blank" rel="noopener">http://www.itcast.cn/bbs/findAll</a> 之后, 是如何找到最终处理业务逻辑的servlet。</p>
<p>​    <strong>通过端口8080确定是Http请求，根据对应的IO类型，从而确定连接器，然后通过域名host找到对应的引擎（虚拟主机），引擎下面同时对应appbase（context的路径）：即webapps，进入对应的context里面的web.xml中，通过映射关系找到对应的Wrapper，然后构造过滤器链FilterChain，执行每个Filter，最后转换成Servlet。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200921154320931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2-请求处理流程分析"><a href="#2-请求处理流程分析" class="headerlink" title="2. 请求处理流程分析"></a>2. 请求处理流程分析</h3><p><img src="https://img-blog.csdnimg.cn/20200921154521460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>步骤如下：</p>
<p>1)    Connector组件Endpoint中的<strong>Acceptor监听客户端Socket连接并接收Socket</strong>。将连接交给线程池Executor处理，开始执行请求响应任务。<strong>Processor组件读取消息报文，解析请求行、请求体、请求头，封装成Request对象。</strong><br>2)    CoyoteAdaptor适配器组件<strong>负责将Connector组件和Engine容器关联起来</strong>，把Processor生成的Request生成对应的ServletRequset传递到Engine容器中，调用 Pipeline。<br>3)    Mapper组件根据<strong>请求行的URL值和请求头的Host值匹配由哪个Host容器、Context容器、Wrapper容器处理请求。</strong><br>4)    Engine容器的管道开始处理，管道中包含若干个Valve、每个Valve负责部分处理逻辑。执行完Valve后会执行<strong>基础的Valve–StandardEngineValve，负责调用Host容器的Pipeline。</strong>Host、Context、Wrapper容器流程类似，最后执行Wrapper容器对应的Servlet对象的处理方法<br>5)    构造一个过滤器链FilterChain，然后执行各个Filter，<strong>最后执行Servlet.service()</strong>。</p>
<h3 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h3><p><img src="https://img-blog.csdnimg.cn/20200924202559435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>1）发起请求后，Tomcat的NioEndpoint中的Acceptor就会监听到Socket连接，然后<strong>调用内部维护的线程池Executor的executor方法执行请求。</strong>executor方法会调用Processor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">extends</span> <span class="title">AbstractEndpoint</span>.<span class="title">Acceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*............................................................*/</span></span><br><span class="line">        SocketChannel socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Accept the next incoming connection from the server</span></span><br><span class="line">            <span class="comment">// serverSock为ServerSocketChannel类型</span></span><br><span class="line">            socket = serverSock.accept();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            <span class="comment">// We didn't get a socket</span></span><br><span class="line">            countDownConnection();</span><br><span class="line">            <span class="keyword">if</span> (running) &#123;</span><br><span class="line">                <span class="comment">// Introduce delay if necessary</span></span><br><span class="line">                errorDelay = handleExceptionWithDelay(errorDelay);</span><br><span class="line">                <span class="comment">// re-throw</span></span><br><span class="line">                <span class="keyword">throw</span> ioe;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Successful accept, reset the error delay</span></span><br><span class="line">        errorDelay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Configure the socket</span></span><br><span class="line">        <span class="keyword">if</span> (running &amp;&amp; !paused) &#123;</span><br><span class="line">            <span class="comment">// setSocketOptions() will hand the socket off to</span></span><br><span class="line">            <span class="comment">// an appropriate processor if successful</span></span><br><span class="line">            <span class="keyword">if</span> (!setSocketOptions(socket)) &#123;</span><br><span class="line">                closeSocket(socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            closeSocket(socket);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        log.error(sm.getString(<span class="string">"endpoint.accept.fail"</span>), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">state = AcceptorState.ENDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketProcessor</span> <span class="keyword">extends</span> <span class="title">SocketProcessorBase</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketProcessor</span><span class="params">(SocketWrapperBase&lt;NioChannel&gt; socketWrapper, SocketEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(socketWrapper, event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        NioChannel socket = socketWrapper.getSocket();</span><br><span class="line">        SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 请求之前的确认握手操作</span></span><br><span class="line">            <span class="keyword">int</span> handshake = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (socket.isHandshakeComplete()) &#123;</span><br><span class="line">                        <span class="comment">// No TLS handshaking required. Let the handler</span></span><br><span class="line">                        <span class="comment">// process this socket / event combination.</span></span><br><span class="line">                        handshake = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event == SocketEvent.STOP || event == SocketEvent.DISCONNECT ||</span><br><span class="line">                            event == SocketEvent.ERROR) &#123;</span><br><span class="line">                        <span class="comment">// Unable to complete the TLS handshake. Treat it as</span></span><br><span class="line">                        <span class="comment">// if the handshake failed.</span></span><br><span class="line">                        handshake = -<span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        handshake = socket.handshake(key.isReadable(), key.isWritable());</span><br><span class="line">                        <span class="comment">// The handshake process reads/writes from/to the</span></span><br><span class="line">                        <span class="comment">// socket. status may therefore be OPEN_WRITE once</span></span><br><span class="line">                        <span class="comment">// the handshake completes. However, the handshake</span></span><br><span class="line">                        <span class="comment">// happens when the socket is opened so the status</span></span><br><span class="line">                        <span class="comment">// must always be OPEN_READ after it completes. It</span></span><br><span class="line">                        <span class="comment">// is OK to always set this as it is only used if</span></span><br><span class="line">                        <span class="comment">// the handshake completes.</span></span><br><span class="line">                        event = SocketEvent.OPEN_READ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                handshake = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) log.debug(<span class="string">"Error during SSL handshake"</span>,x);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancelledKeyException ckx) &#123;</span><br><span class="line">                handshake = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (handshake == <span class="number">0</span>) &#123;</span><br><span class="line">                SocketState state = SocketState.OPEN;</span><br><span class="line">                <span class="comment">// Process the request from this socket</span></span><br><span class="line">                <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 请求的处理，执行Processor的process方法</span></span><br><span class="line">                    state = getHandler().process(socketWrapper, SocketEvent.OPEN_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    state = getHandler().process(socketWrapper, event);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (state == SocketState.CLOSED) &#123;</span><br><span class="line">                    close(socket, key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handshake == -<span class="number">1</span> ) &#123;</span><br><span class="line">                close(socket, key);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handshake == SelectionKey.OP_READ)&#123;</span><br><span class="line">                socketWrapper.registerReadInterest();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handshake == SelectionKey.OP_WRITE)&#123;</span><br><span class="line">                socketWrapper.registerWriteInterest();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException cx) &#123;</span><br><span class="line">            socket.getPoller().cancelledKey(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (VirtualMachineError vme) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(vme);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            log.error(<span class="string">""</span>, t);</span><br><span class="line">            socket.getPoller().cancelledKey(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            socketWrapper = <span class="keyword">null</span>;</span><br><span class="line">            event = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//return to cache</span></span><br><span class="line">            <span class="keyword">if</span> (running &amp;&amp; !paused) &#123;</span><br><span class="line">                processorCache.push(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）Processor组件处理Http请求，<strong>解析Socket请求，</strong>读取消息报文，解析请求行、请求体、请求头，封装成Request对象。</p>
<p>处理完后，<strong>调用CoyoteAdapter的Service方法</strong>，把刚才解析的request和response传进去</p>
<p><img src="https://img-blog.csdnimg.cn/20200924200834691.png#pic_center" alt="在这里插入图片描述"></p>
<p>3）到了CoyoteAdapter的Service方法，<strong>调用容器</strong><code>connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);</code></p>
<p><img src="https://img-blog.csdnimg.cn/20200924201216428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(org.apache.coyote.Request req, org.apache.coyote.Response res)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    Request request = (Request) req.getNote(ADAPTER_NOTES);</span><br><span class="line">    Response response = (Response) res.getNote(ADAPTER_NOTES);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Create objects</span></span><br><span class="line">        request = connector.createRequest();</span><br><span class="line">        request.setCoyoteRequest(req);</span><br><span class="line">        response = connector.createResponse();</span><br><span class="line">        response.setCoyoteResponse(res);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Link objects</span></span><br><span class="line">        request.setResponse(response);</span><br><span class="line">        response.setRequest(request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set as notes</span></span><br><span class="line">        req.setNote(ADAPTER_NOTES, request);</span><br><span class="line">        res.setNote(ADAPTER_NOTES, response);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set query string encoding</span></span><br><span class="line">        req.getParameters().setQueryStringCharset(connector.getURICharset());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connector.getXpoweredBy()) &#123;</span><br><span class="line">        response.addHeader(<span class="string">"X-Powered-By"</span>, POWERED_BY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> async = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> postParseSuccess = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    req.getRequestProcessor().setWorkerThreadName(THREAD_NAME.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Parse and set Catalina and configuration specific</span></span><br><span class="line">        <span class="comment">// request parameters</span></span><br><span class="line">        postParseSuccess = postParseRequest(req, request, res, response);</span><br><span class="line">        <span class="keyword">if</span> (postParseSuccess) &#123;</span><br><span class="line">            <span class="comment">//check valves if we support async</span></span><br><span class="line">            request.setAsyncSupported(</span><br><span class="line">                connector.getService().getContainer().getPipeline().isAsyncSupported());</span><br><span class="line">            <span class="comment">// Calling the container</span></span><br><span class="line">            connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">                request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (request.isAsync()) &#123;</span><br><span class="line">            async = <span class="keyword">true</span>;</span><br><span class="line">            ReadListener readListener = req.getReadListener();</span><br><span class="line">            <span class="keyword">if</span> (readListener != <span class="keyword">null</span> &amp;&amp; request.isFinished()) &#123;</span><br><span class="line">                <span class="comment">// Possible the all data may have been read during service()</span></span><br><span class="line">                <span class="comment">// method so this needs to be checked here</span></span><br><span class="line">                ClassLoader oldCL = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    oldCL = request.getContext().bind(<span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (req.sendAllDataReadEvent()) &#123;</span><br><span class="line">                        req.getReadListener().onAllDataRead();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    request.getContext().unbind(<span class="keyword">false</span>, oldCL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Throwable throwable =</span><br><span class="line">                (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If an async request was started, is not going to end once</span></span><br><span class="line">            <span class="comment">// this container thread finishes and an error occurred, trigger</span></span><br><span class="line">            <span class="comment">// the async error process</span></span><br><span class="line">            <span class="keyword">if</span> (!request.isAsyncCompleting() &amp;&amp; throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                request.getAsyncContextInternal().setErrorState(throwable, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            request.finishRequest();</span><br><span class="line">            response.finishResponse();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// Ignore</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        AtomicBoolean error = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">        res.action(ActionCode.IS_ERROR, error);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (request.isAsyncCompleting() &amp;&amp; error.get()) &#123;</span><br><span class="line">            <span class="comment">// Connection will be forcibly closed which will prevent</span></span><br><span class="line">            <span class="comment">// completion happening at the usual point. Need to trigger</span></span><br><span class="line">            <span class="comment">// call to onComplete() here.</span></span><br><span class="line">            res.action(ActionCode.ASYNC_POST_PROCESS,  <span class="keyword">null</span>);</span><br><span class="line">            async = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Access log</span></span><br><span class="line">        <span class="keyword">if</span> (!async &amp;&amp; postParseSuccess) &#123;</span><br><span class="line">            <span class="comment">// Log only if processing was invoked.</span></span><br><span class="line">            <span class="comment">// If postParseRequest() failed, it has already logged it.</span></span><br><span class="line">            Context context = request.getContext();</span><br><span class="line">            Host host = request.getHost();</span><br><span class="line">            <span class="comment">// If the context is null, it is likely that the endpoint was</span></span><br><span class="line">            <span class="comment">// shutdown, this connection closed and the request recycled in</span></span><br><span class="line">            <span class="comment">// a different thread. That thread will have updated the access</span></span><br><span class="line">            <span class="comment">// log so it is OK not to update the access log here in that</span></span><br><span class="line">            <span class="comment">// case.</span></span><br><span class="line">            <span class="comment">// The other possibility is that an error occurred early in</span></span><br><span class="line">            <span class="comment">// processing and the request could not be mapped to a Context.</span></span><br><span class="line">            <span class="comment">// Log via the host or engine in that case.</span></span><br><span class="line">            <span class="keyword">long</span> time = System.currentTimeMillis() - req.getStartTime();</span><br><span class="line">            <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">                context.logAccess(request, response, time, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response.isError()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (host != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    host.logAccess(request, response, time, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    connector.getService().getContainer().logAccess(</span><br><span class="line">                        request, response, time, <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        req.getRequestProcessor().setWorkerThreadName(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recycle the wrapper request and response</span></span><br><span class="line">        <span class="keyword">if</span> (!async) &#123;</span><br><span class="line">            updateWrapperErrorCount(request, response);</span><br><span class="line">            request.recycle();</span><br><span class="line">            response.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）<strong>engine后序的组件Host、Context、Wrapper都是先拿到管道</strong>，再getFirst拿到valve阀（因为是头插法式的add）</p>
<p><img src="https://img-blog.csdnimg.cn/20200924201344221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/202009242018347.png#pic_center" alt="在这里插入图片描述"></p>
<p>​    <strong>都是调用对应StandardXXX的invoke方法</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200924201639141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>5）最后执行Wrapper容器对应的allocate处理方法，<strong>拿到Servlet对象</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200924202004914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​    Tomcat中的各个组件各司其职，组件之间松耦合，Tomcat中定义了Pipeline 和 Valve 两个接口，Pipeline 用于构建责任链，<strong>只需要调用第一个处理器，它就会依次执行。</strong></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">rnang0</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://rnang0.github.io/2020/09/11/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A09%EF%BC%9ATomcat%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/">http://rnang0.github.io/2020/09/11/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A09%EF%BC%9ATomcat%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://rnang0.github.io" target="_blank">rnang0 Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Tomcat/">Tomcat</a><a class="post-meta__tags" href="/tags/Servlet/">Servlet</a></div><div class="post_share"><div class="social-share" data-image="https://miro.medium.com/max/2000/1*DnnkReGamr7ps_2HlGT_FQ.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/09/27/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A011%EF%BC%9ANetty%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%E5%92%8C%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"><img class="prev_cover" src="https://cdn.ancii.com/article/image/v1/nE/Qq/OF/FOQEqnhn2Rw1d5AwR24pT2LlooHdjhpn6K0JbGh90PzK0wFg4C9Lp5SgO0pMclQTgY5O0s4_rdAkQE8EOQw0wjw1OokU9wUOoT1Uz6nV9wg.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">春招复习10：Netty底层机制</div></div></a></div><div class="next-post pull_right"><a href="/2020/08/03/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A08%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98/"><img class="next_cover" src="https://www.lgstatic.com/i/image2/M01/8A/CA/CgoB5l14rXSAWVk7AAFdi6Ly8iM148.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">春招复习8：数据库与缓存</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By rnang0</div><div class="footer_custom_text">Hi, welcome to my <a href="http://rnang0.github.io/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script></body></html>