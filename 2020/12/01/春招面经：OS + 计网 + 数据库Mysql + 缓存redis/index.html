<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>春招面经：OS + 计网 + 数据库Mysql + 缓存redis | rnang0 Blog</title><meta name="description" content="OS + 计网 + 数据库Mysql + 缓存redis一、OS1. 进程与线程的区别 进程是资源CPU分配的基本单位，而线程则是调度的基本单位，可以看做是进程中的一条执行流程。 进程拥有完整的资源平台，而线程则只独享必不可少的资源，例如寄存器、栈。所以线程能减少并发执行的时间、空间开销。 进程切换要涉及到用户态与内核态之间的切换，还要管理资源信息、内存空间信息（页面的切换），而线程则不需要。 进"><meta name="keywords" content="进/线程,内存管理,TCP/IP,HTTP/HTTPS,缓存,索引"><meta name="author" content="rnang0"><meta name="copyright" content="rnang0"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="春招面经：OS + 计网 + 数据库Mysql + 缓存redis"><meta name="twitter:description" content="OS + 计网 + 数据库Mysql + 缓存redis一、OS1. 进程与线程的区别 进程是资源CPU分配的基本单位，而线程则是调度的基本单位，可以看做是进程中的一条执行流程。 进程拥有完整的资源平台，而线程则只独享必不可少的资源，例如寄存器、栈。所以线程能减少并发执行的时间、空间开销。 进程切换要涉及到用户态与内核态之间的切换，还要管理资源信息、内存空间信息（页面的切换），而线程则不需要。 进"><meta name="twitter:image" content="https://img-blog.csdnimg.cn/20201228092946817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70"><meta property="og:type" content="article"><meta property="og:title" content="春招面经：OS + 计网 + 数据库Mysql + 缓存redis"><meta property="og:url" content="http://rnang0.github.io/2020/12/01/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%EF%BC%9AOS%20+%20%E8%AE%A1%E7%BD%91%20+%20%E6%95%B0%E6%8D%AE%E5%BA%93Mysql%20+%20%E7%BC%93%E5%AD%98redis/"><meta property="og:site_name" content="rnang0 Blog"><meta property="og:description" content="OS + 计网 + 数据库Mysql + 缓存redis一、OS1. 进程与线程的区别 进程是资源CPU分配的基本单位，而线程则是调度的基本单位，可以看做是进程中的一条执行流程。 进程拥有完整的资源平台，而线程则只独享必不可少的资源，例如寄存器、栈。所以线程能减少并发执行的时间、空间开销。 进程切换要涉及到用户态与内核态之间的切换，还要管理资源信息、内存空间信息（页面的切换），而线程则不需要。 进"><meta property="og:image" content="https://img-blog.csdnimg.cn/20201228092946817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70"><meta property="article:published_time" content="2020-11-30T16:00:00.000Z"><meta property="article:modified_time" content="2021-03-03T11:48:19.808Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="canonical" href="http://rnang0.github.io/2020/12/01/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%EF%BC%9AOS%20+%20%E8%AE%A1%E7%BD%91%20+%20%E6%95%B0%E6%8D%AE%E5%BA%93Mysql%20+%20%E7%BC%93%E5%AD%98redis/"><link rel="prev" title="春招面经：Java集合类" href="http://rnang0.github.io/2020/12/13/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%EF%BC%9AJava%E9%9B%86%E5%90%88%E7%B1%BB/"><link rel="next" title="leetcode刷题总结（持续更新...）" href="http://rnang0.github.io/2020/11/30/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0%EF%BC%9Aleetcode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'none',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/autor.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">23</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">41</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-mars"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#OS-计网-数据库Mysql-缓存redis"><span class="toc-text">OS + 计网 + 数据库Mysql + 缓存redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、OS"><span class="toc-text">一、OS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-进程与线程的区别"><span class="toc-text">1. 进程与线程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-作业调度算法"><span class="toc-text">2. 作业调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-进程间通信"><span class="toc-text">3. 进程间通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-死锁条件"><span class="toc-text">4. 死锁条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-分段分页、缺页调度"><span class="toc-text">5. 分段分页、缺页调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-磁盘调度"><span class="toc-text">6. 磁盘调度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、计网"><span class="toc-text">二、计网</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#应用层：Http"><span class="toc-text">应用层：Http</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Http常见状态码？常见字段？"><span class="toc-text">1. Http常见状态码？常见字段？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Get与Post方式有什么区别？"><span class="toc-text">2. Get与Post方式有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-说一说Http的无状态与长，短连接吧！"><span class="toc-text">3. 说一说Http的无状态与长，短连接吧！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-能说说Http1-0与1-1与Http2的演变过程及其区别？"><span class="toc-text">4.能说说Http1.0与1.1与Http2的演变过程及其区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-能说说Http与Https的区别吗？"><span class="toc-text">5. 能说说Http与Https的区别吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Https加密过程"><span class="toc-text">6. Https加密过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#传输层：TCP、UDP"><span class="toc-text">传输层：TCP、UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-TCP头部结构"><span class="toc-text">1. TCP头部结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-UDP与TCP的区别"><span class="toc-text">2. UDP与TCP的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-为什么是三次握手，不是两次？四次？"><span class="toc-text">3. 为什么是三次握手，不是两次？四次？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-为什么握手是三次，挥手却是四次？"><span class="toc-text">4. 为什么握手是三次，挥手却是四次？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-说一下TCP-超时重传与快速重传"><span class="toc-text">5. 说一下TCP 超时重传与快速重传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-说一说TCP的流量控制以及滑动窗口吧"><span class="toc-text">6. 说一说TCP的流量控制以及滑动窗口吧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-流量控制有哪些问题？"><span class="toc-text">7. 流量控制有哪些问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-为什么TCP设置拥塞控制？不是已经有了流量控制嘛？"><span class="toc-text">8. 为什么TCP设置拥塞控制？不是已经有了流量控制嘛？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#"><span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#综合面试题：能说一说键入网址后，期间发生了什么？"><span class="toc-text">综合面试题：能说一说键入网址后，期间发生了什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、DB（Mysql）"><span class="toc-text">三、DB（Mysql）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-说一说事务的四大特性有哪些？"><span class="toc-text">1. 说一说事务的四大特性有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-能说一说事务的隔离级别嘛？"><span class="toc-text">2. 能说一说事务的隔离级别嘛？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-说一说Mysql表结构存储引擎种类，以及它们的不同吧"><span class="toc-text">3. 说一说Mysql表结构存储引擎种类，以及它们的不同吧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Mysql为什么选取B-树作为索引？"><span class="toc-text">4. Mysql为什么选取B+树作为索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-说一说数据库的三范式吧"><span class="toc-text">5. 说一说数据库的三范式吧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-说一说你理解的Mysql主从复制吧"><span class="toc-text">6. 说一说你理解的Mysql主从复制吧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-能说一说常见的数据库优化方式嘛？"><span class="toc-text">7. 能说一说常见的数据库优化方式嘛？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、缓存（redis）"><span class="toc-text">四、缓存（redis）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Redis中有哪些数据结构？"><span class="toc-text">1. Redis中有哪些数据结构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-能说一说Redis中缓存淘汰策略嘛？"><span class="toc-text">2. 能说一说Redis中缓存淘汰策略嘛？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Redis的数据过期策略有哪些？"><span class="toc-text">3. Redis的数据过期策略有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Redis如何实现与数据库一致性？"><span class="toc-text">4. Redis如何实现与数据库一致性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-说一说缓存击穿、缓存穿透、缓存雪崩的区别以及解决办法吧"><span class="toc-text">5. 说一说缓存击穿、缓存穿透、缓存雪崩的区别以及解决办法吧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-说一说Redis中的持久化"><span class="toc-text">6. 说一说Redis中的持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-说说Redis中的哨兵模式吧"><span class="toc-text">7. 说说Redis中的哨兵模式吧</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://img-blog.csdnimg.cn/20201228092946817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">rnang0 Blog</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-mars"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">春招面经：OS + 计网 + 数据库Mysql + 缓存redis</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-12-01 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-12-01</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-03-03 19:48:19"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-03-03</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E7%BB%8F/">面经</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="OS-计网-数据库Mysql-缓存redis"><a href="#OS-计网-数据库Mysql-缓存redis" class="headerlink" title="OS + 计网 + 数据库Mysql + 缓存redis"></a>OS + 计网 + 数据库Mysql + 缓存redis</h1><h2 id="一、OS"><a href="#一、OS" class="headerlink" title="一、OS"></a>一、OS</h2><h3 id="1-进程与线程的区别"><a href="#1-进程与线程的区别" class="headerlink" title="1. 进程与线程的区别"></a>1. 进程与线程的区别</h3><ul>
<li>进程是资源CPU分配的基本单位，<strong>而线程则是调度的基本单位，可以看做是进程中的一条执行流程。</strong></li>
<li>进程拥有完整的资源平台，而<strong>线程则只独享必不可少的资源</strong>，例如寄存器、栈。<strong>所以线程能减少并发执行的时间、空间开销。</strong></li>
<li><strong>进程切换要涉及到用户态与内核态之间的切换</strong>，还要<strong>管理资源信息、内存空间信息（页面的切换），而线程则不需要。</strong></li>
<li><strong>进程的创建与撤销开销比线程大很多（管理内存空间、I/O设备）</strong></li>
</ul>
<h3 id="2-作业调度算法"><a href="#2-作业调度算法" class="headerlink" title="2. 作业调度算法"></a>2. 作业调度算法</h3><p>​    作业调度算法主要分为两类：<strong>非抢占式调度 和 抢占式调度。</strong></p>
<p>非抢占式：一个线程被调度运行完后，才会运行下一个线程，期间一直被阻塞。</p>
<p>抢占式调度：一个线程执行过程中，<strong>时间片用完</strong>发生中断调度下一个线程运行。</p>
<ul>
<li><p>先来先服务：最基本的算法，非抢占式的，<strong>有利于长作业。</strong></p>
</li>
<li><p>短作业优先：顾名思义，<strong>利于短作业，长作业可能会长期等待。</strong></p>
</li>
<li><p><strong>高响应比优先：兼顾了长短作业，要求服务时间少 + 等待时间长（分别对应短作业和长作业）会优先执行。</strong></p>
</li>
<li><p>时间片轮转：每个线程分配相同时间片，执行完后调度下一个。</p>
</li>
<li><p>优先级调度：顾名思义，选择最高的优先级进行调度，<strong>一般是动态优先级，等待时间长的线程优先级就增加，防止永远等待。</strong></p>
</li>
<li><p>多级反馈队列调度算法：基于<strong>最高优先级 + 时间片轮转算法</strong></p>
<p>（1）维护多个优先级队列：<strong>优先级越高，时间越短</strong></p>
<p>（2）<strong>调度按照优先级调度，如果时间片结束未执行完线程，则加入后面队列的尾部，</strong>等待调度，以此类推</p>
<p><strong>兼顾了长短作业，有较好的响应时间。</strong></p>
</li>
</ul>
<h3 id="3-进程间通信"><a href="#3-进程间通信" class="headerlink" title="3. 进程间通信"></a>3. 进程间通信</h3><p>（1）等价于不同进程下的线程通信，同进程下<strong>线程直接通信，更多关注锁（例如信号量）实现多线程共享资源的同步互斥问题。</strong></p>
<p><strong>（2）进程内存地址都是独立的，只有内核空间是进程共享的，所以进程间通信、数据传输都需要经过内核态。</strong></p>
<ul>
<li><strong>管道：</strong>管道是一种<strong>半双工</strong>的，<strong>数据只能单向流动的（固定大小字节流）尾部写，头部读。</strong></li>
</ul>
<p>​    主要分为两类：管道（匿名管道）、命名管道，区别就是：<strong>管道用完就销毁，并且只能具有父子关系的进程调用，而命名管道一直存在，且允许非父子关系的进程通信。</strong></p>
<p><strong>特点：效率低，不适应频繁交换。</strong></p>
<ul>
<li><strong>消息队列：</strong>保存在<code>内核中</code>的消息链表，它分成了一个个<strong>独立的数据块（有类型、大小），这与无格式字节流的管道相区别。</strong></li>
</ul>
<p><strong>特点：通信不是实时性、会进行数据拷贝，涉及到用户态和内核态的数据拷贝开销。</strong></p>
<ul>
<li><strong>共享内存：</strong>用共享内存的方法，<strong>解决了消息队列的数据拷贝开销大的问题，不涉及到用户态与内核态的切换。</strong></li>
</ul>
<p><strong>原理：两个进程拿一块虚拟内存，映射到相同的物理内存（两进程相互独立，其余虚拟内存就算虚拟地址相同都不映射到一块物理内存）</strong></p>
<ul>
<li><strong>信号量：</strong>实质就是一个整数型的<strong>计数器</strong>，<strong>P、V原语操作来实现进程间互斥与同步。</strong></li>
</ul>
<p>一般使用 <strong>信号量 + 共享内存</strong> 来实现同步通信。</p>
<ul>
<li><strong>信号：</strong><code>kill</code><strong>通知接受进程已经发生</strong>，所以它是一个<strong>异步通信</strong>；进程也可以发送信号给自己本身。</li>
<li><strong>Socket套接字：</strong><code>不同主机</code>上的跨网络的进程通信，通过绑定IP和端口，来实现数据传输。</li>
</ul>
<h3 id="4-死锁条件"><a href="#4-死锁条件" class="headerlink" title="4. 死锁条件"></a>4. 死锁条件</h3><ul>
<li><strong>资源进行互斥等待</strong></li>
<li><strong>资源不可被抢占</strong></li>
<li><strong>保持并等待（阻塞不放弃自己资源）</strong></li>
<li><strong>循环等待（相互等待其释放资源）</strong></li>
</ul>
<h3 id="5-分段分页、缺页调度"><a href="#5-分段分页、缺页调度" class="headerlink" title="5. 分段分页、缺页调度"></a>5. 分段分页、缺页调度</h3><ul>
<li><strong>虚拟内存</strong></li>
</ul>
<p>​    每个进程操作的都是<strong>独有的地址空间（虚拟地址）</strong>，不直接控制访问物理内存。</p>
<p>​    如何管理？如何映射到物理内存？这就需要<code>分段和分页</code>来映射到物理内存上。</p>
<p><img src="https://img-blog.csdnimg.cn/20201220104353560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><strong>分段</strong></li>
</ul>
<p>​    分段是<strong>内存连续</strong>存储，将虚拟内存进行逻辑分段，例如代码段、栈段、数据段、堆段</p>
<p><img src="https://img-blog.csdnimg.cn/20201220104502690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>如何映射到物理内存？通过段表：虚拟内存是 <code>段号 + 段内偏移</code> 。通过<strong>段号</strong>去<code>段表</code>查段的起始地址。</p>
<p>​    <strong>缺点：1. 产生内存碎片化问题，外部碎片大  2. 交换效率低，碎片太多，且段内存大换入换出频繁出现卡顿。</strong></p>
<ul>
<li><strong>分页</strong></li>
</ul>
<p>​    分页是把虚拟内存以及物理内存切成一个个<strong>固定大小（4KB）的页</strong>，同理<code>页表</code>进行映射：<code>页号 + 偏移地址</code>。</p>
<p>​    <strong>当页表中查询不到页号对应的基地址时，会产生缺页中断，进行缺页调度。</strong></p>
<p><strong>分页好处：</strong></p>
<p>（1）释放内存<strong>以页为单位释放</strong>，所以就<strong>不会产生外部碎片化问题</strong>，但内部会有碎片。</p>
<p>（2）交换效率高。进程中由于局部性原理，<strong>不会一次性申请全部内存</strong>，需要时再申请，从磁盘中换入，<strong>所以页表就只有很少的页数，交换效率高。</strong></p>
<p>​    简单分页的话，<strong>由于页大小很小，所以个数很多，页表很大，所以引出多级页表来分散。</strong></p>
<p><strong>多级页表：</strong></p>
<p>​    <strong>如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20201220105717114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>快表（TLB）：</strong>多级页表<strong>多次转换，需要的时间开销比较大</strong>，根据程序的局部性，所以就每次把<strong>经常访问的</strong>那几页放到TLB（页表缓存、块表中）。</p>
<p><strong>即每次查询，就先查TLB，再去页表查。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20201220110046394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><strong>段页式</strong></li>
</ul>
<p>通常OS，都是段页式一起使用。</p>
<ol>
<li>先将程序化成逻辑上的段</li>
<li>再把每个段分成页</li>
</ol>
<p>地址结构：<strong>段号 + 段内页号 + 页内偏移。</strong></p>
<ul>
<li><strong>缺页调度算法</strong></li>
</ul>
<ol>
<li>先来先出</li>
<li>最优置换（理论）</li>
<li><strong>最近最少使用（LRU）</strong></li>
<li>时钟算法（二次机会改进）</li>
</ol>
<h3 id="6-磁盘调度"><a href="#6-磁盘调度" class="headerlink" title="6. 磁盘调度"></a>6. 磁盘调度</h3><ul>
<li>先来先服务</li>
<li><strong>最短寻道优先</strong></li>
<li>扫描算法</li>
<li>循环扫描算法</li>
</ul>
<h2 id="二、计网"><a href="#二、计网" class="headerlink" title="二、计网"></a>二、计网</h2><h3 id="应用层：Http"><a href="#应用层：Http" class="headerlink" title="应用层：Http"></a>应用层：Http</h3><h3 id="1-Http常见状态码？常见字段？"><a href="#1-Http常见状态码？常见字段？" class="headerlink" title="1. Http常见状态码？常见字段？"></a>1. Http常见状态码？常见字段？</h3><ul>
<li><strong>常见状态码：</strong></li>
</ul>
<p>​    除了那些常见200,404,500服务器内部错误。</p>
<p>​    就是<code>3xx</code> 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p>
<ul>
<li><strong>常见字段：</strong></li>
</ul>
<p>​    <em>Host</em>：主机地址，客户端发送请求时，用来指定<strong>服务器的域名。</strong></p>
<p>​    <em>Content-Length 字段</em>：服务器在返回数据时，会有 <code>Content-Length</code> 字段，表明本次回应的数据长度。</p>
<p>​    <em>Connection 字段</em>：<code>Connection</code> 字段最常用于客户端<strong>要求服务器使用 TCP 持久连接，以便其他请求复用。</strong></p>
<p>注意：HTTP/<strong>1.1 默认连接都是持久连接</strong>，但为了兼容老版本的 1.0，扔需要指定为 <code>Keep-Alive</code>。</p>
<p>​    <em>Content-Type 字段</em>:<code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p>
<h3 id="2-Get与Post方式有什么区别？"><a href="#2-Get与Post方式有什么区别？" class="headerlink" title="2. Get与Post方式有什么区别？"></a>2. Get与Post方式有什么区别？</h3><p>​    <code>Get</code> 方法的含义是请求<strong>从服务器获取资源</strong>，服务器就会<strong>返回文章的所有文字及资源。</strong></p>
<p>​    <code>Post</code>方法的含义恰恰相反，它向 <code>URI</code> 指定的资源<strong>提交</strong>数据，<strong>数据就放在报文的 body 里。（为了数据传输安全）</strong></p>
<ul>
<li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</li>
<li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</li>
</ul>
<p><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。</p>
<p><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。</p>
<ul>
<li>对于 get 方式的请求，浏览器会把 <code>header 和 data</code> 一并发送出去，服务器响应 200（返回数据）</li>
<li>对于 post，<strong>浏览器先发送 header，服务器响应 100</strong> continue，浏览器再发送 data（确认安全），服务器响应 200 ok（返回数据）。</li>
</ul>
<h3 id="3-说一说Http的无状态与长，短连接吧！"><a href="#3-说一说Http的无状态与长，短连接吧！" class="headerlink" title="3. 说一说Http的无状态与长，短连接吧！"></a>3. 说一说Http的无状态与长，短连接吧！</h3><ul>
<li><strong>无状态：浏览器对于事务的处理没有记忆能力</strong>。</li>
</ul>
<p>​    状态记录的作用的是一个叫做 <code>小甜饼(Cookie)</code> 的机制。它能够让浏览器具有<code>记忆</code>能力。每<strong>次会话开始时服务器建立一个会话级别的cookie对象，接下来客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie信息（包含 sessionId ）</strong>， 然后，服务器读取请求头中的 Cookie 信息，来判断用户信息。</p>
<ul>
<li><strong>长连接、短连接</strong></li>
</ul>
<p>​    <code>Http1.0是短连接</code>，<strong>每次发出请求，都需要新建一次 TCP 连接（三次握手）。</strong></p>
<p>​    <code>HTTP/1.1 提出了流水线的长连接</code>的通信方式，<strong>未提出断开连接，就保持 TCP 连接状态。</strong>这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p>
<p><img src="https://img-blog.csdnimg.cn/20201221192944216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="4-能说说Http1-0与1-1与Http2的演变过程及其区别？"><a href="#4-能说说Http1-0与1-1与Http2的演变过程及其区别？" class="headerlink" title="4.能说说Http1.0与1.1与Http2的演变过程及其区别？"></a>4.能说说Http1.0与1.1与Http2的演变过程及其区别？</h3><ul>
<li><strong>Http1.0 -&gt; Http1.1：</strong></li>
</ul>
<p>Http1.0的短连接，规定浏览器与服务器只保持短暂的连接，浏览器的<strong>每次请求</strong>都需要与服务器建立一个TCP连接（一次请求就挥手握手）。Http1.1的长连接，但是为了兼容旧版本，需要显式指明。在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。<strong>采用了流水线的持久连接，即客户端不用等待上一次请求结果返回，就可以发出下一次请求。</strong></p>
<p><strong>Http1.0不支持Host请求头字段</strong>，WEB浏览器无法使用主机头名来明确表示要访问服务器上的哪个WEB站点。它认为一个服务器就绑定一个站点。Http1.1增加<strong>Host请求头字段后</strong>，在一台WEB服务器上可以在<strong>同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。</strong></p>
<p>Http1.1<strong>带宽优化</strong>，不再返回额外的对象信息，且提供了<strong>Cache缓存</strong>等机制的请求头和响应头。</p>
<ul>
<li><strong>Http1.1-&gt;Http2:</strong></li>
</ul>
<p><strong>Http1.1头部字段信息没有压缩，信息太大</strong>，而body却小的情况，故Http2中进行了<strong>头部压缩，提高速度。</strong></p>
<p>Http1.1报文中的信息都是采取了ASCII码，而<strong>Http2.0报文中的信息改为二进制格式，称为帧，这种形式对传输速率很高，无需解析报文。</strong></p>
<p>Http2.0基本上都是跑在Https上的，<strong>安全性高。</strong></p>
<p>Http2.0采取了<strong>多路复用</strong>，连接上多个请求，<strong>无需每个请求都绑定个连接。</strong></p>
<h3 id="5-能说说Http与Https的区别吗？"><a href="#5-能说说Http与Https的区别吗？" class="headerlink" title="5. 能说说Http与Https的区别吗？"></a>5. 能说说Http与Https的区别吗？</h3><p>（1）<strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</p>
<p>（2）<strong>非对称加密</strong>使用两个密钥：公钥和私钥，<strong>公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</strong></p>
<ul>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。<strong>而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</strong></li>
<li>HTTP信息是明文传输，存在安全风险的问题。HTTPS 也就是<strong>在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，使得报文能够加密传输。</strong>通过 <strong>密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法</strong> 能够解决上面这些问题。</li>
<li>HTTPS在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li>
<li>HTTP 的默认端口是 80，而 HTTPS 的默认端口是 443。</li>
</ul>
<h3 id="6-Https加密过程"><a href="#6-Https加密过程" class="headerlink" title="6. Https加密过程"></a>6. Https加密过程</h3><ul>
<li><p>客户端向服务器发起请求（带上随机数1），服务器对客户端进行回应（带上随机数2），并带上自己的SSL证书</p>
</li>
<li><p><strong>客户端会对证书进行校验</strong>（内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发 ）</p>
</li>
<li><p>校验无问题后<strong>取出公钥，再产生一个随机数，使用三个随机数结合生成对称密钥</strong>，用对称密钥来对称加密内容，并用公钥非对称加密对称密钥后，一起发送给服务器。</p>
</li>
<li><p>服务器<strong>用私钥解密就能得到对称密钥</strong>，两者之后就一直使用这个对称密钥对信息进行加密通信。</p>
</li>
</ul>
<h3 id="传输层：TCP、UDP"><a href="#传输层：TCP、UDP" class="headerlink" title="传输层：TCP、UDP"></a>传输层：TCP、UDP</h3><h3 id="1-TCP头部结构"><a href="#1-TCP头部结构" class="headerlink" title="1. TCP头部结构"></a>1. TCP头部结构</h3><p>​    除了源端口和目的端口外，还有最重要的<strong>序号、确认号、一些标记位等。</strong></p>
<ul>
<li><strong>序号：seq</strong>：每发送一次就加1，用来<strong>解决网络包乱序。</strong></li>
<li><strong>确认号：ack</strong>：<strong>下次希望收到的序列号，主要方便发送方下次发送，解决不丢包的问题</strong>。</li>
<li><strong>标记位：</strong><ul>
<li><strong>ACK：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</strong></li>
<li><strong>SYC：发送请求通讯，建立连接时，一般来回为1</strong></li>
</ul>
</li>
</ul>
<h3 id="2-UDP与TCP的区别"><a href="#2-UDP与TCP的区别" class="headerlink" title="2. UDP与TCP的区别"></a>2. UDP与TCP的区别</h3><ul>
<li><strong>TCP是面向连接的；UDP是无连接</strong>，发送前无需连接，但可以用connect指定只与这台主机交互。</li>
</ul>
<p><strong>连接：有保证<code>可靠性</code>和<code>流量控制</code>的状态信息，有Socket、序列号、窗口大小。</strong></p>
<ul>
<li><strong>TCP是一对一的；</strong>而UDP可以支持一对一，一对多，多对多通信。</li>
<li><strong>TCP是面向字节流的，把数据看做一长串字符流；</strong>而<strong>UDP则是面向报文</strong>的。</li>
<li><strong>TCP是可靠的，</strong>数据保证无差错，不丢失，不重复；而<strong>UDP是不保证可靠性的。</strong></li>
<li><strong>TCP拥有拥塞控制以及流量控制机制；</strong>而UDP则是无论如何拥堵依旧保持一样的发送速率。</li>
<li><strong>TCP头部较长，开销大，</strong>且长度可变；而UDP头部较小固定8字节，开销小。</li>
</ul>
<h3 id="3-为什么是三次握手，不是两次？四次？"><a href="#3-为什么是三次握手，不是两次？四次？" class="headerlink" title="3. 为什么是三次握手，不是两次？四次？"></a>3. 为什么是三次握手，不是两次？四次？</h3><ul>
<li>握手目的：</li>
</ul>
<p>建立<strong>TCP连接，</strong>即<strong>初始化Socket、序列号、滑动窗口的大小。</strong></p>
<ul>
<li><strong>三次握手过程：</strong></li>
</ul>
<p>（1）开始client是close阶段，server端是监听listen阶段。</p>
<p>然后client会<strong>随机一个序列号seq</strong>，放入TCP，<strong>将其SYN标志位置1</strong>，表示发送SYN报文，client处于SYN-SENT（发送阶段）</p>
<p>（2）server收到client<code>SYN报文</code>，初始化自己的<strong>序列号seq=y</strong>，填入到TCP头部里，<strong>将ACK和SYN置为1，确认号为x+1,</strong>将报文发给client，自己处于SYN-RCVD阶段。（接受到阶段）</p>
<p>（3）client端收到server端报文，然后发送应答报文，将TCP头部<strong>SYN、ACK置为1</strong>，将<strong>确认号ack为y+1（服务器端传过来是y）</strong>，然后seq是x+1，加1。</p>
<p><strong>注意：第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong></p>
<ul>
<li><strong>为什么握手不是两次？</strong></li>
</ul>
<p><strong>（1）原因是为了防止旧的重复连接初始化造成混乱。</strong></p>
<p>​    client发送多个连接请求，可能<strong>先发送的比后发送的先到达，于是client端根据上下文判断该序列化过期，或者超时，会发送RST报文，终止。</strong></p>
<p>​    <strong>如果是两次握手连接，就不能判断当前连接是否是历史连接</strong>，client第三次报文时，有足够的上下文来判断，根据情况返回。</p>
<p><strong>（2）不能保证同步双方初始序列号</strong></p>
<p>​    <strong>通信时，必须维护好双方的序列号（去重，按序接收，判断是否被接收）。</strong></p>
<p>​    两次握手只保证了<strong>服务器端的初始序列号能被对方成功接收</strong>，没办法保证双方的初始序列号都能被确认接收。</p>
<p><strong>（3）会造成重复建立连接，资源浪费</strong></p>
<p>​    因为TCP有<code>超时重发</code>机制，<strong>旧请求不阻塞了，到达了服务器端，则服务器重复接受无用的 <code>SYN</code> 报文，而造成重复分配资源，浪费资源。</strong>    </p>
<ul>
<li><strong>为什么不是四次？</strong></li>
</ul>
<p><strong>三次握手就能保证连接建立，四次则优化成三次。</strong></p>
<h3 id="4-为什么握手是三次，挥手却是四次？"><a href="#4-为什么握手是三次，挥手却是四次？" class="headerlink" title="4. 为什么握手是三次，挥手却是四次？"></a>4. 为什么握手是三次，挥手却是四次？</h3><ul>
<li>挥手目的：</li>
</ul>
<p>很形象，挥手代表着<strong>断开连接。</strong></p>
<ul>
<li><strong>挥手过程：</strong></li>
</ul>
<p>任何一方都可以主动的断开连接，<strong>即需要四次，一方关闭然后另一方同意，然后另一方再发断开，一方再同意。</strong></p>
<p>（1）client打算关闭连接，然后发送了<code>FIN报文</code>，FIN = 1，序列号seq = x，进入<code>FIN_WAIT</code>状态。</p>
<p>（2）服务器端收到client的关闭连接，然后发送<code>ACK应答</code>，ACK = 1，ack = x + 1，seq = y，进入<code>CLOSED_WAIT</code>。<strong>client端进入FIN_WAIT2状态。</strong></p>
<p><strong>（3）服务器端处理完数据，然后再向client发送FIN报文，</strong>FIN = 1, seq = z，ACK = 1, <strong>ack = x + 1，</strong>服务器端进入LAST_ACK状态。</p>
<p>（4）client端收到<code>FIN报文</code>，<strong>回一个ACK应答，ACK = 1,ack = z + 1，seq = x + 1，进入 <code>TIME_WAIT</code> 状态，</strong>然后<strong>服务器收到ACK，进入CLOSE状态。</strong></p>
<p>​    <strong>客户端经过2MSL时间，自动进入CLOSE状态。</strong></p>
<ul>
<li>为什么挥手是四次？</li>
</ul>
<p>​    经过上面的过程可知，服务器收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文。应答方（接收挥手的一方）<code>ACK</code> 和 <code>FIN</code> 一般都会分开发送。</p>
<p>​    <strong>而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</strong></p>
<ul>
<li>为什么 TIME_WAIT 等待的时间是 2MSL？</li>
</ul>
<p>​    <code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
<p>​    <strong>最后一次挥手可能丢失，超时，server端会重新发一次第三次挥手的FIN报文，然后client端再回复ACK。</strong>所以<strong>一来一回需要等待 2 MSL的时间</strong>。</p>
<h3 id="5-说一下TCP-超时重传与快速重传"><a href="#5-说一下TCP-超时重传与快速重传" class="headerlink" title="5. 说一下TCP 超时重传与快速重传"></a>5. 说一下TCP 超时重传与快速重传</h3><ul>
<li>可靠性保证：</li>
</ul>
<p>​    TCP 是通过<strong>序列号、确认应答、超时重发、连接管理以及滑动窗口</strong>等机制实现可靠性传输的。</p>
<ul>
<li><strong>超时重传</strong></li>
</ul>
<p>​    TCP <strong>针对数据包丢失</strong>的情况，会用重传机制解决。</p>
<p>发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p>
<p><strong>可能的情况：（1）发送数据丢包；（2）确认应答ACK丢失</strong></p>
<ul>
<li><strong>快速重传</strong></li>
</ul>
<p>快速重传就不是以时间来定夺，而是<strong>几次接受到同一个ACK</strong>，因为有一个请求发送未到达发生丢包，后几次响应返回相同的ACK。</p>
<p><img src="https://img-blog.csdnimg.cn/20201226093011107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="6-说一说TCP的流量控制以及滑动窗口吧"><a href="#6-说一说TCP的流量控制以及滑动窗口吧" class="headerlink" title="6. 说一说TCP的流量控制以及滑动窗口吧"></a>6. 说一说TCP的流量控制以及滑动窗口吧</h3><ul>
<li><strong>流量控制</strong></li>
</ul>
<p>​    发送方不能无脑一直发送数据，因为接收方不一定能够处理的过来，会导致一直<code>超时重发</code>。</p>
<p><strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</strong></p>
<p>​    发送方每次收到接收方的确认消息，<strong>都会根据确认号，挪动窗口的相应位置，使得窗口内出现新的未发送字节</strong>，同时接收方还会<strong>返回现在滑动窗口的大小来限制发送方的发送速度。</strong></p>
<ul>
<li><strong>滑动窗口</strong></li>
</ul>
<p>​    TCP 引入了<strong>窗口</strong>这个概念，解决数据包的<strong>往返时间越长，通信的效率就越低</strong>的问题。</p>
<p>（1）窗口大小：无需等待确认应答，一次性发送数据的最大值，<strong>以字节为单位。</strong></p>
<p>​    窗口实际上是OS开辟的一个<strong>缓存空间</strong>，发送方&lt;=接收方，并且OS会一直调整。</p>
<p><strong>（2）累积应答：</strong>图中的 ACK 600 确认应答报文丢失，也没关系，因为只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫<strong>累计确认</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20201226094312379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>（3）接收方滑动窗口</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20201226094505803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="7-流量控制有哪些问题？"><a href="#7-流量控制有哪些问题？" class="headerlink" title="7. 流量控制有哪些问题？"></a>7. 流量控制有哪些问题？</h3><ul>
<li><strong>糊涂窗口综合征</strong></li>
</ul>
<p>因为发送方每次<strong>发送的包都很小</strong>，接收方刚腾出一点空间，让发送方开个小窗口，由于窗口小就只能发送很少的数据。这样每次发送数据少，且由于<strong>数据头部40个字节的固定开销存在</strong>，导致发送速度更慢，所以针对某一遍性能差有两种解决思路。</p>
<p>所以解决方式：</p>
<p>（1）<strong>避免发送方发送小窗口</strong></p>
<p>强制<strong>不发送小数据，囤积数据</strong>，满足一定大小条件才发送。</p>
<p>（2）<strong>避免接收方不通告小窗口</strong>给发送方</p>
<p>这个还是比较好想的，当 <code>窗口大小 &lt; Min（一个报文长度，缓存空间 / 2）</code>时就<strong>给发送方通告窗口为0。</strong></p>
<h3 id="8-为什么TCP设置拥塞控制？不是已经有了流量控制嘛？"><a href="#8-为什么TCP设置拥塞控制？不是已经有了流量控制嘛？" class="headerlink" title="8. 为什么TCP设置拥塞控制？不是已经有了流量控制嘛？"></a>8. 为什么TCP设置拥塞控制？不是已经有了流量控制嘛？</h3><p>​    目的：<strong>避免发送方的数据填满整个网络通信</strong>，在发送方调节要发送数据的量。</p>
<p>​    <strong>与流量控制的区别：流量控制是避免发送方的数据填满接收方的缓存（窗口）。</strong></p>
<p><strong>拥塞窗口 cwnd</strong> = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</p>
<p>​    拥塞控制主要是四个算法：</p>
<ul>
<li><strong>慢启动：</strong></li>
</ul>
<p>​    <strong>一点一点的提高发送数据包的数量，每返回一个ACK，cwnd就增加1，当到达门限时就退出慢启动。</strong></p>
<ul>
<li><strong>拥塞避免：</strong></li>
</ul>
<p>​    <strong>每当收到一个 ACK 时，cwnd 增加 1/cwnd。</strong></p>
<ul>
<li><strong>拥塞发生：</strong></li>
</ul>
<p>​    出现丢包现象，这时就需要<strong>对丢失的数据包进行重传。</strong>当触发了重传机制，也就进入了「拥塞发生算法」。</p>
<ol>
<li><strong>超时重传：将门限设置为原来1/2，窗口重置为1。（太抖了，不用）</strong></li>
</ol>
<p><strong>突然减少数据流，然后一般会造成网络卡顿。</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeuicRMlA8rKvl5AVLibhibDhgDicBugvroe9EtiaFU38hk4JuVfDciauVPfecBNp8TPI1zkoqbibePA4dlg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ol start="2">
<li><strong>快速重传</strong></li>
</ol>
<p><strong>与超时重传区别是，窗口设置为原先的1/2，然后门限也是现在的窗口。</strong></p>
<ul>
<li><strong>快速恢复：</strong></li>
</ul>
<p>一般跟快速重传一起使用，<strong>还能收到3个相同的ACK，不那么糟糕，则窗口设置为门限 + 3，重传丢失的，进入拥塞避免状态。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20201226154013631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="综合面试题：能说一说键入网址后，期间发生了什么？"><a href="#综合面试题：能说一说键入网址后，期间发生了什么？" class="headerlink" title="综合面试题：能说一说键入网址后，期间发生了什么？"></a>综合面试题：能说一说键入网址后，期间发生了什么？</h3><p>总结：</p>
<p><img src="https://img-blog.csdnimg.cn/20201227095024612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>一个数据包的心路历程：</p>
<ul>
<li><strong>HTTP</strong></li>
</ul>
<p><strong>对url进行解析，生成Http请求报文</strong>，确定了Web服务器和文件名。</p>
<ul>
<li><strong>DNS域名解析：指路不带路</strong></li>
</ul>
<p><strong>查询服务器域名对应的 IP 地址，</strong>顶级DNS服务器（com）。。。</p>
<ul>
<li><strong>TCP进行可靠传输</strong></li>
</ul>
<p>DNS获取到IP后，就可以把<strong>Http报文的传输工作</strong>交给OS的协议栈。</p>
<img src="https://img-blog.csdnimg.cn/20201226191001600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 80%;" />

<p>​    程序通过<strong>调用 Socket 库</strong>，来委托协议栈工作。<strong>HTTP 是基于 TCP 协议传输的</strong>，TCP 传输数据之前，要先三次握手建立连接来<strong>保证双方都有发送和接收的能力</strong>。然后生成报文进行传输。</p>
<p>​    <strong>TCP报文</strong>包括<code>先前生成的HTTP报文头 + 数据</code> 进行组装。</p>
<p><img src="https://img-blog.csdnimg.cn/20201226213915138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><strong>IP进行远程定位</strong></li>
</ul>
<p>​    TCP在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成<strong>网络包</strong>发送给通信对象，即加了一层IP头部。</p>
<ul>
<li><strong>MAC协议进行两点的传输</strong></li>
</ul>
<p>需要通过<code>ARP</code>协议帮助我们知道<strong>对方的路由器MAC地址。</strong>ARP 协议会在以太网中以<strong>广播</strong>的形式获取到。</p>
<ul>
<li><strong>网卡进行数据的物理传输</strong></li>
</ul>
<p>​    网卡驱动从 IP 模块获取到包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p>
<p><strong>能在交换机和路由器的转发下，抵达到了目的地。</strong></p>
<h2 id="三、DB（Mysql）"><a href="#三、DB（Mysql）" class="headerlink" title="三、DB（Mysql）"></a>三、DB（Mysql）</h2><h3 id="1-说一说事务的四大特性有哪些？"><a href="#1-说一说事务的四大特性有哪些？" class="headerlink" title="1. 说一说事务的四大特性有哪些？"></a>1. 说一说事务的四大特性有哪些？</h3><p>​    事务主要是四大特性，ACID</p>
<p>​    总结：原子性和持久性是通过<strong>日志恢复（undo log，redo log）</strong>实现；隔离性是通过<strong>并发控制（锁）</strong>来实现的，而原子性、隔离性、持久性巩固实现一致性。</p>
<ul>
<li><strong>原子性（Atomicity）</strong></li>
<li><strong>一致性（Consistency）</strong></li>
<li><strong>隔离性（Isolation）</strong></li>
<li><strong>持久性（Durability）</strong></li>
</ul>
<h3 id="2-能说一说事务的隔离级别嘛？"><a href="#2-能说一说事务的隔离级别嘛？" class="headerlink" title="2. 能说一说事务的隔离级别嘛？"></a>2. 能说一说事务的隔离级别嘛？</h3><p>​    因为<strong>完全的隔离性会导致并发的性能很低，所以我们一般把事务隔离级别从低到高划分：</strong></p>
<p><strong>读未提交Read uncommitted:</strong> 读写锁均在<strong>操作完成后</strong>立即释放。</p>
<p><strong>读已提交Read committed:</strong> 防止脏读。<strong>读锁在读完成后</strong>立即释放，<strong>写锁持续到事务结束</strong>释放。Oracle和sql server的默认隔离等级。</p>
<p><strong>可重复读Repeatable read: （Mysql默认）</strong>防止脏读、不可重复读。读写锁均<strong>持续到事务结束释放。</strong></p>
<p><strong>串行化Serializable: 防止脏读、不可重复读和幻读。不再锁定行，而是</strong>锁定表。直接将表操作串行。</p>
<p><img src="https://img-blog.csdnimg.cn/20200323180645368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTg5NzM4,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="3-说一说Mysql表结构存储引擎种类，以及它们的不同吧"><a href="#3-说一说Mysql表结构存储引擎种类，以及它们的不同吧" class="headerlink" title="3. 说一说Mysql表结构存储引擎种类，以及它们的不同吧"></a>3. 说一说Mysql表结构存储引擎种类，以及它们的不同吧</h3><p>​    主要是两种引擎，MyIsam和InnoDB：</p>
<ul>
<li>MyIsam不支持事务、外键，仅支持表级锁。<strong>适合执行大量的select和insert</strong>。</li>
<li>InnoDB支持事务、外键，支持表级锁和行级锁。如果表中既无主键也无索引，将自动创建一个隐藏主键列。<strong>适合执行大量的delete和update，适合大尺寸数据库。</strong></li>
</ul>
<p>​    不同之处主要就是：</p>
<ol>
<li><strong>MyIsam不支持事务，而InnoDB是支持事务的。</strong></li>
<li><strong>MyIsam是非聚集索引</strong>，<code>索引和数据文件</code>是分离的(非聚集)，<strong>每个叶子节点存储的都是数据的磁盘指针</strong>；<strong>InnoDB是聚集索引</strong>，表数据文件本身就是按<code>B+Tree</code>组织的一个索引结构文件。</li>
<li><strong>InnoDB表必须有主键，并且推荐使用整型的自增主键</strong>，B+树有序，插入数据方便，并且范围查找高效。</li>
</ol>
<h3 id="4-Mysql为什么选取B-树作为索引？"><a href="#4-Mysql为什么选取B-树作为索引？" class="headerlink" title="4. Mysql为什么选取B+树作为索引？"></a>4. Mysql为什么选取B+树作为索引？</h3><p><img src="https://img-blog.csdnimg.cn/20200323125011779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTg5NzM4,size_16,color_FFFFFF,t_70" alt=""></p>
<ul>
<li><strong>非叶子节点不存储data,只存储索引(冗余)</strong>，可以放更多的索引。</li>
<li><strong>叶子节点包含所有索引字段，且节点索引依次递增。</strong></li>
<li><strong>叶子节点用指针连接</strong>，提高<strong>区间访问</strong>的性能。</li>
</ul>
<h3 id="5-说一说数据库的三范式吧"><a href="#5-说一说数据库的三范式吧" class="headerlink" title="5. 说一说数据库的三范式吧"></a>5. 说一说数据库的三范式吧</h3><ul>
<li><p>1NF</p>
<p>数据库表的每一列都是不可分割的原子数据项，例如不能出现学生字段，数据为“张三 男 18岁”。</p>
</li>
<li><p>2NF</p>
<p>在1NF的基础上，<strong>非主键字段完全依赖于主键</strong>。</p>
</li>
<li><p>3NF</p>
<p>在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上<strong>消除传递依赖</strong>）</p>
</li>
</ul>
<h3 id="6-说一说你理解的Mysql主从复制吧"><a href="#6-说一说你理解的Mysql主从复制吧" class="headerlink" title="6. 说一说你理解的Mysql主从复制吧"></a>6. 说一说你理解的Mysql主从复制吧</h3><ul>
<li><strong>作用：</strong></li>
</ul>
<ol>
<li><strong>数据热备</strong></li>
<li>多库存储，<strong>读写分离</strong></li>
</ol>
<ul>
<li><strong>步骤：</strong></li>
</ul>
<ol>
<li>主数据库操作，<strong>sql语句写入数据库的同时，写入binlog二进制文件</strong>，主要是一些SQL语句（写库，所以是增删改）。</li>
<li>主库通过<strong>I/O线程</strong>发送binlog，<strong>写入至从库replay log</strong></li>
<li><strong>从库执行SQL线程将replay log，写入至从库的bin log data中。</strong></li>
</ol>
<p><img src="https://img-blog.csdn.net/2018041911065697?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhcmtBbmdlbDEyMjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<h3 id="7-能说一说常见的数据库优化方式嘛？"><a href="#7-能说一说常见的数据库优化方式嘛？" class="headerlink" title="7. 能说一说常见的数据库优化方式嘛？"></a>7. 能说一说常见的数据库优化方式嘛？</h3><ul>
<li>若表中很少对数据进行更新，且<strong>经常只查询某几个字段，可对这几个字段都创建索引</strong>，加快速率</li>
<li><strong>通过explain来查看SQL语句的执行效果，可以帮助更好的选择索引和优化查询语句</strong>，写出更好的优化语句。</li>
<li><strong>避免使用select *</strong> ，用具体的字段列表。</li>
<li>不在索引列做运算或者使用函数</li>
<li>查询尽可能使用<code>limit</code>减少返回的行数，减少数据传输时间和带宽浪费。</li>
</ul>
<h2 id="四、缓存（redis）"><a href="#四、缓存（redis）" class="headerlink" title="四、缓存（redis）"></a>四、缓存（redis）</h2><h3 id="1-Redis中有哪些数据结构？"><a href="#1-Redis中有哪些数据结构？" class="headerlink" title="1. Redis中有哪些数据结构？"></a>1. Redis中有哪些数据结构？</h3><p>​    Redis是一个<code>键值对</code><strong>非关系型数据库，key一直都是String类型，而value有五种数据类型：</strong></p>
<p>​    <strong>String、List、Hash、Set、Zset</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200720193947363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTg5NzM4,size_16,color_FFFFFF,t_70" alt=""></p>
<h3 id="2-能说一说Redis中缓存淘汰策略嘛？"><a href="#2-能说一说Redis中缓存淘汰策略嘛？" class="headerlink" title="2. 能说一说Redis中缓存淘汰策略嘛？"></a>2. 能说一说Redis中缓存淘汰策略嘛？</h3><p>​    缓存淘汰主要分为三类：</p>
<ol>
<li><strong>对设置了过期时间的数据valatile</strong></li>
</ol>
<p><code>valatile-lru</code>：<strong>最近最少使用</strong>数据</p>
<p><code>valatile-ttl</code>：<strong>将要过期的数据</strong></p>
<p><code>valatile-random</code>：随机选取</p>
<ol start="2">
<li><strong>对全局数据</strong></li>
</ol>
<p><code>allkeys-lru</code></p>
<p><code>allkeys-random</code></p>
<ol start="3">
<li><strong>直接报错，不淘汰数据</strong></li>
</ol>
<p><code>no-enviction（驱逐）</code></p>
<h3 id="3-Redis的数据过期策略有哪些？"><a href="#3-Redis的数据过期策略有哪些？" class="headerlink" title="3. Redis的数据过期策略有哪些？"></a>3. Redis的数据过期策略有哪些？</h3><p>就是检查数据是否过期的策略：</p>
<ol>
<li>定期检查：定时遍历redis删除</li>
<li>惰性检查，get时再检查</li>
</ol>
<p><strong>但我们一般就综合使用，惰性检查 + 定时检查</strong></p>
<h3 id="4-Redis如何实现与数据库一致性？"><a href="#4-Redis如何实现与数据库一致性？" class="headerlink" title="4. Redis如何实现与数据库一致性？"></a>4. Redis如何实现与数据库一致性？</h3><p>​    Redis要与数据库的数据保持一致性，可能在<code>并发修改</code>时会产生不一致。</p>
<p>先删缓存，再更新数据库，可能出现不一致问题，写入缓存时，另一线程进行更新数据库。</p>
<p>所以使用<strong>延时双删策略</strong>：先删除缓存，更新数据库，延时，再次删除缓存，就能大概率避免。</p>
<h3 id="5-说一说缓存击穿、缓存穿透、缓存雪崩的区别以及解决办法吧"><a href="#5-说一说缓存击穿、缓存穿透、缓存雪崩的区别以及解决办法吧" class="headerlink" title="5. 说一说缓存击穿、缓存穿透、缓存雪崩的区别以及解决办法吧"></a>5. 说一说缓存击穿、缓存穿透、缓存雪崩的区别以及解决办法吧</h3><ul>
<li><strong>缓存击穿</strong></li>
</ul>
<p><strong>缓存中的某个热点数据</strong>到期后，大量请求击穿，发到DB</p>
<p>解决：</p>
<ol>
<li>最简单就是<strong>热点数据设定永不过期</strong></li>
<li><strong>不存在的数据加个互斥锁（setnx来实现）</strong>，避免一瞬间大量请求。</li>
</ol>
<ul>
<li><strong>缓存穿透</strong></li>
</ul>
<p>大量请求访问<strong>一个不存在的数据</strong>，即缓存和数据库中都没有</p>
<p>解决：</p>
<ol>
<li>返回空值给缓存</li>
<li>使用<strong>布隆过滤器</strong>，维护一个集合保存<strong>所有可能被访问到的key，不存在的key直接过滤掉。</strong></li>
</ol>
<p><strong>k个同时为1，才代表有，但可能误判</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200526185103601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTg5NzM4,size_16,color_FFFFFF,t_70" alt="img"></p>
<ul>
<li><strong>缓存雪崩</strong></li>
</ul>
<p><strong>较短时间内，缓存中大量的热点数据集体过期，</strong>造成一瞬间DB的压力骤增</p>
<p>解决：</p>
<ol>
<li><strong>还是避免同时过期，则要使热点数据过期时间分散</strong></li>
<li>热点数据分布在分布式的数据库中</li>
<li>或者就直接永不过期。</li>
</ol>
<h3 id="6-说一说Redis中的持久化"><a href="#6-说一说Redis中的持久化" class="headerlink" title="6. 说一说Redis中的持久化"></a>6. 说一说Redis中的持久化</h3><p>​    Redis的持久化主要分为两种，一个是RDB快照，一个是AOF日志</p>
<ul>
<li><p>RDB快照是<strong>数据库的完整备份</strong>，里面有全部数据，保存时就将快照保存在<strong>dump.rdb</strong>文件中，启动时加载。</p>
</li>
<li><p>RDB实现：主要是<code>fork</code>出一个子进程，然后<strong>这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。</strong></p>
</li>
<li><p>AOF是将修改的<strong>每一条指令记录</strong>进文件，避免了save才去保存，<strong>实时性强。</strong></p>
</li>
<li><p>AOF实现：改变数据集的命令时（比如 SET）， 这个命令的反向命令就会被追加到<strong>AOF写命令刷新缓存区里</strong>，默认每秒一次磁盘操作。重启时， 程序就可以通过<strong>重新执行 AOF 文件中的命令</strong>来达到重建数据集的目的。</p>
</li>
</ul>
<p>​    二者的比较：</p>
<p>​    RDB 在<strong>恢复大数据集</strong>时的速度比 AOF 的恢复速度要快，但是故障宕机时丢失数据。</p>
<p>​    AOF <strong>文件的体积</strong>通常要大于 RDB 文件的体积，<strong>因为有数据的过期，所以恢复慢。</strong></p>
<h3 id="7-说说Redis中的哨兵模式吧"><a href="#7-说说Redis中的哨兵模式吧" class="headerlink" title="7. 说说Redis中的哨兵模式吧"></a>7. 说说Redis中的哨兵模式吧</h3><p>​    Redis采用哨兵进程监控主redis服务器和从redis服务器。<strong>当主服务器宕机，哨兵通知其他从服务器切换为主机。（哨兵之间也会互相监控）</strong>哨兵会向主从服务器发送hello指令，以确保其状态，然后在哨兵之间网络进行消息互通。</p>
<p>​    <strong>领头哨兵在主机故障时进行自动故障转移，并从从服务器间选择一个作为一个新服务器。</strong> </p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">rnang0</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://rnang0.github.io/2020/12/01/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%EF%BC%9AOS%20+%20%E8%AE%A1%E7%BD%91%20+%20%E6%95%B0%E6%8D%AE%E5%BA%93Mysql%20+%20%E7%BC%93%E5%AD%98redis/">http://rnang0.github.io/2020/12/01/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%EF%BC%9AOS%20+%20%E8%AE%A1%E7%BD%91%20+%20%E6%95%B0%E6%8D%AE%E5%BA%93Mysql%20+%20%E7%BC%93%E5%AD%98redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://rnang0.github.io" target="_blank">rnang0 Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%9B-%E7%BA%BF%E7%A8%8B/">进/线程</a><a class="post-meta__tags" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a><a class="post-meta__tags" href="/tags/TCP-IP/">TCP/IP</a><a class="post-meta__tags" href="/tags/HTTP-HTTPS/">HTTP/HTTPS</a><a class="post-meta__tags" href="/tags/%E7%BC%93%E5%AD%98/">缓存</a><a class="post-meta__tags" href="/tags/%E7%B4%A2%E5%BC%95/">索引</a></div><div class="post_share"><div class="social-share" data-image="https://miro.medium.com/max/2000/1*DnnkReGamr7ps_2HlGT_FQ.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/12/13/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%EF%BC%9AJava%E9%9B%86%E5%90%88%E7%B1%BB/"><img class="prev_cover" src="https://img-blog.csdnimg.cn/20201206163642351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">春招面经：Java集合类</div></div></a></div><div class="next-post pull_right"><a href="/2020/11/30/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0%EF%BC%9Aleetcode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"><img class="next_cover" src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=4254185095,1044467258&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">leetcode刷题总结（持续更新...）</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/06/23/春招复习4：操作系统/" title="春招复习4：操作系统"><img class="relatedPosts_cover" src="https://img-blog.csdnimg.cn/20200624114032370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-23</div><div class="relatedPosts_title">春招复习4：操作系统</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/28/春招复习5：计算机网络/" title="春招复习5：计算机网络"><img class="relatedPosts_cover" src="https://img-blog.csdnimg.cn/20200701112110271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-28</div><div class="relatedPosts_title">春招复习5：计算机网络</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/03/春招复习8：数据库与缓存/" title="春招复习8：数据库与缓存"><img class="relatedPosts_cover" src="https://www.lgstatic.com/i/image2/M01/8A/CA/CgoB5l14rXSAWVk7AAFdi6Ly8iM148.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-08-03</div><div class="relatedPosts_title">春招复习8：数据库与缓存</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By rnang0</div><div class="footer_custom_text">Hi, welcome to my <a href="http://rnang0.github.io/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script></body></html>