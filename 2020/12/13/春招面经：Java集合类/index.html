<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>春招面经：Java集合类 | rnang0 Blog</title><meta name="description" content="Java集合类1、Java集合容器包含了哪些？​    主要就是List、Set、Map接口，以及实现了这些接口的子类。 ​    List、Set是继承自Collection接口、Map是单独的接口 2、List、Set、Map有何区别？​    如同他们名字一样：  List：列表，有序，可以插入相同的值、null Set：集合，无序的，元素不能重复，所以就只能存一个null Map：是映射，"><meta name="keywords" content="Java集合"><meta name="author" content="rnang0"><meta name="copyright" content="rnang0"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="春招面经：Java集合类"><meta name="twitter:description" content="Java集合类1、Java集合容器包含了哪些？​    主要就是List、Set、Map接口，以及实现了这些接口的子类。 ​    List、Set是继承自Collection接口、Map是单独的接口 2、List、Set、Map有何区别？​    如同他们名字一样：  List：列表，有序，可以插入相同的值、null Set：集合，无序的，元素不能重复，所以就只能存一个null Map：是映射，"><meta name="twitter:image" content="https://img-blog.csdnimg.cn/20201206163642351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70"><meta property="og:type" content="article"><meta property="og:title" content="春招面经：Java集合类"><meta property="og:url" content="http://rnang0.github.io/2020/12/13/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%EF%BC%9AJava%E9%9B%86%E5%90%88%E7%B1%BB/"><meta property="og:site_name" content="rnang0 Blog"><meta property="og:description" content="Java集合类1、Java集合容器包含了哪些？​    主要就是List、Set、Map接口，以及实现了这些接口的子类。 ​    List、Set是继承自Collection接口、Map是单独的接口 2、List、Set、Map有何区别？​    如同他们名字一样：  List：列表，有序，可以插入相同的值、null Set：集合，无序的，元素不能重复，所以就只能存一个null Map：是映射，"><meta property="og:image" content="https://img-blog.csdnimg.cn/20201206163642351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70"><meta property="article:published_time" content="2020-12-12T16:00:00.000Z"><meta property="article:modified_time" content="2021-02-27T02:42:41.619Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="canonical" href="http://rnang0.github.io/2020/12/13/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%EF%BC%9AJava%E9%9B%86%E5%90%88%E7%B1%BB/"><link rel="prev" title="春招面经：JVM" href="http://rnang0.github.io/2020/12/28/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%EF%BC%9AJVM/"><link rel="next" title="春招面经：OS + 计网 + 数据库Mysql + 缓存redis" href="http://rnang0.github.io/2020/12/01/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%EF%BC%9AOS%20+%20%E8%AE%A1%E7%BD%91%20+%20%E6%95%B0%E6%8D%AE%E5%BA%93Mysql%20+%20%E7%BC%93%E5%AD%98redis/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'none',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/autor.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">68</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">94</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-mars"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java集合类"><span class="toc-text">Java集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、Java集合容器包含了哪些？"><span class="toc-text">1、Java集合容器包含了哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、List、Set、Map有何区别？"><span class="toc-text">2、List、Set、Map有何区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、ArrayList存储结构和特点"><span class="toc-text">3、ArrayList存储结构和特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、ArrayList底层是数组，数组是定长的，那扩容怎么办？"><span class="toc-text">4、ArrayList底层是数组，数组是定长的，那扩容怎么办？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、ArrayList空参构造和初始化大小0的不同？"><span class="toc-text">5、ArrayList空参构造和初始化大小0的不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6、-ArrayList为什么elementData加上transient关键字"><span class="toc-text">6、 ArrayList为什么elementData加上transient关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7、ArrayList为什么elementData没有private修饰"><span class="toc-text">7、ArrayList为什么elementData没有private修饰</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8、ArrayList与Vector的区别"><span class="toc-text">8、ArrayList与Vector的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9、对Vector的所有操作都是线程安全滴吗？"><span class="toc-text">9、对Vector的所有操作都是线程安全滴吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10、实现普通的队列时，ArrayDeque-与-LinkedList-该如何选择？"><span class="toc-text">10、实现普通的队列时，ArrayDeque 与 LinkedList 该如何选择？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11、ArrayDeque-与-LinkedList-区别？"><span class="toc-text">11、ArrayDeque 与 LinkedList 区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12、说说Set集合的实现类，以及特点"><span class="toc-text">12、说说Set集合的实现类，以及特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、能说说HashMap内部结构是怎么样的？"><span class="toc-text">1、能说说HashMap内部结构是怎么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、HashMap中字段例如Node数组table要使用transient"><span class="toc-text">2、HashMap中字段例如Node数组table要使用transient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、HashMap为什么要设置modCount（fail-fast、fail-safe）？"><span class="toc-text">3、HashMap为什么要设置modCount（fail-fast、fail-safe）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、HashMap中的hash值计算时，为什么-h-key-hashCode-h-gt-gt-gt-16"><span class="toc-text">4、HashMap中的hash值计算时，为什么 (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、HashMap的数组容量length为什么是2-n，如果指定初始化不为2-n怎么办？"><span class="toc-text">5、HashMap的数组容量length为什么是2^n，如果指定初始化不为2^n怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、在Node节点中，重写equals方法时，为什么建议重写hashcode方法？"><span class="toc-text">6、在Node节点中，重写equals方法时，为什么建议重写hashcode方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、HashMap是数量达到容量才扩容？扩容机制"><span class="toc-text">7、HashMap是数量达到容量才扩容？扩容机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、为什么HashMap扩容时线程不安全？"><span class="toc-text">8、为什么HashMap扩容时线程不安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9、HashMap是线程不安全的，如何处理？"><span class="toc-text">9、HashMap是线程不安全的，如何处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10、能说说HashMap和HashTable的不同？"><span class="toc-text">10、能说说HashMap和HashTable的不同？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-text">ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、说说ConcurrentHashMap的数据结构，以及为啥他并发度这么高？"><span class="toc-text">1、说说ConcurrentHashMap的数据结构，以及为啥他并发度这么高？</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://img-blog.csdnimg.cn/20201206163642351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">rnang0 Blog</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-mars"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">春招面经：Java集合类</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-12-13 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-12-13</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-02-27 10:42:41"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-02-27</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E7%BB%8F/">面经</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Java集合类"><a href="#Java集合类" class="headerlink" title="Java集合类"></a>Java集合类</h1><h2 id="1、Java集合容器包含了哪些？"><a href="#1、Java集合容器包含了哪些？" class="headerlink" title="1、Java集合容器包含了哪些？"></a>1、Java集合容器包含了哪些？</h2><p>​    主要就是<strong>List、Set、Map接口</strong>，以及实现了这些接口的子类。</p>
<p>​    <strong>List、Set是继承自Collection接口、Map是单独的接口</strong></p>
<h2 id="2、List、Set、Map有何区别？"><a href="#2、List、Set、Map有何区别？" class="headerlink" title="2、List、Set、Map有何区别？"></a>2、List、Set、Map有何区别？</h2><p>​    如同他们名字一样：</p>
<ul>
<li>List：列表，<strong>有序，可以插入相同的值、null</strong></li>
<li>Set：集合，<strong>无序的，元素不能重复，所以就只能存一个null</strong></li>
<li>Map：是映射，存储的是Entry键值对（1.8之后是Node），key唯一，则只能存一个null的key，value可以存多个值为null</li>
</ul>
<h2 id="3、ArrayList存储结构和特点"><a href="#3、ArrayList存储结构和特点" class="headerlink" title="3、ArrayList存储结构和特点"></a>3、ArrayList存储结构和特点</h2><p>​    ArrayList顾名思义嘛，是数组列表，底层使用数组实现，当装载的是基本类型时，例如Byte，int，boolean，要使用他们的包装类例如Interger</p>
<ul>
<li><strong>底层是一个Object数组，elementData</strong></li>
<li><strong>特点是：查询效率高，但是增删的话（一般使用LinkedList）效率就低，线程也不安全，但是使用频率高</strong></li>
</ul>
<h2 id="4、ArrayList底层是数组，数组是定长的，那扩容怎么办？"><a href="#4、ArrayList底层是数组，数组是定长的，那扩容怎么办？" class="headerlink" title="4、ArrayList底层是数组，数组是定长的，那扩容怎么办？"></a>4、ArrayList底层是数组，数组是定长的，那扩容怎么办？</h2><p>​    ArrayList可以初始化长度，当空间不足时，则进行扩容。</p>
<p>扩容机制：</p>
<ul>
<li>重新定义一个新数组，大小为原来的1.5倍（size + （size &gt;&gt; 1））</li>
<li>然后将原数组copy到新数组，再进行添加操作</li>
</ul>
<h2 id="5、ArrayList空参构造和初始化大小0的不同？"><a href="#5、ArrayList空参构造和初始化大小0的不同？" class="headerlink" title="5、ArrayList空参构造和初始化大小0的不同？"></a>5、ArrayList空参构造和初始化大小0的不同？</h2><ul>
<li>空参构造时，即<code>new ArrayList()</code>，空间大小为<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA = 0</code>，然后add时，扩容为10</li>
<li>初始化大小为0时，即<code>new ArrayList(0)</code>，空间大小为<code>EMPTY_ELEMENTDATA</code>也是0，但是add时，扩容为1</li>
</ul>
<h2 id="6、-ArrayList为什么elementData加上transient关键字"><a href="#6、-ArrayList为什么elementData加上transient关键字" class="headerlink" title="6、 ArrayList为什么elementData加上transient关键字"></a>6、 ArrayList为什么elementData加上transient关键字</h2><p>​    因为<strong>不想让整个数组空间都序列化，比较耗费资源</strong>，ArrayList内部有实现的序列化和反序列化方法</p>
<h2 id="7、ArrayList为什么elementData没有private修饰"><a href="#7、ArrayList为什么elementData没有private修饰" class="headerlink" title="7、ArrayList为什么elementData没有private修饰"></a>7、ArrayList为什么elementData没有private修饰</h2><p>​    因为这样可以<strong>简化内部类对elementData的访问。</strong></p>
<h2 id="8、ArrayList与Vector的区别"><a href="#8、ArrayList与Vector的区别" class="headerlink" title="8、ArrayList与Vector的区别"></a>8、ArrayList与Vector的区别</h2><ol>
<li>第一个简单，ArrayList是线程不安全的，而<strong>Vector是线程安全的</strong>，每个方法都加了<code>synchronized</code>关键字</li>
<li>第二个重点，<strong>在扩容时，ArrayList扩容为原来的1.5倍，而Vector是扩容为原来的2倍。</strong></li>
</ol>
<h2 id="9、对Vector的所有操作都是线程安全滴吗？"><a href="#9、对Vector的所有操作都是线程安全滴吗？" class="headerlink" title="9、对Vector的所有操作都是线程安全滴吗？"></a>9、对Vector的所有操作都是线程安全滴吗？</h2><p>​    不一定，虽然内部每个单独的方法都加了互斥锁，<strong>但是进行复合操作时，就无法保证其安全性。</strong></p>
<p>拓展：Vector是同步容器，降低了并发的能力，所以就有了Java的并发容器（JUC）来进行高效并发</p>
<ul>
<li><p>同步容器：Vector、HashTable、Stack</p>
</li>
<li><p>并发容器：JUC下的集合类，<strong>进行复合操作时，尽量使用自身提供的线程安全方法。</strong></p>
</li>
</ul>
<p><strong>Stack不建议使用了，因为继承自Vector容器，栈一般用ArrayDeque来实现。</strong></p>
<h2 id="10、实现普通的队列时，ArrayDeque-与-LinkedList-该如何选择？"><a href="#10、实现普通的队列时，ArrayDeque-与-LinkedList-该如何选择？" class="headerlink" title="10、实现普通的队列时，ArrayDeque 与 LinkedList 该如何选择？"></a>10、实现普通的队列时，ArrayDeque 与 LinkedList 该如何选择？</h2><p>​    普通队列只需要在队头取，在队尾插入。</p>
<p>​    <strong>即使用ArrayDeque（底层是数组）即可，使用LinkedList还需要额外维护双向链表，增大了开销。</strong></p>
<h2 id="11、ArrayDeque-与-LinkedList-区别？"><a href="#11、ArrayDeque-与-LinkedList-区别？" class="headerlink" title="11、ArrayDeque 与 LinkedList 区别？"></a>11、ArrayDeque 与 LinkedList 区别？</h2><ol>
<li>一个是数组实现，一个是双向链表实现</li>
<li>一个不可存储null值，LinkedList可以存储null值</li>
</ol>
<h2 id="12、说说Set集合的实现类，以及特点"><a href="#12、说说Set集合的实现类，以及特点" class="headerlink" title="12、说说Set集合的实现类，以及特点"></a>12、说说Set集合的实现类，以及特点</h2><p>​    Set就是我们数学上的集合，<strong>无序，不重复。</strong></p>
<p>分类：HashSet、LinkedHashSet、TreeSet</p>
<ul>
<li>Hash实现的话，内部维护了一个HashMap，Set的值作为key，值是一个Object类型，key是指向这个对象的。</li>
<li>LinkedHashSet，<strong>内部加了一个LinkedList双向链表来保留插入的顺序</strong></li>
<li>Tree实现的话，内部是红黑树实现，但<strong>查询没有Hash快</strong></li>
</ul>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="1、能说说HashMap内部结构是怎么样的？"><a href="#1、能说说HashMap内部结构是怎么样的？" class="headerlink" title="1、能说说HashMap内部结构是怎么样的？"></a>1、能说说HashMap内部结构是怎么样的？</h3><p>​    顾名思义，底层是用了hash表，<strong>key由hashcode来计算进行存储</strong>，有三种数据结构：<strong>数组 + 链表（1.8之后是红黑树，加快了查询效率）</strong></p>
<ol>
<li><p>key经过hash函数<strong>（取hashcode，然后位运算取模）</strong>的运算，得到数组索引，<strong>数组table存储的是Entry键值对（1.8之后是Node），里面有key，value，还有hash值，以及链表的next</strong></p>
</li>
<li><p>当发生哈希碰撞时，就会在桶的位置形成链表，采用头插法进行维护链表，1.8之后是尾插法进行维护链表。</p>
</li>
</ol>
<h3 id="2、HashMap中字段例如Node数组table要使用transient"><a href="#2、HashMap中字段例如Node数组table要使用transient" class="headerlink" title="2、HashMap中字段例如Node数组table要使用transient"></a>2、HashMap中字段例如Node数组table要使用transient</h3><p>​    看源码发现，HashMap中的字段，例如：Node数组table，entrySet，size，<strong>modCount（结构修改次数）</strong></p>
<p>​    让这些<strong>敏感字段</strong>不被序列化成字节信息，从而反序列化成对象时，属性消失。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>

<h3 id="3、HashMap为什么要设置modCount（fail-fast、fail-safe）？"><a href="#3、HashMap为什么要设置modCount（fail-fast、fail-safe）？" class="headerlink" title="3、HashMap为什么要设置modCount（fail-fast、fail-safe）？"></a>3、HashMap为什么要设置modCount（fail-fast、fail-safe）？</h3><p>​    modCount，指的是对HashMap结构发生修改的次数</p>
<p>​    <strong>java.utils 包下的集合类都是遵循fail-fast</strong>，快速失败机制的，多线程操作下当遍历时发现modCount不匹配时，就会迅速抛出异常。</p>
<ul>
<li><p>fail-fast：</p>
<p>使用迭代器遍历元素的过程，如果集合的结构被改变的话，就会抛出异常，防止继续遍历。这就是所谓的快速失败机制。</p>
</li>
<li><p>fail-safe：</p>
<p>顾名思义：安全失败，他就不会抛出异常，<strong>会在复制原集合的一份数据出来，然后在复制的那份数据遍历。</strong></p>
</li>
</ul>
<p><strong>注意：juc包下的并发容器都是<code>fail-safe</code>，因为它会复制一份进行操作，所以就不保证数据时最新数据。</strong></p>
<h3 id="4、HashMap中的hash值计算时，为什么-h-key-hashCode-h-gt-gt-gt-16"><a href="#4、HashMap中的hash值计算时，为什么-h-key-hashCode-h-gt-gt-gt-16" class="headerlink" title="4、HashMap中的hash值计算时，为什么 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)"></a>4、HashMap中的hash值计算时，为什么 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</h3><p>​    <code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code></p>
<p>​    实际上是将<strong>hashcode的高16位 与 低16位进行异或操作</strong>，这样高低16位信息都用上了，能够<strong>让hash值更分散，减少hash碰撞。</strong></p>
<h3 id="5、HashMap的数组容量length为什么是2-n，如果指定初始化不为2-n怎么办？"><a href="#5、HashMap的数组容量length为什么是2-n，如果指定初始化不为2-n怎么办？" class="headerlink" title="5、HashMap的数组容量length为什么是2^n，如果指定初始化不为2^n怎么办？"></a>5、HashMap的数组容量length为什么是2^n，如果指定初始化不为2^n怎么办？</h3><ul>
<li><strong>为什么数组容量length是2^n</strong></li>
</ul>
<p>​    由插入时源码得知，插入到对应桶位置的时候，是根据 <code>(n - 1) &amp; hash</code>进行<strong>位运算取模</strong>计算桶的数组下标</p>
<p>​    <strong>因为2 ^ n - 1 转换成二进制就变成全1，&amp;运算等价于取模。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>指定初始化容量不为2^n，怎么办？</strong></li>
</ul>
<p>​    当我们new一个HashMap(int Capacity)时，实际上并不是直接采用这个容量，而是<strong>将第一个比它大的2^n，作为容量。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在tableSizeFor方法中</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、在Node节点中，重写equals方法时，为什么建议重写hashcode方法？"><a href="#6、在Node节点中，重写equals方法时，为什么建议重写hashcode方法？" class="headerlink" title="6、在Node节点中，重写equals方法时，为什么建议重写hashcode方法？"></a>6、在Node节点中，重写equals方法时，为什么建议重写hashcode方法？</h3><p>​    因为equals方法中，通过比较key和value是否一样来判断相同的，保证二者是同一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有重写hashcode方法，会出现equals相等而hashcode不相同的情况，<strong>保证同一个链表上的对象返回不同的hashcode值，这样去get的时候，才能拿到具体的链表上的节点。</strong></p>
<p>同时<strong>使用hashcode方法提前校验，可以避免每一次比对都调用equals方法，提高效率。</strong></p>
<h3 id="7、HashMap是数量达到容量才扩容？扩容机制"><a href="#7、HashMap是数量达到容量才扩容？扩容机制" class="headerlink" title="7、HashMap是数量达到容量才扩容？扩容机制"></a>7、HashMap是数量达到容量才扩容？扩容机制</h3><p>​    HashMap当元素数量达到<strong>阈值threshold</strong>，就进行一次扩容，扩容为原来的2倍，然后重新插入。</p>
<p>​    阈值 <code>threshold = size * LoadFactor</code>（负载因子，默认0.75）</p>
<ul>
<li><strong>新数组容量扩为原来2倍</strong></li>
</ul>
<p>查看源码resize函数：发现每次扩容都是<code>oldCap &lt;&lt; 1</code>，<strong>扩容为原来的2倍。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">		oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">	newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>数据重新插入到新数组，以及碰撞后的链表</strong></li>
</ul>
<p><strong>重新计算Hash值</strong>，进行插入到新数组，发生碰撞再插入进链表。</p>
<h3 id="8、为什么HashMap扩容时线程不安全？"><a href="#8、为什么HashMap扩容时线程不安全？" class="headerlink" title="8、为什么HashMap扩容时线程不安全？"></a>8、为什么HashMap扩容时线程不安全？</h3><ol>
<li><p>Java1.8之前采用头插法</p>
<ol>
<li>数组中位于同一个桶的node，链表中元素会在扩容的插入时<strong>前后链表顺序倒置</strong>，就会引发线程安全问题。</li>
<li><strong>多线程进行插入时，就会陷入死循环，指向混乱或丢失，从而形成环形链表，或者数据丢失</strong></li>
</ol>
</li>
<li><p>Java1.8之后hash碰撞就采用尾插法</p>
<p>尾插法不会改变前后链表顺序，就不会形成这种情况，但<strong>我觉得还是会造成数据覆盖</strong>的情况。</p>
<p>因为多线程可能同时进入<strong>判断桶中是否有数据</strong>，当其中一个挂起时，重新获得时间片时，可能桶中有数据，这样就会覆盖掉原数据。</p>
</li>
</ol>
<h3 id="9、HashMap是线程不安全的，如何处理？"><a href="#9、HashMap是线程不安全的，如何处理？" class="headerlink" title="9、HashMap是线程不安全的，如何处理？"></a>9、HashMap是线程不安全的，如何处理？</h3><p>​    一共有三种方式：</p>
<ul>
<li><code>Collections.synchronizedMap(Map)</code>创建线程安全的map集合；</li>
</ul>
<p><strong>内部有一个Map和一个mutex排斥锁（默认是this），创建线程安全的map时，会对方法进行上锁。</strong></p>
<ul>
<li>使用Hashtable</li>
</ul>
<p>我看过他的源码，他在对数据操作的时候都会上锁，所以效率比较低下。</p>
<ul>
<li><strong>使用ConcurrentHashMap</strong></li>
</ul>
<p>不过出于线程并发度的原因，我都会舍弃前两者<strong>使用最后的ConcurrentHashMap，他的性能和效率明显高于前两者。</strong></p>
<h3 id="10、能说说HashMap和HashTable的不同？"><a href="#10、能说说HashMap和HashTable的不同？" class="headerlink" title="10、能说说HashMap和HashTable的不同？"></a>10、能说说HashMap和HashTable的不同？</h3><ul>
<li>实现方式不同，Hashtable 继承了 Dictionary类，而 HashMap 继承的是 AbstractMap 类。</li>
<li><strong>初始化容量不同</strong>：HashMap 的初始容量为：16，<strong>Hashtable 初始容量为：11</strong>，两者的负载因子默认都是：0.75。</li>
<li><strong>扩容机制不同</strong>：当现有容量大于总容量 * 负载因子时，HashMap 扩容规则为当前容量翻倍，<strong>Hashtable 扩容规则为当前容量翻倍 + 1。</strong></li>
<li><strong>迭代器不同</strong>：<strong>HashMap 中的 Iterator 迭代器是 fail-fast 的</strong>，而 Hashtable 的 Enumerator 不是 fail-fast 的。</li>
<li>Hashtable使用的是<strong>安全失败机制（fail-safe），不能存入null值：</strong>无法判断对应的key是不存在还是为空，因为你无法再调用一次contain(key）来对key是否存在进行判断，ConcurrentHashMap同理。</li>
</ul>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="1、说说ConcurrentHashMap的数据结构，以及为啥他并发度这么高？"><a href="#1、说说ConcurrentHashMap的数据结构，以及为啥他并发度这么高？" class="headerlink" title="1、说说ConcurrentHashMap的数据结构，以及为啥他并发度这么高？"></a>1、说说ConcurrentHashMap的数据结构，以及为啥他并发度这么高？</h3><ul>
<li><p><strong>jdk8之前：Segment 分段锁</strong></p>
<p>还是采用<code>链表+数组</code>的形式存储键值对的，但是为了并发操作，而<strong>又避免了将整个数组锁住，就把原来的整个 table 划分为 n 个 Segment ，每个Segment对应一把锁，多个线程访问不同的segment。每个 Segment 里边是由 HashEntry 组成的数组，每个 HashEntry之间又可以形成链表。</strong></p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201212140449437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 和 HashMap 中的 Entry 作用一样，真正存放数据的桶</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"> <span class="keyword">final</span> K key;</span><br><span class="line"> <span class="comment">//value和next都用 volatile 修饰，用于保证内存可见性和禁止指令重排序</span></span><br><span class="line"> <span class="keyword">volatile</span> V value;</span><br><span class="line"> <span class="comment">//指向下一个节点</span></span><br><span class="line"> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    ConcurrentHashMap 采用了<strong>分段锁</strong>技术，<strong>Segment分段锁继承ReentrantLock</strong>，每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。在并发数高的时候，ReentrantLock比Syncronized总体开销要小一些。</p>
<p>​    HashEntry使用<code>volatile</code>去修饰了他的数据Value还有下一个节点next。</p>
<ul>
<li><strong>jdk8之后：CAS + synchronized</strong></li>
</ul>
<p>​    1.8之后抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。给数组中的每一个<strong>头节点加锁，锁的粒度降低了。并且，用的是 Synchronized 锁。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V val;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>初始化，使用CAS保证并发安全，懒惰初始化<code>table[]</code>即Node数组</strong></li>
<li><strong>put，没链表时为CAS创建链表，有就尾插法</strong></li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">rnang0</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://rnang0.github.io/2020/12/13/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%EF%BC%9AJava%E9%9B%86%E5%90%88%E7%B1%BB/">http://rnang0.github.io/2020/12/13/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%EF%BC%9AJava%E9%9B%86%E5%90%88%E7%B1%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://rnang0.github.io" target="_blank">rnang0 Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E9%9B%86%E5%90%88/">Java集合</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/rnang0/blogimage/raw/master/20210512182016.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/12/28/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%EF%BC%9AJVM/"><img class="prev_cover" src="https://img-blog.csdnimg.cn/2021012409181395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">春招面经：JVM</div></div></a></div><div class="next-post pull_right"><a href="/2020/12/01/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%EF%BC%9AOS%20+%20%E8%AE%A1%E7%BD%91%20+%20%E6%95%B0%E6%8D%AE%E5%BA%93Mysql%20+%20%E7%BC%93%E5%AD%98redis/"><img class="next_cover" src="https://img-blog.csdnimg.cn/20201228092946817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">春招面经：OS + 计网 + 数据库Mysql + 缓存redis</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By rnang0</div><div class="footer_custom_text">Hi, welcome to my <a href="http://rnang0.github.io/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script></body></html>