<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>春招复习8：数据库与缓存 | rnang0 Blog</title><meta name="description" content="数据库与缓存重点学习内容 事务隔离级别 索引 Mysql三范式 主从复制 SQL语句的优化 缓存策略 缓存穿透、击穿和雪崩 Redis淘汰策略 Redis持久化  一、关系型数据库（Mysql为例）1.1 事务的四大特性 原子性（Atomicity）：事务中所有操作是不可再分割的原子单位。事务中所有操作要么全部执行成功，要么全部执行失败。 一致性（Consistency）：事务执行后，数据库状态与"><meta name="keywords" content="Mysql,Redis,缓存"><meta name="author" content="rnang0"><meta name="copyright" content="rnang0"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="春招复习8：数据库与缓存"><meta name="twitter:description" content="数据库与缓存重点学习内容 事务隔离级别 索引 Mysql三范式 主从复制 SQL语句的优化 缓存策略 缓存穿透、击穿和雪崩 Redis淘汰策略 Redis持久化  一、关系型数据库（Mysql为例）1.1 事务的四大特性 原子性（Atomicity）：事务中所有操作是不可再分割的原子单位。事务中所有操作要么全部执行成功，要么全部执行失败。 一致性（Consistency）：事务执行后，数据库状态与"><meta name="twitter:image" content="https://www.lgstatic.com/i/image2/M01/8A/CA/CgoB5l14rXSAWVk7AAFdi6Ly8iM148.png"><meta property="og:type" content="article"><meta property="og:title" content="春招复习8：数据库与缓存"><meta property="og:url" content="http://rnang0.github.io/2020/08/03/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A08%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98/"><meta property="og:site_name" content="rnang0 Blog"><meta property="og:description" content="数据库与缓存重点学习内容 事务隔离级别 索引 Mysql三范式 主从复制 SQL语句的优化 缓存策略 缓存穿透、击穿和雪崩 Redis淘汰策略 Redis持久化  一、关系型数据库（Mysql为例）1.1 事务的四大特性 原子性（Atomicity）：事务中所有操作是不可再分割的原子单位。事务中所有操作要么全部执行成功，要么全部执行失败。 一致性（Consistency）：事务执行后，数据库状态与"><meta property="og:image" content="https://www.lgstatic.com/i/image2/M01/8A/CA/CgoB5l14rXSAWVk7AAFdi6Ly8iM148.png"><meta property="article:published_time" content="2020-08-02T16:00:00.000Z"><meta property="article:modified_time" content="2020-12-29T11:37:01.337Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="canonical" href="http://rnang0.github.io/2020/08/03/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A08%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98/"><link rel="prev" title="春招复习9：Tomcat架构解析" href="http://rnang0.github.io/2020/09/11/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A09%EF%BC%9ATomcat%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/"><link rel="next" title="春招复习7：Java并发" href="http://rnang0.github.io/2020/07/25/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A07%EF%BC%9AJava%E5%B9%B6%E5%8F%91/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'none',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/autor.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">20</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">40</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-mars"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#数据库与缓存"><span class="toc-text">数据库与缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#重点学习内容"><span class="toc-text">重点学习内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一、关系型数据库（Mysql为例）"><span class="toc-text">一、关系型数据库（Mysql为例）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-事务的四大特性"><span class="toc-text">1.1 事务的四大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-undo-log"><span class="toc-text">1.1.1 undo log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-redo-log"><span class="toc-text">1.1.2 redo log</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-事务隔离级别"><span class="toc-text">1.2 事务隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Mysql常见引擎"><span class="toc-text">1.3 Mysql常见引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-InnoDB（支持事务）"><span class="toc-text">1.3.1 InnoDB（支持事务）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-MyIsam（不支持事务）"><span class="toc-text">1.3.2 MyIsam（不支持事务）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-Memory"><span class="toc-text">1.3.2 Memory</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-常用数据库优化方式"><span class="toc-text">1.4 常用数据库优化方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-索引"><span class="toc-text">1.5 索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-索引种类"><span class="toc-text">1.5.1 索引种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-索引使用原则"><span class="toc-text">1.5.2 索引使用原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-3-B-树"><span class="toc-text">1.5.3 B+树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-4-聚集与非聚集索引"><span class="toc-text">1.5.4 聚集与非聚集索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-数据库三范式"><span class="toc-text">1.6 数据库三范式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-1-1NF"><span class="toc-text">1.6.1 1NF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-2-2NF"><span class="toc-text">1.6.2 2NF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-1-3NF"><span class="toc-text">1.6.1 3NF</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-主从复制"><span class="toc-text">1.7 主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-1-主从复制的方式"><span class="toc-text">1.7.1 主从复制的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-2-主从复制的作用"><span class="toc-text">1.7.2 主从复制的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-3-主从复制原理"><span class="toc-text">1.7.3 主从复制原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-半同步复制"><span class="toc-text">1.8 半同步复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-Mysql查询缓存"><span class="toc-text">1.9 Mysql查询缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、非关系型数据库（Redis为例）"><span class="toc-text">二、非关系型数据库（Redis为例）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-缓存"><span class="toc-text">2.1 缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-缓存的类型"><span class="toc-text">2.1.1 缓存的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-常见缓存策略"><span class="toc-text">2.1.2 常见缓存策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-缓存预热、穿透、击穿和雪崩"><span class="toc-text">2.1.3 缓存预热、穿透、击穿和雪崩</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Redis"><span class="toc-text">2.2 Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-Redis的五种数据结构"><span class="toc-text">2.2.1 Redis的五种数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-Redis的单线程和高性能"><span class="toc-text">2.2.2 Redis的单线程和高性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-Redis淘汰策略"><span class="toc-text">2.2.2 Redis淘汰策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-数据库与缓存一致性解决方案"><span class="toc-text">2.2.3 数据库与缓存一致性解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-持久化"><span class="toc-text">2.2.4 持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-4-1-RDB快照"><span class="toc-text">2.2.4.1 RDB快照</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-4-2-AOF日志（主流）"><span class="toc-text">2.2.4.2 AOF日志（主流）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-5-哨兵模式"><span class="toc-text">2.2.5 哨兵模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-6-Redis数据过期策略"><span class="toc-text">2.2.6 Redis数据过期策略</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://www.lgstatic.com/i/image2/M01/8A/CA/CgoB5l14rXSAWVk7AAFdi6Ly8iM148.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">rnang0 Blog</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-mars"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">春招复习8：数据库与缓存</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-08-03 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-08-03</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-12-29 19:37:01"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-12-29</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/">春招复习</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="数据库与缓存"><a href="#数据库与缓存" class="headerlink" title="数据库与缓存"></a>数据库与缓存</h1><h2 id="重点学习内容"><a href="#重点学习内容" class="headerlink" title="重点学习内容"></a>重点学习内容</h2><ul>
<li>事务隔离级别</li>
<li>索引</li>
<li>Mysql三范式</li>
<li>主从复制</li>
<li>SQL语句的优化</li>
<li>缓存策略</li>
<li>缓存穿透、击穿和雪崩</li>
<li>Redis淘汰策略</li>
<li>Redis持久化</li>
</ul>
<h2 id="一、关系型数据库（Mysql为例）"><a href="#一、关系型数据库（Mysql为例）" class="headerlink" title="一、关系型数据库（Mysql为例）"></a>一、关系型数据库（Mysql为例）</h2><h3 id="1-1-事务的四大特性"><a href="#1-1-事务的四大特性" class="headerlink" title="1.1 事务的四大特性"></a>1.1 事务的四大特性</h3><ul>
<li><strong>原子性（Atomicity）：</strong>事务中所有操作是不可再分割的原子单位。事务中所有操作要么全部执行成功，要么全部执行失败。</li>
<li><strong>一致性（Consistency）：</strong>事务执行后，数据库状态与其它业务规则保持一致。如转账业务，无论事务执行成功与否，参与转账的两个账号余额之和应该是不变的。</li>
<li><strong>隔离性（Isolation）：</strong>隔离性是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰。</li>
<li><strong>持久性（Durability）：</strong>一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在数据库重启时，也必须能保证通过某种机制redo log恢复数据。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200323172115711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTg5NzM4,size_16,color_FFFFFF,t_70" alt=""></p>
<p>​    总结：原子性和持久性是通过日志恢复实现，隔离性是通过并发控制（锁）来实现的，而原子性、隔离性、持久性巩固实现一致性。</p>
<h4 id="1-1-1-undo-log"><a href="#1-1-1-undo-log" class="headerlink" title="1.1.1 undo log"></a>1.1.1 undo log</h4><p>​    <strong>原子性的实现原理，undo log存储的是数据库的备份数据，通过此日志可以恢复到事务开始的状态（回滚的实现）。</strong></p>
<p>所以它存的就是相反的sql语句，例如插入一条数据，undo log里面就是存的删除语句（因为执行删除才能恢复到原样）。</p>
<h4 id="1-1-2-redo-log"><a href="#1-1-2-redo-log" class="headerlink" title="1.1.2 redo log"></a>1.1.2 redo log</h4><p>​    持久性的实现原理，redo log存储的是新数据的备份，因为在提交前<strong>将redo log持久化，不需要数据进行持久化。</strong></p>
<img src="https://img-blog.csdnimg.cn/20200323175153122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTg5NzM4,size_16,color_FFFFFF,t_70" style="zoom:200%;" />

<h3 id="1-2-事务隔离级别"><a href="#1-2-事务隔离级别" class="headerlink" title="1.2 事务隔离级别"></a>1.2 事务隔离级别</h3><p>然而<strong>完全的隔离性会导致并发的性能很低</strong>，事务隔离级别从低到高分别是：</p>
<p>​    <strong>读未提交Read uncommitted:</strong> 读写锁均在<strong>操作完成后</strong>立即释放。</p>
<p>​    <strong>读已提交Read committed:</strong> 防止脏读。<strong>读锁在读完成后</strong>立即释放，<strong>写锁持续到事务结束</strong>释放。Oracle和sql server的默认隔离等级。</p>
<p>​    <strong>可重复读Repeatable read: （Mysql默认）</strong>防止脏读、不可重复读。读写锁均<strong>持续到事务结束释放。</strong></p>
<p>​    <strong>串行化Serializable: **防止脏读、不可重复读和幻读。不再锁定行，而是</strong>锁定表。直接将表操作串行**。</p>
<img src="https://img-blog.csdnimg.cn/20200323180645368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTg5NzM4,size_16,color_FFFFFF,t_70" style="zoom:200%;" />

<p>解释几个概念：</p>
<ul>
<li><strong>脏读（查找）：</strong>读到其他事务未提交的数据，拿到不该拿的东西</li>
<li><strong>不可重复读（修改、删除）：</strong>同一事务对同一数据前后读取结果不一致，比如在其他事物提交前后进行读取。</li>
<li><strong>幻读（插入）：</strong>像是产生幻觉，事务A对表操作时，事务B添加了新的记录，都能受到B的操作影响了，比如A进行插入时ID与B中刚插入重复，失败。</li>
</ul>
<p>隔离性实现原理：锁</p>
<p>​    <strong>InnoDB的锁机制：共享锁（读锁）+排它锁（写锁，更新操作默认），既支持表锁也支持行锁</strong></p>
<img src="https://img-blog.csdnimg.cn/20200324000836985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTg5NzM4,size_16,color_FFFFFF,t_70" style="zoom:150%;" />

<h3 id="1-3-Mysql常见引擎"><a href="#1-3-Mysql常见引擎" class="headerlink" title="1.3 Mysql常见引擎"></a>1.3 Mysql常见引擎</h3><p>​    引擎是对于数据库的<code>表结构</code>来说的。</p>
<h4 id="1-3-1-InnoDB（支持事务）"><a href="#1-3-1-InnoDB（支持事务）" class="headerlink" title="1.3.1 InnoDB（支持事务）"></a>1.3.1 InnoDB（支持事务）</h4><p>​    支持事务、外键，支持表级锁和行级锁。如果表中既无主键也无索引，将自动创建一个隐藏主键列。<strong>适合执行大量的delete和update，适合大尺寸数据库。</strong></p>
<p>​    InnoDB索引实现(聚集) ，表数据文件本身就是按B+Tree组织的一个索引结构文件，是聚集索引<strong>（叶节点包含了完整的数据记录，不用再二次访问）</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20200323154939959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTg5NzM4,size_16,color_FFFFFF,t_70" alt=""></p>
<p>常问的面试题：</p>
<p>①<strong>为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？</strong></p>
<ol>
<li>因为整型的存储比字段类型要小，而且应为是InnoDB存储引擎使用的是B+Tree数据结构，在进行查询数据是需要<strong>对每个元素进行比较</strong>，而<strong>整型的对比效率是高于其他数据结构的</strong>，字符串等</li>
<li>而且由于<strong>自增的主键而言，B+树是有序的，插入数据也非常方便，范围查找高效</strong></li>
<li>Mysql是通过B+树组织这些索引的，如果不设定主键Mysql也会<strong>默认生成主键比如rowid等</strong>；</li>
</ol>
<p>②<strong>为什么非主键索引结构叶子节点存储的是主键值而不是数据？</strong>(保障数据一致性、用时间换空间)<br>   INNODB文件和数据文件是聚集的，每个INNODB表可分为两个文件：<strong>.frm（表结构），.ibd（表索引和数据）</strong>，主键索引叶子节点存储的是<strong>主键（key）和数据（value）</strong>，非主键索引的叶子节点存储的是<strong>索引的数据 + 主键(value，比如15)</strong>，这样得到主键的值之后再到主键索引树去搜索一遍，这个过程也成为<strong>回表</strong>。</p>
<h4 id="1-3-2-MyIsam（不支持事务）"><a href="#1-3-2-MyIsam（不支持事务）" class="headerlink" title="1.3.2 MyIsam（不支持事务）"></a>1.3.2 MyIsam（不支持事务）</h4><p>​    MyISAM索引和数据文件是分离的(非聚集)，mysql的数据文件是存储在data目录下的，data下每个文件夹存储的就是每个数据库的文件，一个MyISAM表可分为三个文件：<strong>.frm</strong>（表结构），<strong>.MYI</strong>（表索引），<strong>.MYD</strong>（表数据）；</p>
<p>​    <strong>每个叶子节点存储的都是数据的磁盘指针</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200323154756262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTg5NzM4,size_16,color_FFFFFF,t_70" alt=""></p>
<p>​    总结：不支持事务、外键，仅支持表级锁。允许无索引无主键表的存在。数据是可被压缩的，存储空间较小。<strong>适合执行大量的select和insert</strong>。</p>
<h4 id="1-3-2-Memory"><a href="#1-3-2-Memory" class="headerlink" title="1.3.2 Memory"></a>1.3.2 Memory</h4><p>​    <strong>数据存放在内存</strong>，访问速度极快，默认使用<strong>hash索引</strong>。适合需要频繁使用的少量、可允许丢失的临时数据。</p>
<h3 id="1-4-常用数据库优化方式"><a href="#1-4-常用数据库优化方式" class="headerlink" title="1.4 常用数据库优化方式"></a>1.4 常用数据库优化方式</h3><p>​    <strong>选取最适用的字段属性：</strong>字段应设置得尽可能小；尽量把字段设置为NOT NULL，这样数据库无需去比较NULL；尽可能使用ENUM代替文本类型。</p>
<ol>
<li><p><strong>使用连接(join)代替子查询：</strong>join不会在内存中创建临时表，所以效率更高。</p>
</li>
<li><p><strong>在有索引的字段尽量不使用函数操作</strong></p>
</li>
<li><p><strong>字符型字段模糊匹配时可使用以下技巧：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200802213452161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>正确使用索引</strong></p>
</li>
<li><p><strong>分区分表：</strong>对于数据量极大的表，应分区分表存储（垂直分表、水平分表）</p>
</li>
</ol>
<h3 id="1-5-索引"><a href="#1-5-索引" class="headerlink" title="1.5 索引"></a>1.5 索引</h3><h4 id="1-5-1-索引种类"><a href="#1-5-1-索引种类" class="headerlink" title="1.5.1 索引种类"></a>1.5.1 索引种类</h4><p>​    <strong>普通索引,index：</strong>对关键字没有要求。</p>
<p>​    <strong>唯一索引,unique index：</strong>要求关键字不能重复。同时增加唯一约束。</p>
<p>​    <strong>主键索引,primary key：</strong>要求关键字不能重复，也不能为NULL。同时增加主键约束。</p>
<p>​    <strong>全文索引,fulltext key：</strong>关键字的来源不是所有字段的数据，而是从字段中提取的特别关键词。</p>
<p>主键索引不能为空值，唯一索引允许空值；主键索引在一张表内只能创建一个，唯一索引可以创建多个。主键索引肯定是唯一索引，但唯一索引不一定是主键索引。</p>
<h4 id="1-5-2-索引使用原则"><a href="#1-5-2-索引使用原则" class="headerlink" title="1.5.2 索引使用原则"></a>1.5.2 索引使用原则</h4><ol>
<li><p>列独立：有字段参与的表达中，字段独立在一侧（如where num+1 = 20无法使用索引）</p>
</li>
<li><p>左原则：like模糊匹配不得以通配符开头（如field like ‘%keywork’需要使用全文索引）</p>
</li>
<li><p>OR：使用or时，左右两端都需要能够使用索引。</p>
</li>
<li><p>有时mysql会智能选择是否使用索引。</p>
</li>
</ol>
<h4 id="1-5-3-B-树"><a href="#1-5-3-B-树" class="headerlink" title="1.5.3 B+树"></a>1.5.3 B+树</h4><ul>
<li>红黑树缺点</li>
</ul>
<p>​    如果采用普通的树，或者红黑树来存储索引的话，树的高度h就会很高，每次查找都会进行一次I/O操作访问磁盘，影响性能。</p>
<p>故就需要树横向发展，“平铺开来”，于是考虑B树</p>
<ul>
<li><p>B树</p>
<p>①叶节点具有相同的深度，叶节点的指针为空。<br>②所有<strong>索引元素不重复</strong>，也就不是冗余的。<br>③节点中的数据索引从左到右递增排列。<br>它的存储结构如下图所示，每个节点的索引和数据都存储在一起。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200323124158388.png" alt=""></p>
<p>缺点：虽然B树解决了索引量的存储问题，但是进行范围查询时例如<code>where ID &gt; 15</code>时，需要每次进行重新返回根结点查询，性能较低。</p>
<ul>
<li><p>B+树</p>
<p>MySQL索引并没有采用B树而是<strong>采用B+树</strong>，B+树相对于B树具有以下特点：</p>
<p>①<strong>非叶子节点不存储data,只存储索引(冗余)</strong>，可以放更多的索引。<br>②叶子节点包含所有索引字段，且节点索引依次递增。<br>③<strong>叶子节点用指针连接</strong>，提高<strong>区间访问</strong>的性能。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200323125011779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTg5NzM4,size_16,color_FFFFFF,t_70" alt=""></p>
<p>​    在Mysql中，<strong>索引一般为bigint类型占8个字节</strong>，对于<strong>索引后面的指针占用6个字节</strong>，而Mysql给第一层大节点的限制内存大小为16KB，因此大概可以存储16KB/(6+8)B=1170个索引，同样第二层也可以存储1170个，而对于高度为3的B+树来说，假设第三层的<strong>索引和数据占用1KB大小</strong>，可以存放16KB/1KB=16个索引(加数据)，因此总共可以存储1170 x 1170 x 16 = 21,902,400个数据，2000多万条数据，令人诧异！！</p>
<p>​    <strong>注意：Mysql中极少情况下也可以用Hash表来存储，但像B树一样不适合于范围查询。</strong></p>
<h4 id="1-5-4-聚集与非聚集索引"><a href="#1-5-4-聚集与非聚集索引" class="headerlink" title="1.5.4 聚集与非聚集索引"></a>1.5.4 聚集与非聚集索引</h4><p>非聚集索引：叶子节点里，只是指向数据的地址，并非有真正的数据，MyISAM引擎采用</p>
<p><strong>聚集索引：叶子节点的data里放的索引所在行的完整数据字段，不用二次访问。InnoDB引擎采用</strong></p>
<p>​    每个表只能有1个聚集索引。可以有多个非聚集索引。</p>
<p> <img src="https://img-blog.csdnimg.cn/20200802213542789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>联合索引</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200323155012585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTg5NzM4,size_16,color_FFFFFF,t_70" alt=""></p>
<p>​    联合索引非叶子节点存储的是联合<strong>索引</strong>（key）和<strong>主键</strong>（value），其索引的顺序是按索引常见的顺序排的，先按第一个索引排序，再按第二个索引排序…<br>​    <strong>对于Hash索引的话，不支持区间范围查询，但是速度的确比B+树要快</strong>，B+树的双向链表<strong>支持范围查询</strong>，但是仅仅简单查询的话，Hash索引还是比B+树索引要快的。</p>
<h3 id="1-6-数据库三范式"><a href="#1-6-数据库三范式" class="headerlink" title="1.6 数据库三范式"></a>1.6 数据库三范式</h3><h4 id="1-6-1-1NF"><a href="#1-6-1-1NF" class="headerlink" title="1.6.1 1NF"></a>1.6.1 1NF</h4><p>​    数据库表的每一列都是不可分割的原子数据项，例如不能出现学生字段，数据为“张三 男 18岁”。</p>
<h4 id="1-6-2-2NF"><a href="#1-6-2-2NF" class="headerlink" title="1.6.2 2NF"></a>1.6.2 2NF</h4><p>​    在1NF的基础上，非主键字段完全依赖于主键，不能是联合主键。</p>
<h4 id="1-6-1-3NF"><a href="#1-6-1-3NF" class="headerlink" title="1.6.1 3NF"></a>1.6.1 3NF</h4><p>​    在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上<strong>消除传递依赖</strong>）</p>
<h3 id="1-7-主从复制"><a href="#1-7-主从复制" class="headerlink" title="1.7 主从复制"></a>1.7 主从复制</h3><h4 id="1-7-1-主从复制的方式"><a href="#1-7-1-主从复制的方式" class="headerlink" title="1.7.1 主从复制的方式"></a>1.7.1 主从复制的方式</h4><p> <img src="https://img-blog.csdn.net/20180419105602774?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhcmtBbmdlbDEyMjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<h4 id="1-7-2-主从复制的作用"><a href="#1-7-2-主从复制的作用" class="headerlink" title="1.7.2 主从复制的作用"></a>1.7.2 主从复制的作用</h4><ol>
<li>数据热备</li>
<li>多库存储，<strong>读写分离</strong></li>
</ol>
<p>读写分离技术：适用于写多读少的数据库，利用了主从复制的原理，实现了多库存储。</p>
<h4 id="1-7-3-主从复制原理"><a href="#1-7-3-主从复制原理" class="headerlink" title="1.7.3 主从复制原理"></a>1.7.3 主从复制原理</h4><ol>
<li>主数据库操作，sql语句写入数据库的同时，写入binlog二进制文件，主要是一些SQL语句（写库，所以是增删改）。</li>
<li>主库通过<strong>I/O线程</strong>发送binlog，写入至从库replay log</li>
<li>从库执行SQL线程将replay log，写入至从库的bin log data中。</li>
</ol>
<p><img src="https://img-blog.csdn.net/2018041911065697?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhcmtBbmdlbDEyMjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>但主从复制也会引发问题，<strong>比如脏读，牺牲了数据库的一致性，产生延迟。</strong></p>
<h3 id="1-8-半同步复制"><a href="#1-8-半同步复制" class="headerlink" title="1.8 半同步复制"></a>1.8 半同步复制</h3><p>​    解决主库宕机后数据丢失的问题（bin log没传走）：</p>
<p>至少有一个<strong>确认从库的relay log接收到bin log后，用户线程才返回success</strong>，但会带来更高的延迟。</p>
<h3 id="1-9-Mysql查询缓存"><a href="#1-9-Mysql查询缓存" class="headerlink" title="1.9 Mysql查询缓存"></a>1.9 Mysql查询缓存</h3><p>Mysql会缓存sql语句的hash值和查询结果。但有两个弊端：</p>
<ol>
<li><p>对表有任何改动都会清空该表的所有缓存。</p>
</li>
<li><p>依靠sql语句的hash值查询缓存结果，两条sql语句必须大小写和空格格式完全相同才可查询到。</p>
</li>
</ol>
<h2 id="二、非关系型数据库（Redis为例）"><a href="#二、非关系型数据库（Redis为例）" class="headerlink" title="二、非关系型数据库（Redis为例）"></a>二、非关系型数据库（Redis为例）</h2><h3 id="2-1-缓存"><a href="#2-1-缓存" class="headerlink" title="2.1 缓存"></a>2.1 缓存</h3><h4 id="2-1-1-缓存的类型"><a href="#2-1-1-缓存的类型" class="headerlink" title="2.1.1 缓存的类型"></a>2.1.1 缓存的类型</h4><ol>
<li><p>本地缓存：在进程的内存中实现缓存。优点：本地访问，无远程交互开销。缺点：容量较小</p>
</li>
<li><p>分布式缓存：采用分布式系统管理缓存。</p>
</li>
<li><p>多级缓存：访问频率较高的数据使用本地缓存，其余使用分布式缓存。</p>
</li>
</ol>
<h4 id="2-1-2-常见缓存策略"><a href="#2-1-2-常见缓存策略" class="headerlink" title="2.1.2 常见缓存策略"></a>2.1.2 常见缓存策略</h4><ol>
<li><p>基于访问时间</p>
</li>
<li><p>基于访问频率</p>
</li>
<li><p>时间与频率兼顾</p>
</li>
<li><p>基于访问模式（针对某些有明确访问特点的数据）</p>
</li>
</ol>
<h4 id="2-1-3-缓存预热、穿透、击穿和雪崩"><a href="#2-1-3-缓存预热、穿透、击穿和雪崩" class="headerlink" title="2.1.3 缓存预热、穿透、击穿和雪崩"></a>2.1.3 缓存预热、穿透、击穿和雪崩</h4><ul>
<li><strong>缓存预热：</strong>缓存系统启动前，提前将相关缓存数据加载到缓存系统，避免在系统开启时，先查询数据库。</li>
</ul>
<p>步骤：</p>
<ol>
<li>前置准备：统计数据的访问记录，统计高热点数据；利用LRU删除策略，留存数据建立队列，依次放到文件事件分派器，事件分派器将事件分发给事件处理器。</li>
<li>准备工作：将热点数据分级，优先加载级别较高的数据</li>
<li>实施：数据预热（使用脚本）</li>
</ol>
<ul>
<li><strong>缓存雪崩：</strong>较短时间内，<strong>大量热点数据集中过期</strong>，造成一瞬间DB压力陡增。</li>
</ul>
<p>​    解决方法：</p>
<ol>
<li>数据过期时间随机设置，防止大量数据同时过期</li>
<li>热点数据均匀分布在不同数据库</li>
<li>设置热点数据永不过期</li>
<li>加锁限流，只允许一个线程查询和写缓存，慎用。</li>
</ol>
<ul>
<li><strong>缓存击穿：</strong>缓存中的某个热点数据到期后，大量请求同时发向DB（缓存没有DB有）。</li>
</ul>
<p>​    解决方法：</p>
<ol>
<li><p>设置热点数据永不过期</p>
</li>
<li><p>加互斥锁（分布式锁）<strong>SETNX</strong>，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(key)</span> </span>&#123;</span><br><span class="line">      String value = redis.get(key);</span><br><span class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">//代表缓存值过期</span></span><br><span class="line">          <span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line">      		<span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;  <span class="comment">//代表设置成功</span></span><br><span class="line">               value = db.get(key);</span><br><span class="line">               redis.set(key, value, expire_secs);</span><br><span class="line">               redis.del(key_mutex);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;  <span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">               sleep(<span class="number">50</span>);</span><br><span class="line">               get(key);  <span class="comment">//重试</span></span><br><span class="line">              &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> value;      </span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><strong>缓存穿透：</strong>大量访问一个<strong>不存在的key（缓存和DB都不存在）</strong>，请求会大量穿透到DB，例如</li>
</ul>
<p>解决方法：</p>
<ol>
<li>访问key未查询到值，也将空值null写入缓存并返回，赋予较短的过期时间，但会导致一段时间不一致性。</li>
<li>采用过滤器，维护一个集合保存<strong>所有可能被访问到的key，不存在的key直接过滤掉。</strong>命中率可以忽略</li>
</ol>
<p>例如布隆过滤器：</p>
<p>对一个key进行k个hash算法获取到k个值的位置，设定为1，如果查询的key的k个位置全为1则说明有，但是会出现误判。</p>
<p><img src="https://img-blog.csdnimg.cn/20200526185103601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTg5NzM4,size_16,color_FFFFFF,t_70" alt=""></p>
<h3 id="2-2-Redis"><a href="#2-2-Redis" class="headerlink" title="2.2 Redis"></a>2.2 Redis</h3><h4 id="2-2-1-Redis的五种数据结构"><a href="#2-2-1-Redis的五种数据结构" class="headerlink" title="2.2.1 Redis的五种数据结构"></a>2.2.1 Redis的五种数据结构</h4><p>​    数据结构都是说的是Redis中的value的数据结构，Redis本身就是一个Map，只不过他的key永远都是String类型的。</p>
<img src="https://img-blog.csdnimg.cn/20200424171756456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTg5NzM4,size_16,color_FFFFFF,t_70"  />

<ol>
<li>String：将Json数据序列化为字符串，塞进 Redis 来缓存。</li>
</ol>
<p><strong>（1）批量键值对mget和mset</strong>：可以批量对多个字符串进行读写，节省网络耗时开销 </p>
<p><strong>（2）过期和 set 命令扩展expire或者是setex</strong>：可以对 key 设置过期时间，到点自动删除，这个功能常用来控制缓存的失效时间。</p>
<p>（3）value 值是一个整数，还可以对它进行自增操作。自增是有范围的，它的范围是 signed long 的最大最小值</p>
<ol start="2">
<li>List：底层quickList，一种由<strong>zipList构成的双向链表</strong>（即每一个元素都是一个zipList），类似于LinkedList</li>
</ol>
<p>（1）常常用作<strong>消息队列</strong>使用：需要延后处理的任务，序列化成list，然后另一个线程就轮询这个list，拿取。</p>
<p>（2）一般使用 rpop，rpush和lpop，lpush来实现 一边进一边出 的栈和 一边进另一边出 的队列</p>
<ol start="3">
<li>Hash：底层使用的是数组 + 链表，类似于HashMap，无序，拉链法解决hash碰撞。</li>
</ol>
<p>（1）key依然是字符串，value是个hash表</p>
<p>（2）Hash可以对用户字段进行单独存储，例如hset userId username “张三”，就可以<strong>实现部分数据获取，避免整个获取浪费网络流量。</strong></p>
<p>缺点也是显而易见，字段单独存储，存储消耗很高。</p>
<ol start="4">
<li><p>Set：底层hashtable，无序的，适合于查询操作。</p>
<p><strong>它的内部实现相当于一个特殊的hash表，字典中所有的 value 都是一个值NULL。</strong></p>
</li>
<li><p>Zset：底层使用<strong>跳表</strong>或zipList，有序的且唯一，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 <strong>score，代表这个 value 的排序权重</strong>，可以用来排序。</p>
</li>
</ol>
<p><strong>List、Set、ZSet的比较</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200720193947363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTg5NzM4,size_16,color_FFFFFF,t_70" alt=""></p>
<h4 id="2-2-2-Redis的单线程和高性能"><a href="#2-2-2-Redis的单线程和高性能" class="headerlink" title="2.2.2 Redis的单线程和高性能"></a>2.2.2 Redis的单线程和高性能</h4><p><strong>1. Redis 单线程为什么还能这么快？</strong><br> ●因为它所有的数据都在<strong>内存</strong>中，所有的运算都是<strong>内存级别的运算</strong><br> ●而且<strong>单线程避免了多线程的切换性能损耗问题</strong>。正因为 Redis 是单线程，所以要小心使用 Redis 指令，对于那些耗时的指令(比如keys)，一定要谨慎使用，一不小心就可能会导致 Redis 卡顿。</p>
<p><strong>2. Redis 单线程如何处理那么多的并发客户端连接？</strong><br>  <strong>Redis的IO多路复用</strong>：redis利用<strong>epoll</strong>来实现IO多路复用，<strong>将连接信息和事件放到队列中</strong>，依次放到文件事件分派器，事件分派器将事件分发给事件处理器。<br>    Nginx也是采用IO多路复用原理解决C10K问题</p>
<p><img src="https://img-blog.csdnimg.cn/20200424191015278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTg5NzM4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-2-2-Redis淘汰策略"><a href="#2-2-2-Redis淘汰策略" class="headerlink" title="2.2.2 Redis淘汰策略"></a>2.2.2 Redis淘汰策略</h4><ul>
<li>检查volatile易失数据（有时效的，有expires的）</li>
</ul>
<ol>
<li>volatile-lru：淘汰掉设置了过期时间的<strong>最近里最少使用</strong>数据</li>
<li>volatile-lfu：淘汰掉设置了过期时间的<strong>一段时间里最少使用</strong>数据</li>
<li>volatile-ttl：淘汰掉设置了过期时间的<strong>将要过期</strong>的数据</li>
<li>volatile-random：<strong>随机</strong>淘汰掉设置了过期时间的数据</li>
</ol>
<ul>
<li>检查全库的数据（所有的数据集）</li>
</ul>
<ol>
<li>allkeys-lru：从全部数据中淘汰掉<strong>最近里最少使用</strong>数据</li>
<li>allkeys-lfu：从全部数据中淘汰掉<strong>一段时间里最少使用</strong>数据</li>
<li>allkeys-random：从全部数据中<strong>随机</strong>淘汰数据</li>
</ol>
<ul>
<li>放弃数据驱逐</li>
</ul>
<ol>
<li>no-enviction（驱逐）：不淘汰数据，<strong>对写入报错（OOM）</strong></li>
</ol>
<h4 id="2-2-3-数据库与缓存一致性解决方案"><a href="#2-2-3-数据库与缓存一致性解决方案" class="headerlink" title="2.2.3 数据库与缓存一致性解决方案"></a>2.2.3 数据库与缓存一致性解决方案</h4><p>​    先删除缓存，在更新数据库。更新数据库的操作与缓存查询数据库的操作在同一队列。</p>
<h4 id="2-2-4-持久化"><a href="#2-2-4-持久化" class="headerlink" title="2.2.4 持久化"></a>2.2.4 持久化</h4><p>​    RDB机制 == 内存数据库完整备份<strong>（全部数据）</strong></p>
<p>​    AOF机制 == 内存数据库日志备份<strong>（每一条指令）</strong></p>
<h5 id="2-2-4-1-RDB快照"><a href="#2-2-4-1-RDB快照" class="headerlink" title="2.2.4.1 RDB快照"></a>2.2.4.1 RDB快照</h5><p>​    Save操作。默认情况下， Redis 将<strong>内存数据库快照保存</strong>在名字为 <strong>dump.rdb</strong> 的二进制文件中（并且启动时加载文件），并且可以设置时间间隔和改动数。</p>
<ol>
<li><p>RDB优点：</p>
<p><strong>（1）RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集</strong>。 </p>
<p>（2）RDB 可以最大化 Redis 的性能，保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后<strong>这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。</strong></p>
<p>（3）RDB 在<strong>恢复大数据集</strong>时的速度比 AOF 的恢复速度要快。</p>
</li>
<li><p><strong>RDB 的缺点:</strong></p>
<p>（1）如果需要<strong>尽量避免在服务器故障时丢失数据</strong>，那么 RDB 不适合，因为RDB 文件需要保存<strong>整个数据集的状态</strong>， 所以它可能会<strong>至少 5 分钟才保存一次 RDB 文件</strong>。 在这种情况下， 一旦发生故障宕机， 你就可能会丢失好几分钟的数据。</p>
<p>（2）每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 <strong>在数据集比较庞大时， fork() 可能会非常耗时。</strong></p>
</li>
</ol>
<h5 id="2-2-4-2-AOF日志（主流）"><a href="#2-2-4-2-AOF日志（主流）" class="headerlink" title="2.2.4.2 AOF日志（主流）"></a>2.2.4.2 AOF日志（主流）</h5><p>​    Redis 因为RDB而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。那么Redis 采用了实时性的<strong>启动优先级高</strong>的持久化方式： AOF 持久化，将修改的<strong>每一条指令记录</strong>进文件，避免了save才去保存的非实时性且数据集大的特点。</p>
<p>​    每当 Redis 执行一个改变数据集的命令时（比如 SET）， 这个命令就会被追加到<strong>AOF写命令刷新缓存区里</strong>，然后再将命令同步到.aof文件中。重启时， 程序就可以通过<strong>重新执行 AOF 文件中的命令</strong>来达到重建数据集的目的。</p>
<p>​    AOF写数据的三种策略（appendfsync）</p>
<ul>
<li>appendfsync always</li>
<li>appendfsync everysec</li>
<li>appendfsync no</li>
</ul>
<p>always 每写入一条数据，立即将这个数据对应给的写日志fsync到磁盘上去，<strong>性能会变得很差</strong>，但是可以确保说每一条数据都不会丢失</p>
<p>everysec <strong>每秒</strong>将os cache中的数据fsync到磁盘，这个最常用，<strong>生产环境下一般都使用这种策略，性能很高</strong>。</p>
<p>no 仅仅负责将数据写到os cache就可以了，不进行fsync等待操作系统对这些数据写入磁盘，这种策略，会让我们的数据不可控，因为无法预知操作系统什么时候会把数据刷到磁盘。</p>
<ol>
<li>重写</li>
</ol>
<p>​    很多数据可能会自动过期，也有可能会被用户删除，但是这些操作都会被AOF文件记录下来会出现AOF记录的命令体积<strong>超出保存数据集状态</strong>的情况，而且重建数据集根本不需要执行所有下，会进行一个<strong>重写</strong>（rewrite）操作,确保文件不会太大。</p>
<p>​    重写的过程：</p>
<p>（1）fork一个子进程，子进程基于<strong>当前内存中的数据</strong>往一个<strong>新的临时AOF文件中写入日志</strong>；主进程如果<strong>接收到client的写操作</strong>，<strong>在内存中写入日志</strong>，同时新的日志也继续写入旧的AOF文件；</p>
<p>（2）子进程完成新的日志文件之后，主进程<strong>将内存中的新日志再次追加到新的AOF文件中</strong>；用新的日志文件替换旧的日志文件。</p>
<ol start="2">
<li><p>AOF 的优点:</p>
<p><strong>AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求），它也是轻量级的。</strong></p>
</li>
<li><p>AOF 的缺点:</p>
<p><strong>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积，从而恢复速度就会很慢。</strong></p>
</li>
</ol>
<h4 id="2-2-5-哨兵模式"><a href="#2-2-5-哨兵模式" class="headerlink" title="2.2.5 哨兵模式"></a>2.2.5 哨兵模式</h4><p>​    采用哨兵进程监控主redis服务器和从redis服务器。<strong>当主服务器宕机，哨兵通知其他从服务器切换为主机。（哨兵之间也会互相监控）</strong></p>
<p>哨兵机制：</p>
<ol>
<li><p>监控：同步各个节点的状态信息：<strong>先检查各个的哨兵状态哨兵，看是否在线；获取master的状态，最后获取所以slave状态。</strong></p>
<p>工作顺序：</p>
<p>（1）info知道状况，建立cmd连接</p>
<p>（2）哨兵端：保存所有的哨兵状态；Master端：保存Redis实例（即主从缓存服务器）</p>
<p>（3）连接每个slave，使得哨兵信息完整</p>
<p>（4）其它哨兵再与主机建立cmd连接</p>
<p>（5）哨兵间互发ping命令，确认状况</p>
</li>
<li><p>通知：<strong>当被监控的服务器出现问题时，向其他哨兵发送通知</strong></p>
<p>哨兵会向主从服务器发送hello指令，以确保其状态，然后在哨兵之间网络进行消息互通。</p>
</li>
<li><p>自动故障转移：<strong>断开master与slave，选一个当master（投票），告知连接新的master，告知客户端新的地址。</strong></p>
<p>若hello无响应，将master的标志位置为主观down，则其他哨兵也去“问候”主机，确认挂了，则设置为客观down。</p>
<p>哨兵之间竞选（主要根据竞选次数与投票接受顺序），得到投票结果，则执行哨兵选取新的master，其他slave再切换主机。</p>
</li>
</ol>
<h4 id="2-2-6-Redis数据过期策略"><a href="#2-2-6-Redis数据过期策略" class="headerlink" title="2.2.6 Redis数据过期策略"></a>2.2.6 Redis数据过期策略</h4><ol>
<li><p>定时删除：定时遍历redis，查看有无过期数据，删除之。</p>
</li>
<li><p>惰性删除：数据被get即被访问时时，再检查其是否过期。</p>
<p>综合（定期删除 ）：定时<strong>随机抽取某个expires[*]中的</strong>数据检查有无过期删除，同时使用惰性删除。</p>
</li>
</ol>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">rnang0</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://rnang0.github.io/2020/08/03/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A08%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98/">http://rnang0.github.io/2020/08/03/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A08%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://rnang0.github.io" target="_blank">rnang0 Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Mysql/">Mysql</a><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/%E7%BC%93%E5%AD%98/">缓存</a></div><div class="post_share"><div class="social-share" data-image="https://img-blog.csdnimg.cn/2021012409181395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/09/11/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A09%EF%BC%9ATomcat%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/"><img class="prev_cover" src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2864077756,2277292526&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">春招复习9：Tomcat架构解析</div></div></a></div><div class="next-post pull_right"><a href="/2020/07/25/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A07%EF%BC%9AJava%E5%B9%B6%E5%8F%91/"><img class="next_cover" src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=4060513360,1461496884&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">春招复习7：Java并发</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/12/12/春招面经：OS + 计网 + 数据库Mysql + 缓存redis/" title="春招面经：OS + 计网 + 数据库Mysql + 缓存redis"><img class="relatedPosts_cover" src="https://img-blog.csdnimg.cn/20201228092946817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-12-12</div><div class="relatedPosts_title">春招面经：OS + 计网 + 数据库Mysql + 缓存redis</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By rnang0</div><div class="footer_custom_text">Hi, welcome to my <a href="http://rnang0.github.io/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script></body></html>