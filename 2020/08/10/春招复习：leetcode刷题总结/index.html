<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>leetcode刷题总结（持续更新...） | rnang0 Blog</title><meta name="description" content="leetcode刷题总结数据结构与算法代码实现 数组1. 遍历时需要用到其余位置的值，或者该位置的值此前是否被访问过​    可以考虑使用HashMap进行存储（哈希表时间复杂度为1），key或者value进行存储值，map中没有则put进去，有的话就取出来使用。 Map&lt;Integer,Integer&gt; map &#x3D; new HashMap&lt;Integer, Integer&amp;gt"><meta name="keywords" content="数据结构,算法,leetcode"><meta name="author" content="rnang0"><meta name="copyright" content="rnang0"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="leetcode刷题总结（持续更新...）"><meta name="twitter:description" content="leetcode刷题总结数据结构与算法代码实现 数组1. 遍历时需要用到其余位置的值，或者该位置的值此前是否被访问过​    可以考虑使用HashMap进行存储（哈希表时间复杂度为1），key或者value进行存储值，map中没有则put进去，有的话就取出来使用。 Map&lt;Integer,Integer&gt; map &#x3D; new HashMap&lt;Integer, Integer&amp;gt"><meta name="twitter:image" content="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=4254185095,1044467258&amp;fm=26&amp;gp=0.jpg"><meta property="og:type" content="article"><meta property="og:title" content="leetcode刷题总结（持续更新...）"><meta property="og:url" content="http://rnang0.gitee.io/2020/08/10/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0%EF%BC%9Aleetcode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"><meta property="og:site_name" content="rnang0 Blog"><meta property="og:description" content="leetcode刷题总结数据结构与算法代码实现 数组1. 遍历时需要用到其余位置的值，或者该位置的值此前是否被访问过​    可以考虑使用HashMap进行存储（哈希表时间复杂度为1），key或者value进行存储值，map中没有则put进去，有的话就取出来使用。 Map&lt;Integer,Integer&gt; map &#x3D; new HashMap&lt;Integer, Integer&amp;gt"><meta property="og:image" content="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=4254185095,1044467258&amp;fm=26&amp;gp=0.jpg"><meta property="article:published_time" content="2020-08-09T16:00:00.000Z"><meta property="article:modified_time" content="2020-09-20T01:35:05.105Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="canonical" href="http://rnang0.gitee.io/2020/08/10/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0%EF%BC%9Aleetcode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"><link rel="prev" title="春招复习9：Tomcat架构解析" href="http://rnang0.gitee.io/2020/09/11/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A09%EF%BC%9ATomcat%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/"><link rel="next" title="春招复习8：数据库与缓存" href="http://rnang0.gitee.io/2020/08/03/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A08%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'none',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/autor.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">71</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">101</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-mars"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode刷题总结"><span class="toc-text">leetcode刷题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-遍历时需要用到其余位置的值，或者该位置的值此前是否被访问过"><span class="toc-text">1. 遍历时需要用到其余位置的值，或者该位置的值此前是否被访问过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-数组题，一般就是左到右或者右到左扫描，通常我们就需要使用双指针，甚至三指针"><span class="toc-text">2. 数组题，一般就是左到右或者右到左扫描，通常我们就需要使用双指针，甚至三指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链表"><span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#链表结题技巧"><span class="toc-text">链表结题技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-双链表长度不一需要对位比较或者处理"><span class="toc-text">1. 双链表长度不一需要对位比较或者处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-链表分隔"><span class="toc-text">2. 链表分隔</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-反转链表（默写）"><span class="toc-text">3. 反转链表（默写）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-快慢指针（解决有环、对称、中间节点的问题）"><span class="toc-text">4. 快慢指针（解决有环、对称、中间节点的问题）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-解决是否有环问题"><span class="toc-text">4.1 解决是否有环问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-对称问题（求中间节点，默写）"><span class="toc-text">4.2 对称问题（求中间节点，默写）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-遍历时该位置的值此前是否被访问过，或者需要用到其余位置的值"><span class="toc-text">5. 遍历时该位置的值此前是否被访问过，或者需要用到其余位置的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-while循环遍历，条件是head-next-null-还是-head-null"><span class="toc-text">6. while循环遍历，条件是head.next !&#x3D; null 还是 head !&#x3D; null</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈、队列"><span class="toc-text">栈、队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-栈实现二叉树非递归遍历"><span class="toc-text">1.  栈实现二叉树非递归遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-单调栈实现某值左右（或者左右其中一个）第一个最值"><span class="toc-text">2. 单调栈实现某值左右（或者左右其中一个）第一个最值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-单调队列实现一段区间内的最大、最小值和排序"><span class="toc-text">3. 单调队列实现一段区间内的最大、最小值和排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树"><span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-完全二叉树性质"><span class="toc-text">1. 完全二叉树性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-二叉树遍历应用"><span class="toc-text">2. 二叉树遍历应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#哈希"><span class="toc-text">哈希</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆"><span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-优先队列"><span class="toc-text">1. 优先队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trie"><span class="toc-text">Trie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#排序"><span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-分割区间最好左闭右开-begin-end"><span class="toc-text">1. 分割区间最好左闭右开[begin, end)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-冒泡排序和插入排序优化"><span class="toc-text">2. 冒泡排序和插入排序优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-归并排序合并时避免，讨论右结束时左全挪动情况"><span class="toc-text">3. 归并排序合并时避免，讨论右结束时左全挪动情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-快排轴点随机设置，优化算法避免两边不均匀"><span class="toc-text">4. 快排轴点随机设置，优化算法避免两边不均匀</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并查集"><span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-尽量使用Quick-Union基于路径分裂-路径减半-基于rank优化或者size优化"><span class="toc-text">1. 尽量使用Quick Union基于路径分裂&#x2F;路径减半 + 基于rank优化或者size优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回溯"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-经典N皇后问题优化"><span class="toc-text">1. 经典N皇后问题优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#贪心"><span class="toc-text">贪心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分治"><span class="toc-text">分治</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态规划"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-dp-i-对于数组序列来说，一般定为以该值（nums-i-）结尾的满足条件的序列"><span class="toc-text">1. dp[i]对于数组序列来说，一般定为以该值（nums[i]）结尾的满足条件的序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-dp-i-j-还可以是多元的，例如两个数组序列的公共问题"><span class="toc-text">2. dp[i,j]还可以是多元的，例如两个数组序列的公共问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#串"><span class="toc-text">串</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=4254185095,1044467258&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">rnang0 Blog</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-mars"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">leetcode刷题总结（持续更新...）</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-08-10 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-08-10</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-09-20 09:35:05"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-09-20</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/">春招复习</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="leetcode刷题总结"><a href="#leetcode刷题总结" class="headerlink" title="leetcode刷题总结"></a>leetcode刷题总结</h1><p><a href="https://github.com/rnang0/DataStructure-Algorithm" target="_blank" rel="noopener">数据结构与算法代码实现</a></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1-遍历时需要用到其余位置的值，或者该位置的值此前是否被访问过"><a href="#1-遍历时需要用到其余位置的值，或者该位置的值此前是否被访问过" class="headerlink" title="1. 遍历时需要用到其余位置的值，或者该位置的值此前是否被访问过"></a>1. 遍历时需要用到其余位置的值，或者该位置的值此前是否被访问过</h3><p>​    可以考虑使用<strong>HashMap进行存储</strong>（哈希表时间复杂度为1），<strong>key或者value进行存储值</strong>，map中没有则put进去，有的话就取出来使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"><span class="keyword">int</span> length = nums.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">//value与nums[i]有关</span></span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(value)) &#123;</span><br><span class="line">        <span class="comment">//map.get(value)就为索引下标，value为值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有就put进去</span></span><br><span class="line">    map.put(nums[i],i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-数组题，一般就是左到右或者右到左扫描，通常我们就需要使用双指针，甚至三指针"><a href="#2-数组题，一般就是左到右或者右到左扫描，通常我们就需要使用双指针，甚至三指针" class="headerlink" title="2. 数组题，一般就是左到右或者右到左扫描，通常我们就需要使用双指针，甚至三指针"></a>2. 数组题，一般就是左到右或者右到左扫描，通常我们就需要使用双指针，甚至三指针</h3><p>​    例如颜色分类排序中，head指针把将<strong>小的放前面，tail指针把大的放后面</strong>，cur指针从头到尾来扫描</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tail = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> cur = head;</span><br><span class="line"><span class="comment">// cur等于tail时</span></span><br><span class="line"><span class="keyword">while</span> (cur &lt;= tail) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[cur] == <span class="number">0</span>) &#123;</span><br><span class="line">        swap(nums, cur, head);</span><br><span class="line">        <span class="comment">// 此时前面只能是0,1所以不需要再进行判断是否为2</span></span><br><span class="line">        head++;</span><br><span class="line">        cur++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[cur] == <span class="number">2</span>) &#123;</span><br><span class="line">        swap(nums, cur, tail);</span><br><span class="line">        tail--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="链表结题技巧"><a href="#链表结题技巧" class="headerlink" title="链表结题技巧"></a>链表结题技巧</h3><ul>
<li><strong>虚拟头结点</strong></li>
<li><strong>快慢指针（求中间节点）</strong></li>
<li><strong>多指针</strong></li>
<li><strong>检验边界情况：头、尾，传入一个节点进来处理，处理全部的节点</strong></li>
</ul>
<h3 id="1-双链表长度不一需要对位比较或者处理"><a href="#1-双链表长度不一需要对位比较或者处理" class="headerlink" title="1. 双链表长度不一需要对位比较或者处理"></a>1. 双链表长度不一需要对位比较或者处理</h3><p>​    两个数用链表存储例如345（3-&gt;4-&gt;5）和6789（6-&gt;7-&gt;8-&gt;9）相加，则将<strong>短的链表高位空位置为0</strong></p>
<p>​    例：345（0-&gt;3-&gt;4-&gt;5）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line"><span class="keyword">int</span> y = l2 == <span class="keyword">null</span> ? <span class="number">0</span> : l2.val;</span><br></pre></td></tr></table></figure>

<p>​    并且虚拟头结点newHead保存结果链表的开头，<strong>newHead的next才开始存储数据，然后 return newHead.next; 或者newHead.next开始遍历</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">ListNode newTail = newHead; <span class="comment">// 用newTail来指向链表尾部，且从newTail开始存数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newHead.next;</span><br></pre></td></tr></table></figure>

<h3 id="2-链表分隔"><a href="#2-链表分隔" class="headerlink" title="2. 链表分隔"></a>2. 链表分隔</h3><p>​    以某一值x，来分割链表，所有小于 x 的节点排在大于或等于 x 的节点之前，链表中包含 x，x 只需出现在小于 x 的元素之后。</p>
<p>​    <strong>思路：只需要使用双指针，类似于荷兰国旗题，小的挂在左尾指针后，大的挂在右尾指针后，最后连接左右两条链表即可。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode leftTail = leftHead;</span><br><span class="line">ListNode rightTail = rightHead;</span><br></pre></td></tr></table></figure>

<p>​    <strong>连接左右两条链表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">leftTail.next = rightHead.next;</span><br><span class="line">rightTail.next = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-反转链表（默写）"><a href="#3-反转链表（默写）" class="headerlink" title="3. 反转链表（默写）"></a>3. 反转链表（默写）</h3><ul>
<li>递归</li>
</ul>
<p>​    <strong>思路：递归的思路很简单，就是把除了这个节点后面的反转后，然后指向这个节点，一直到最后一个节点，或者传进来就是null。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3. 设置边界条件，递归到一个的时候，或者传进来是null了，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 后面整体反转：head.next为反转前的头，反转后的尾，新头是newHead</span></span><br><span class="line">ListNode newHead = reverseList(head.next);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 整体（反转后的尾）指向节点，所以就不能用newHead来指向</span></span><br><span class="line">head.next.next = head;</span><br><span class="line">head.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newHead;</span><br></pre></td></tr></table></figure>

<ul>
<li>迭代</li>
</ul>
<p>​    <strong>思路：只有一个head能用，所以就只能从head入手一个一个串起来，加一个指针newhead来实现。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode newhead = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//head为null了，就不用了，因为开始newhead已经是null了</span></span><br><span class="line"><span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 先保存后一个节点位置，避免丢失</span></span><br><span class="line">    ListNode temp = head.next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// head指向新的节点（开始为null）</span></span><br><span class="line">    head.next = newhead;</span><br><span class="line">    newhead = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// head迭代</span></span><br><span class="line">    head = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-快慢指针（解决有环、对称、中间节点的问题）"><a href="#4-快慢指针（解决有环、对称、中间节点的问题）" class="headerlink" title="4. 快慢指针（解决有环、对称、中间节点的问题）"></a>4. 快慢指针（解决有环、对称、中间节点的问题）</h3><h4 id="4-1-解决是否有环问题"><a href="#4-1-解决是否有环问题" class="headerlink" title="4.1 解决是否有环问题"></a>4.1 解决是否有环问题</h4><p>​    顾名思义即一个走一步，而另一个走两步。<code>low = low.next; fast = fast.next.next;</code></p>
<p>​    注意：</p>
<ol>
<li><code>while (fast != null &amp;&amp; fast.next != null)</code>，在while条件是加个fast.next的判断，<strong>避免null.next情况出现</strong>。</li>
<li><strong>开始最好设置low为一个head，而另一个fast为下一位，这样才能使我们low == fast只在有环时成立</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对head进行入参检验（一个节点或者为null）</span></span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始最好设置一个head，而另一个为下一位，这样才能使我们low == fast只在有环时成立</span></span><br><span class="line">ListNode low = head;</span><br><span class="line">ListNode fast = head.next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (low == fast) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    low = low.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-对称问题（求中间节点，默写）"><a href="#4-2-对称问题（求中间节点，默写）" class="headerlink" title="4.2 对称问题（求中间节点，默写）"></a>4.2 对称问题（求中间节点，默写）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode slow = head;</span><br><span class="line">ListNode fast = head.next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow; <span class="comment">//slow即中间节点</span></span><br></pre></td></tr></table></figure>

<h3 id="5-遍历时该位置的值此前是否被访问过，或者需要用到其余位置的值"><a href="#5-遍历时该位置的值此前是否被访问过，或者需要用到其余位置的值" class="headerlink" title="5. 遍历时该位置的值此前是否被访问过，或者需要用到其余位置的值"></a>5. 遍历时该位置的值此前是否被访问过，或者需要用到其余位置的值</h3><p>​    之前我们在数组时有这种思想采用hash表实现，时间复杂度为O（1）</p>
<p>判断链表是否有环，我们基本上能想到就是快慢指针，但是其实我们<strong>只需遍历一遍判断 某个位置的值此前被访问过 即可判断有环</strong>，因为链表没有索引，所以就用<strong>hash表实现的列表（无重复的值）HashSet。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用hash表实现的列表set进行存储并校验</span></span><br><span class="line">Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">ListNode node = head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// node.next != null没有到尾部，这样做少判断一次</span></span><br><span class="line"><span class="keyword">while</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 该位置的值此前有被访问过就知道有环</span></span><br><span class="line">    <span class="keyword">if</span> (set.contains(node)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该位置的值此前没有被访问过就加入进去</span></span><br><span class="line">    set.add(node);</span><br><span class="line">    node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<h3 id="6-while循环遍历，条件是head-next-null-还是-head-null"><a href="#6-while循环遍历，条件是head-next-null-还是-head-null" class="headerlink" title="6. while循环遍历，条件是head.next != null 还是 head != null"></a>6. while循环遍历，条件是head.next != null 还是 head != null</h3><p>​    主要是看后面循环体里面是否有head的next相关的赋值，保证没有<strong>null.next</strong>。</p>
<p>例如：这里不仅有fast.next而且还有fast.next.next，所以就两个条件都要满足</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">	......</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈、队列"><a href="#栈、队列" class="headerlink" title="栈、队列"></a>栈、队列</h2><h3 id="1-栈实现二叉树非递归遍历"><a href="#1-栈实现二叉树非递归遍历" class="headerlink" title="1.  栈实现二叉树非递归遍历"></a>1.  栈实现二叉树非递归遍历</h3><p>​    非递归进行前序、中序、后序遍历，条件为：<strong>一直向左走，访问左节点，然后回来访问根结点。</strong>所以就可以用栈来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node&lt;E&gt; node = root;</span><br><span class="line">Stack&lt;Node&lt;E&gt;&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="comment">// 循环node = node.left;</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 访问器返回true就停止</span></span><br><span class="line">        <span class="keyword">if</span> (visit(node.element)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有右子节点就入栈</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 右子节点开始遍历</span></span><br><span class="line">        node = stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-单调栈实现某值左右（或者左右其中一个）第一个最值"><a href="#2-单调栈实现某值左右（或者左右其中一个）第一个最值" class="headerlink" title="2. 单调栈实现某值左右（或者左右其中一个）第一个最值"></a>2. 单调栈实现某值左右（或者左右其中一个）第一个最值</h3><p>​    <strong>要通过遍历，使得找到某值左右（或者左右其中一个）的第一个最值，可以使用单调栈，因为临近滴必将必将，弹出栈或者入栈。</strong></p>
<p>例如：找到最大二叉树的每个节点的父节点索引</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (......) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; nums[i] &lt; nums[stack.peek()]) &#123;</span><br><span class="line">        <span class="comment">//nums[i] &lt; 栈中元素，遇见小的了，设置左大</span></span><br><span class="line">        leftIndexes[i] = stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[i] &gt; nums[stack.peek()]) &#123;</span><br><span class="line">        <span class="comment">//nums[i] &gt; 栈中元素，遇见大的了，设置右大</span></span><br><span class="line">        rightIndexes[stack.peek()] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-单调队列实现一段区间内的最大、最小值和排序"><a href="#3-单调队列实现一段区间内的最大、最小值和排序" class="headerlink" title="3. 单调队列实现一段区间内的最大、最小值和排序"></a>3. 单调队列实现一段区间内的最大、最小值和排序</h3><p>​    <strong>要通过遍历，使得比它大（小）的值保留在队列中，小（大）的值删去，所以遍历就保证了单调递减（递增），从而找到这个队列区间的元素的最值。</strong></p>
<p>例：滑动的窗口的最值问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (......) &#123;</span><br><span class="line">    <span class="comment">// 删除队列中索引对应元素值小的</span></span><br><span class="line">    <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt;= nums[i] ) &#123;</span><br><span class="line">        deque.pollLast();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将该索引入队</span></span><br><span class="line">    deque.offerLast(i);</span><br><span class="line">	<span class="comment">//...............................................................</span></span><br><span class="line">    <span class="comment">// 设置最大值</span></span><br><span class="line">    maxes[w] = nums[deque.peekFirst()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>​    二叉搜索树，可以获取<strong>一组排序好的数据</strong>，logn级别。</p>
<h3 id="1-完全二叉树性质"><a href="#1-完全二叉树性质" class="headerlink" title="1. 完全二叉树性质"></a>1. 完全二叉树性质</h3><p>​    完全二叉树的n1要么是0，要么是1（节点按序号排列），则由通用性质：<strong>n = 2n0 + n1 - 1</strong></p>
<ul>
<li>n1为0，则n = 2n0 - 1，n为奇数，叶子节点n0 =（n + 1）/ 2，非叶子节点n1 + n2 = （n - 1）/ 2</li>
<li>n1为1，则n = 2n0，n为偶数，叶子结点n0 = n / 2，非叶子节点n1 + n2 = n / 2</li>
</ul>
<h3 id="2-二叉树遍历应用"><a href="#2-二叉树遍历应用" class="headerlink" title="2. 二叉树遍历应用"></a>2. 二叉树遍历应用</h3><ul>
<li>前序遍历：<strong>树状结构</strong>的展示（注意左右子树的顺序）</li>
<li><strong>中序遍历：二叉搜索树的中序遍历按升序或者降序处理节点</strong></li>
<li>后序遍历：适用于一些先子后父的操作</li>
<li>层序遍历：<strong>计算二叉树的高度，判断一棵树是否为完全二叉树</strong></li>
</ul>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>​    哈希表，不考虑顺序、<strong>不考虑 Key 的可比较性（指的是不需要元素之间有大小顺序，而不是不能判断相等与否）</strong>。</p>
<p><strong>数组实现，典型的空间换时间，</strong>HashMap底层的hash函数。</p>
<p><img src="https://img-blog.csdnimg.cn/20200816214141949.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>​    堆，操作<strong>一个排序好的数据，例如最大值，最小值</strong>，O（1）级别，用数组存放，用二叉搜索树则杀鸡用牛刀。</p>
<h3 id="1-优先队列"><a href="#1-优先队列" class="headerlink" title="1. 优先队列"></a>1. 优先队列</h3><p>​    优先队列，每次<strong>拿取一组数据的最值</strong>（例如：最小的，最大的），所以就可以<strong>采用大顶堆、小顶堆</strong>来实现。</p>
<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p>​    字典树，对一堆<strong>不重复</strong>字符串进行<strong>前缀搜索，效率只跟字符串长度有关</strong>。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>​    各种排序时间复杂度</p>
<p><img src="https://img-blog.csdnimg.cn/20200817171413772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="1-分割区间最好左闭右开-begin-end"><a href="#1-分割区间最好左闭右开-begin-end" class="headerlink" title="1. 分割区间最好左闭右开[begin, end)"></a>1. 分割区间最好左闭右开[begin, end)</h3><p>​    有利于计算区间长度<code>length = end - begin;</code>，保证了mid的取值。</p>
<p>​    例如归并排序中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="comment">// [begin,mid)</span></span><br><span class="line">sort(begin,mid);</span><br><span class="line"><span class="comment">// [mid,end)</span></span><br><span class="line">sort(mid,end);</span><br><span class="line"></span><br><span class="line">merge(begin,mid,end);</span><br></pre></td></tr></table></figure>

<h3 id="2-冒泡排序和插入排序优化"><a href="#2-冒泡排序和插入排序优化" class="headerlink" title="2. 冒泡排序和插入排序优化"></a>2. 冒泡排序和插入排序优化</h3><p>​    冒泡排序：加入endIndex记录<strong>最后一次交换位置（后面的就不用去冒泡了）</strong>，初始值为完全有序时的下标为，即1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> endIndex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt;= end; begin++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cmp(begin,begin - <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        swap(begin,begin - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 记录交换位置</span></span><br><span class="line">        endIndex = begin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">end = endIndex;</span><br></pre></td></tr></table></figure>

<p>​    插入排序（打扑克排序）：时间复杂度与<strong>逆序对</strong>个数成正比</p>
<p>​    优化：</p>
<ol>
<li><strong>（重点）先将待插入的数据备份，挪动前面的元素后，再插入</strong></li>
<li><strong>（进阶）</strong>利用<strong>二分搜索，优化了比较的次数</strong>，但是挪动没变，时间复杂度没变</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt; array.length; begin++) &#123;</span><br><span class="line">    <span class="comment">/*----------------------------------------------------*/</span></span><br><span class="line">    <span class="keyword">int</span> cur = begin;</span><br><span class="line">    <span class="comment">// 数据备份</span></span><br><span class="line">    E element = array[begin];</span><br><span class="line">    <span class="keyword">while</span> (cur &gt; <span class="number">0</span> &amp;&amp; cmp(cur, cur - <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 1.交换</span></span><br><span class="line">        swap(cur, cur - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.将交换改为挪动</span></span><br><span class="line">        array[cur] = array[cur - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// cur减一之后为begin所在的值，依次比较然后插入</span></span><br><span class="line">        cur--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    array[cur] = element;</span><br><span class="line">    <span class="comment">/*----------------------------------------------------*/</span></span><br><span class="line">    <span class="comment">// 3.采用二分搜索进行插入优化</span></span><br><span class="line">    <span class="comment">// 数据备份</span></span><br><span class="line">    E element = array[begin];</span><br><span class="line">    <span class="keyword">int</span> insertIndex = search(begin);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = begin - <span class="number">1</span>; i &gt;= insertIndex; i--) &#123;</span><br><span class="line">        array[i + <span class="number">1</span>] = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    array[insertIndex] = element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-归并排序合并时避免，讨论右结束时左全挪动情况"><a href="#3-归并排序合并时避免，讨论右结束时左全挪动情况" class="headerlink" title="3. 归并排序合并时避免，讨论右结束时左全挪动情况"></a>3. 归并排序合并时避免，讨论右结束时左全挪动情况</h3><p>​    即<code>ri = re</code>时，仍然是左边数组进行搬运，如代码 else块 所示，<code>ri = re</code>时<code>array[ai] = leftArray[li];</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// li le 左新建序列起始，ri re 右序列起始，ai为遍历数组指针</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = li; i &lt; le; i++) &#123;</span><br><span class="line">    <span class="comment">// 重点：左边序列起始是begin + i</span></span><br><span class="line">    leftArray[i] = array[begin + i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左边还没结束</span></span><br><span class="line"><span class="keyword">while</span> (li &lt; le) &#123;</span><br><span class="line">    <span class="comment">// 保证稳定性，且ri = re了，即左边全部挪过去</span></span><br><span class="line">    <span class="keyword">if</span> (ri &lt; re &amp;&amp; cmp(leftArray[li], array[ri]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        array[ai] = array[ri];</span><br><span class="line">        ai++;</span><br><span class="line">        ri++;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        array[ai] = leftArray[li];</span><br><span class="line">        ai++;</span><br><span class="line">        li++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-快排轴点随机设置，优化算法避免两边不均匀"><a href="#4-快排轴点随机设置，优化算法避免两边不均匀" class="headerlink" title="4. 快排轴点随机设置，优化算法避免两边不均匀"></a>4. 快排轴点随机设置，优化算法避免两边不均匀</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 避免出现最坏情况进行优化方案：</span></span><br><span class="line"><span class="comment">// 随机选取一个值与begin位置替换，作为轴点</span></span><br><span class="line"><span class="keyword">int</span> length = end - begin;</span><br><span class="line">swap(begin,begin + (<span class="keyword">int</span>) (Math.random() * length));</span><br><span class="line"></span><br><span class="line">E pivot = array[begin];</span><br></pre></td></tr></table></figure>

<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="1-尽量使用Quick-Union基于路径分裂-路径减半-基于rank优化或者size优化"><a href="#1-尽量使用Quick-Union基于路径分裂-路径减半-基于rank优化或者size优化" class="headerlink" title="1. 尽量使用Quick Union基于路径分裂/路径减半 + 基于rank优化或者size优化"></a>1. 尽量使用Quick Union基于路径分裂/路径减半 + 基于rank优化或者size优化</h3><p>​    实质上：<strong>基于路径分裂/路径减半优化find、基于rank优化或者size优化union</strong></p>
<p>（1）不使用路径压缩是因为虽然树高度降低离谱，<strong>但是成本很高，每个节点都要压缩</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*路径分裂：使每个节点指向祖父即可*/</span></span><br><span class="line"><span class="keyword">if</span> (v != parents[v]) &#123;</span><br><span class="line">    <span class="keyword">int</span> parent = parents[v];</span><br><span class="line">    parents[v] = parents[parent];</span><br><span class="line">    v = parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line"><span class="comment">/*路径减半：跳一个节点指向祖父节点，中间的依然只指向父亲不动*/</span></span><br><span class="line"><span class="keyword">if</span> (v != parents[v]) &#123;</span><br><span class="line">    parents[v] = parents[parents[v]];</span><br><span class="line">    v = parents[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v;</span><br></pre></td></tr></table></figure>

<p>（2）基于rank的优化更好一点，避免数过高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1. 基于size优化，size小的跟随size大的，降低树高度---------*/</span></span><br><span class="line"><span class="keyword">if</span> (sizes[p1] &lt; sizes[p2]) &#123;</span><br><span class="line">    <span class="comment">// v2的根结点赋值给v1的根结点</span></span><br><span class="line">    parents[p1] = p2;</span><br><span class="line">    sizes[p2] += sizes[p1];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// v1的根结点赋值给v2的根结点</span></span><br><span class="line">    parents[p2] = p1;</span><br><span class="line">    sizes[p1] += sizes[p2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2. 基于rank的优化（树的高度）,rank小的跟随rank大的，降低树高度*/</span></span><br><span class="line"><span class="keyword">if</span> (ranks[p1] &lt; ranks[p2]) &#123;</span><br><span class="line">    <span class="comment">// v2的根结点赋值给v1的根结点</span></span><br><span class="line">    parents[p1] = p2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ranks[p1] &gt; ranks[p2])&#123;</span><br><span class="line">    <span class="comment">// v1的根结点赋值给v2的根结点</span></span><br><span class="line">    parents[p2] = p1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 随便选个，然后被指向的要加一层高度</span></span><br><span class="line">    parents[p1] = p2;</span><br><span class="line">    ranks[p2]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>​    一般<code>链表</code>或者<code>二叉树</code>的问题都可以使用递归的思想，因为链表和二叉树的结构，本身就是递归的结构，即二叉树里面还是二叉树。</p>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>​    树和图的DFS就是典型的回溯，而且回溯本质就是使用<strong>递归来实现</strong>，例如八皇后和走迷宫。</p>
<h3 id="1-经典N皇后问题优化"><a href="#1-经典N皇后问题优化" class="headerlink" title="1. 经典N皇后问题优化"></a>1. 经典N皇后问题优化</h3><p>​    回溯 + <strong>剪枝</strong>处理，剪枝即剪去肯定错误的位置时（同一列，在其对角线上），使用三个标记数组来实现。</p>
<p><strong>以空间换时间，不用每次都用O（n）复杂度</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">    <span class="comment">// 剪枝，如果判断不在该列，不在对角线，可以摆</span></span><br><span class="line">    <span class="keyword">if</span> (cols[col]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过行和列计算，所在对角线索引leftIndex 和 rightIndex</span></span><br><span class="line">    <span class="keyword">int</span> leftIndex = n - <span class="number">1</span> - col + row;</span><br><span class="line">    <span class="keyword">int</span> rightIndex = row + col;</span><br><span class="line">    <span class="keyword">if</span> (leftTop[leftIndex] || rightTop[rightIndex]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在第row行第col列摆放皇后</span></span><br><span class="line">    queens[row] = col;</span><br><span class="line">    cols[col] = <span class="keyword">true</span>;</span><br><span class="line">    leftTop[leftIndex] = <span class="keyword">true</span>;</span><br><span class="line">    rightTop[rightIndex] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 继续下一行</span></span><br><span class="line">    place(row + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该行所有都不满足，place（该行）执行完毕，回溯到上一行</span></span><br><span class="line">    <span class="comment">// 刚刚标记的需要重制</span></span><br><span class="line">    cols[col] = <span class="keyword">false</span>;</span><br><span class="line">    leftTop[leftIndex] = <span class="keyword">false</span>;</span><br><span class="line">    rightTop[rightIndex] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    针对特定的数值（例如八皇后）每一位只有两种结果，可以使用位运算来优化（存在为1，不存在为0）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记所有列是否摆放皇后</span></span><br><span class="line"><span class="comment"> * 采用位运算优化，8位二进制数 = byte</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">byte</span> cols;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记所有主对角线是否摆放皇后</span></span><br><span class="line"><span class="comment"> * leftTop[1] = true，则第一条对角线是否摆放皇后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">short</span> leftTop;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记所有副对角线是否摆放皇后</span></span><br><span class="line"><span class="comment"> * rightTop[1] = true，则第一条对角线是否摆放皇后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">short</span> rightTop;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------剪枝操作--------------------------*/</span></span><br><span class="line"><span class="keyword">if</span> ((cols &amp; (<span class="number">1</span> &lt;&lt; col)) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过行和列计算，所在对角线索引leftIndex 和 rightIndex</span></span><br><span class="line"><span class="keyword">int</span> leftIndex = n - <span class="number">1</span> - col + row;</span><br><span class="line"><span class="keyword">int</span> rightIndex = row + col;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((leftTop &amp; (<span class="number">1</span> &lt;&lt; leftIndex)) != <span class="number">0</span> ||</span><br><span class="line">    (rightTop &amp; (<span class="number">1</span> &lt;&lt; rightIndex)) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 摆放</span></span><br><span class="line">cols = (<span class="keyword">byte</span>)(cols | (<span class="number">1</span> &lt;&lt; col));</span><br><span class="line">leftTop = (<span class="keyword">byte</span>)(leftTop | (<span class="number">1</span> &lt;&lt; leftIndex));</span><br><span class="line">rightTop = (<span class="keyword">byte</span>)(rightTop | (<span class="number">1</span> &lt;&lt; rightIndex));</span><br><span class="line"><span class="comment">// 刚刚标记的需要重制</span></span><br><span class="line"><span class="comment">// 01111101 n</span></span><br><span class="line"><span class="comment">//&amp;11111011  ~00000100</span></span><br><span class="line"><span class="comment">// 01111001</span></span><br><span class="line">cols = (<span class="keyword">byte</span>)(cols &amp; ~(<span class="number">1</span> &lt;&lt; col));</span><br><span class="line">leftTop = (<span class="keyword">byte</span>)(leftTop &amp; ~(<span class="number">1</span> &lt;&lt; leftIndex));</span><br><span class="line">rightTop = (<span class="keyword">byte</span>)(rightTop &amp; ~(<span class="number">1</span> &lt;&lt; rightIndex));</span><br></pre></td></tr></table></figure>



<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>​    动态规划一般求解最优问题的一种算法策略，<strong>后面的解与前面的状态有关</strong>，步骤为三步：</p>
<ol>
<li>定义dp[i]的含义</li>
<li>设置初始状态（边界）</li>
<li>确定状态转移方程：dp[i]与dp[i - 1]的关系</li>
</ol>
<h3 id="1-dp-i-对于数组序列来说，一般定为以该值（nums-i-）结尾的满足条件的序列"><a href="#1-dp-i-对于数组序列来说，一般定为以该值（nums-i-）结尾的满足条件的序列" class="headerlink" title="1. dp[i]对于数组序列来说，一般定为以该值（nums[i]）结尾的满足条件的序列"></a>1. dp[i]对于数组序列来说，一般定为以该值（nums[i]）结尾的满足条件的序列</h3><p>​    例如：求最长上升（递增）子序列的长度，dp为以nums[i]结尾的…长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    dp[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> ; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果dp[j] + 1大于上一次赋的值dp[i]</span></span><br><span class="line">            dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取每次循坏的最大值</span></span><br><span class="line">    maxLength = Math.max(dp[i], maxLength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-dp-i-j-还可以是多元的，例如两个数组序列的公共问题"><a href="#2-dp-i-j-还可以是多元的，例如两个数组序列的公共问题" class="headerlink" title="2. dp[i,j]还可以是多元的，例如两个数组序列的公共问题"></a>2. dp[i,j]还可以是多元的，例如两个数组序列的公共问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][nums2.length + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums1.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 前一行和当前行</span></span><br><span class="line">    <span class="keyword">int</span> prevRow = (i - <span class="number">1</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> row = i &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nums2.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            dp[row][j] = dp[prevRow][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果最后一位不相等，则对称判断前面的取最大值</span></span><br><span class="line">            dp[row][j] = Math.max(dp[prevRow][j], dp[row][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">rnang0</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://rnang0.gitee.io/2020/08/10/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0%EF%BC%9Aleetcode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/">http://rnang0.gitee.io/2020/08/10/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0%EF%BC%9Aleetcode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://rnang0.gitee.io" target="_blank">rnang0 Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/leetcode/">leetcode</a></div><div class="post_share"><div class="social-share" data-image="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2864077756,2277292526&amp;fm=26&amp;gp=0.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/09/11/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A09%EF%BC%9ATomcat%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/"><img class="prev_cover" src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2864077756,2277292526&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">春招复习9：Tomcat架构解析</div></div></a></div><div class="next-post pull_right"><a href="/2020/08/03/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A08%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98/"><img class="next_cover" src="https://www.lgstatic.com/i/image2/M01/8A/CA/CgoB5l14rXSAWVk7AAFdi6Ly8iM148.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">春招复习8：数据库与缓存</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By rnang0</div><div class="footer_custom_text">Hi, welcome to my <a href="http://rnang0.github.io/" target="_blank" rel="noopener">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script></body></html>