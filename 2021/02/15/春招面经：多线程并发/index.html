<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>春招面经：多线程并发 | rnang0 Blog</title><meta name="description" content="多线程并发一、Volatile关键字1、Java内存模型JMM 计算机内存模型  ​    由于现在的计算机CPU的指令运行速度 &gt;&gt; 内存的读写速度，所以一般在CPU内部加一层高速缓存，然后CPU将数据复制到缓存中运算，然后再从缓存中同步回主内存。但是需要解决数据一致性问题。   Java内存模型   ​    描述了Java中 各个线程对共享变量 的访问规则，规定了： （1）所以的"><meta name="keywords" content="并发,锁,多线程"><meta name="author" content="rnang0"><meta name="copyright" content="rnang0"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="春招面经：多线程并发"><meta name="twitter:description" content="多线程并发一、Volatile关键字1、Java内存模型JMM 计算机内存模型  ​    由于现在的计算机CPU的指令运行速度 &gt;&gt; 内存的读写速度，所以一般在CPU内部加一层高速缓存，然后CPU将数据复制到缓存中运算，然后再从缓存中同步回主内存。但是需要解决数据一致性问题。   Java内存模型   ​    描述了Java中 各个线程对共享变量 的访问规则，规定了： （1）所以的"><meta name="twitter:image" content="https://img-blog.csdnimg.cn/20201207121521698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70"><meta property="og:type" content="article"><meta property="og:title" content="春招面经：多线程并发"><meta property="og:url" content="http://rnang0.github.io/2021/02/15/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/"><meta property="og:site_name" content="rnang0 Blog"><meta property="og:description" content="多线程并发一、Volatile关键字1、Java内存模型JMM 计算机内存模型  ​    由于现在的计算机CPU的指令运行速度 &gt;&gt; 内存的读写速度，所以一般在CPU内部加一层高速缓存，然后CPU将数据复制到缓存中运算，然后再从缓存中同步回主内存。但是需要解决数据一致性问题。   Java内存模型   ​    描述了Java中 各个线程对共享变量 的访问规则，规定了： （1）所以的"><meta property="og:image" content="https://img-blog.csdnimg.cn/20201207121521698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70"><meta property="article:published_time" content="2021-02-14T16:00:00.000Z"><meta property="article:modified_time" content="2021-02-15T11:58:41.093Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="canonical" href="http://rnang0.github.io/2021/02/15/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/"><link rel="next" title="春招面经：JVM" href="http://rnang0.github.io/2020/12/28/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%EF%BC%9AJVM/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'none',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/autor.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">21</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">41</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-mars"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#多线程并发"><span class="toc-text">多线程并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、Volatile关键字"><span class="toc-text">一、Volatile关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、Java内存模型JMM"><span class="toc-text">1、Java内存模型JMM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、可见性问题"><span class="toc-text">2、可见性问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、Volatile底层如何实现可见性？"><span class="toc-text">3、Volatile底层如何实现可见性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、何为有序性？Volatile底层如何保证有序性？"><span class="toc-text">4、何为有序性？Volatile底层如何保证有序性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、Volatile无法保证原子性"><span class="toc-text">5、Volatile无法保证原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、Volatile与Synchronized的区别"><span class="toc-text">6、Volatile与Synchronized的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、Java锁机制"><span class="toc-text">二、Java锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、Java的锁机制"><span class="toc-text">1、Java的锁机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、Java对象结构"><span class="toc-text">2、Java对象结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、乐观锁"><span class="toc-text">三、乐观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、说一说CAS吧！"><span class="toc-text">1、说一说CAS吧！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、CAS如何保证线程安全？"><span class="toc-text">2、CAS如何保证线程安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、原子类底层的实现？"><span class="toc-text">3、原子类底层的实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、CAS存在的问题"><span class="toc-text">4、CAS存在的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、悲观锁"><span class="toc-text">四、悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、JVM层面的锁：synchronized"><span class="toc-text">1、JVM层面的锁：synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1、为什么说synchronized是重量级锁"><span class="toc-text">1.1、为什么说synchronized是重量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2、说说Java6之后锁升级的过程？"><span class="toc-text">1.2、说说Java6之后锁升级的过程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3、synchronized具有可重入性、不可中断性"><span class="toc-text">1.3、synchronized具有可重入性、不可中断性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4、双重校验锁实现对象单例"><span class="toc-text">1.4、双重校验锁实现对象单例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、API层面的锁：Lock"><span class="toc-text">2、API层面的锁：Lock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1、说说synchronized与Lock的区别"><span class="toc-text">2.1、说说synchronized与Lock的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2、说说AQS吧，谈谈对它的理解"><span class="toc-text">2.2、说说AQS吧，谈谈对它的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3、synchronized与Reentrantlock的区别"><span class="toc-text">2.3、synchronized与Reentrantlock的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4、Semaphore与ReentrantLock的区别"><span class="toc-text">2.4、Semaphore与ReentrantLock的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、ThreadLocal"><span class="toc-text">五、ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、ThreadLocal常见的使用场景？"><span class="toc-text">1、ThreadLocal常见的使用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、ThreadLocal实现原理"><span class="toc-text">2、ThreadLocal实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、ThreadLocal-和-ThreadLocalMap-的关系"><span class="toc-text">3、ThreadLocal 和 ThreadLocalMap 的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、ThreadLocalMap-的底层结构（重点）"><span class="toc-text">4、ThreadLocalMap 的底层结构（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1、底层实现时什么结构？"><span class="toc-text">4.1、底层实现时什么结构？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2、如何解决hash冲突？"><span class="toc-text">4.2、如何解决hash冲突？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、ThreadLocal-实例存放在堆内存嘛？"><span class="toc-text">5、ThreadLocal 实例存放在堆内存嘛？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、ThreadLocal-为什么会有内存泄露问题？（重点）"><span class="toc-text">6、ThreadLocal 为什么会有内存泄露问题？（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、为什么key要设计成弱引用？不是找麻烦嘛？"><span class="toc-text">7、为什么key要设计成弱引用？不是找麻烦嘛？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、线程池"><span class="toc-text">六、线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、能说说线程池（池化技术）的好处吗？"><span class="toc-text">1、能说说线程池（池化技术）的好处吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、线程实现Runnable接口和Callable接口的区别"><span class="toc-text">2、线程实现Runnable接口和Callable接口的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、说一说执行execute-方法和submit-方法的区别是什么呢？"><span class="toc-text">3、说一说执行execute()方法和submit()方法的区别是什么呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、如何规范且优雅的创建线程池？"><span class="toc-text">4、如何规范且优雅的创建线程池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、说一说线程池的拒绝策略吧！（重要）"><span class="toc-text">5、说一说线程池的拒绝策略吧！（重要）</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://img-blog.csdnimg.cn/20201207121521698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">rnang0 Blog</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-mars"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">春招面经：多线程并发</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-02-15 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2021-02-15</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-02-15 19:58:41"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-02-15</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E7%BB%8F/">面经</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="多线程并发"><a href="#多线程并发" class="headerlink" title="多线程并发"></a>多线程并发</h1><h2 id="一、Volatile关键字"><a href="#一、Volatile关键字" class="headerlink" title="一、Volatile关键字"></a>一、Volatile关键字</h2><h3 id="1、Java内存模型JMM"><a href="#1、Java内存模型JMM" class="headerlink" title="1、Java内存模型JMM"></a>1、Java内存模型JMM</h3><ul>
<li>计算机内存模型</li>
</ul>
<p>​    由于现在的计算机<strong>CPU的指令运行速度 &gt;&gt; 内存的读写速度</strong>，所以一般在<strong>CPU内部加一层高速缓存，</strong>然后CPU<strong>将数据复制到缓存中运算，然后再从缓存中同步回主内存。</strong>但是需要解决数据一致性问题。</p>
<p><img src="https://img-blog.csdnimg.cn/20201208162113371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>Java内存模型</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200723213613452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt=""></p>
<p>​    描述了Java中 <strong>各个线程对共享变量</strong> 的访问规则，规定了：</p>
<p>（1）所以的共享资源（类变量，实例）都存储在主内存</p>
<p>（2）每个线程都有自己的<strong>工作内存，保留了工作副本，</strong>线程对共享变量的操作，都只能在工作内存中进行</p>
<p><strong>（3）线程间不能访问对方的工作内存，线程间值传递只能通过主内存进行中转。</strong></p>
<p>从而引发了可见性问题，即不加锁的情况下，当前线程对共享变量进行操作时，不知道此值是否为最新。</p>
<h3 id="2、可见性问题"><a href="#2、可见性问题" class="headerlink" title="2、可见性问题"></a>2、可见性问题</h3><p>​    解决可见性问题，主要解决<strong>线程间共享变量及时更新</strong>的问题。</p>
<p>解决办法：</p>
<ul>
<li><strong>1. 加锁</strong></li>
</ul>
<p>​    这种方法最简单粗暴，其中一个线程在工作内存中操作完毕后，写回主内存时才释放锁，其他线程从一直阻塞再开始操作，这样肯定是最新值。</p>
<ul>
<li><strong>2. Volatile修饰共享变量</strong></li>
</ul>
<p>​    使用Volatile来修饰这个共享变量，就能实现：</p>
<p>其中一个线程修改共享变量后，写回主线程时，其余线程都能“知道”，使得<strong>工作内存中的拷贝值失效（此次操作失败），重新从主存获取值，此时肯定是最新。</strong></p>
<h3 id="3、Volatile底层如何实现可见性？"><a href="#3、Volatile底层如何实现可见性？" class="headerlink" title="3、Volatile底层如何实现可见性？"></a>3、Volatile底层如何实现可见性？</h3><p>​    Volatile 底层会<strong>触发一次lock前缀指令，锁定这块内存</strong>，然后进行一次<strong>缓存一致性原则MESI</strong>。</p>
<ul>
<li>MESI：缓存一致性原则：</li>
</ul>
<p>​    当CPU在对 共享变量 进行写操作时，必须马上写回到主存中，然后<strong>其他CPU通过总线嗅探机制监听总线，监听到修改后，工作内存中的值实现，重新触发一次内存的 read， load，use操作。</strong></p>
<h3 id="4、何为有序性？Volatile底层如何保证有序性？"><a href="#4、何为有序性？Volatile底层如何保证有序性？" class="headerlink" title="4、何为有序性？Volatile底层如何保证有序性？"></a>4、何为有序性？Volatile底层如何保证有序性？</h3><ul>
<li><strong>指令重排序</strong></li>
</ul>
<p>​    <strong>一般来说，编译器为了提升程序运行效率，可能会改变代码的执行顺序，但会保证单线程结果与预期结果一致。</strong></p>
<p>所以为了保证多线程下，结果一致，就必须<strong>禁止指令重排序</strong>。</p>
<ul>
<li><strong>有序性</strong></li>
</ul>
<p>​    顾名思义，程序按照代码的先后顺序执行。<strong>有序性通常也指的是happen-before原则</strong>。</p>
<p>happen-before，我觉得就是按照控制流执行，按部就班。其中<strong>Volatile变量规则：对Volatile域的写操作，后序所以线程的读操作都可见</strong>。</p>
<ul>
<li><strong>Volatile通过禁止指令重排序来保证有序性</strong></li>
</ul>
<p>​    具体做法：会插入<code>内存屏障</code>，禁止重排序。</p>
<h3 id="5、Volatile无法保证原子性"><a href="#5、Volatile无法保证原子性" class="headerlink" title="5、Volatile无法保证原子性"></a>5、Volatile无法保证原子性</h3><p>​    因为Volatile的<code>lock前缀指令</code>会触发总线嗅探，<strong>可能使其他线程一次结果失效</strong>，这样就会导致结果有误。</p>
<p>​    例如多线程操作Volatile变量i++，可能会导致加的次数不变，但是结果变少。</p>
<p>​    如果想要保住原子性，如何操作？</p>
<ul>
<li><p>加锁，简单粗暴，直接在代码块加上synchronized关键字</p>
</li>
<li><p>使用<strong>原子类</strong></p>
<p>将共享变量类型使用原子类进行操作，底层使用的是CAS。</p>
</li>
</ul>
<h3 id="6、Volatile与Synchronized的区别"><a href="#6、Volatile与Synchronized的区别" class="headerlink" title="6、Volatile与Synchronized的区别"></a>6、Volatile与Synchronized的区别</h3><ul>
<li>Volatile可以保住可见性、有序性，但是无法保证原子性。而synchronized都可以保证</li>
<li>Volatile只能修饰变量，而synchronized是修饰方法、代码块的。</li>
<li>最重要的一点：<strong>Volatile可以看做轻量级的synchronized，</strong>当多线程<strong>只进行读操作、或者赋值</strong>的操作，没有其他操作就<strong>可以使用Volatile进行代替</strong>，保证线程安全。</li>
</ul>
<h2 id="二、Java锁机制"><a href="#二、Java锁机制" class="headerlink" title="二、Java锁机制"></a>二、Java锁机制</h2><h3 id="1、Java的锁机制"><a href="#1、Java的锁机制" class="headerlink" title="1、Java的锁机制"></a>1、Java的锁机制</h3><ul>
<li>引入锁的原因</li>
</ul>
<p>​    多线程对同一共享变量进行操作时，<strong>可能会造成数据不一致（JMM决定）</strong>的问题，则需要对资源进行锁定来防止其他线程操作使得结果不一致。</p>
<ul>
<li><strong>Java的锁机制</strong></li>
</ul>
<p>​    多线程进行操作<strong>Java堆对象、方法区（类信息、常量、类变量）</strong>这些<strong>线程共享</strong>的数据时，会存在异常。</p>
<h3 id="2、Java对象结构"><a href="#2、Java对象结构" class="headerlink" title="2、Java对象结构"></a>2、Java对象结构</h3><p>​    在JVM中，对象由 <code>对象头、数据、填充字节</code>，重点看看对象头。</p>
<p><strong>对象头：以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针，指向方法区中的类信息）。</strong></p>
<p>​    我们重点来看看mark word字段：</p>
<p><img src="https://img-blog.csdnimg.cn/20201209093705261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p><strong>无锁：</strong></p>
<p><strong>无锁状态时，存储的是对象的hashcode值。</strong></p>
</li>
<li><p><strong>偏向锁：</strong></p>
<p>偏向锁时，<strong>前23位存储偏向的线程ID</strong>，并将倒数第三位置为1，表示偏向锁。</p>
</li>
<li><p><strong>轻量级锁：</strong></p>
<p>轻量级锁时，存储的是 <strong>指向JVM栈中的锁记录Lock Record的指针</strong></p>
</li>
<li><p><strong>重量级锁：</strong></p>
<p>当自旋次数超过10次时，将转换成重量级锁，重量级锁存储的是 <strong>指向重量级锁Monitor的指针</strong></p>
</li>
</ul>
<h2 id="三、乐观锁"><a href="#三、乐观锁" class="headerlink" title="三、乐观锁"></a>三、乐观锁</h2><p>​    乐观锁其实不是锁，<strong>我们想要不锁定资源，也能进行线程同步。</strong></p>
<h3 id="1、说一说CAS吧！"><a href="#1、说一说CAS吧！" class="headerlink" title="1、说一说CAS吧！"></a>1、说一说CAS吧！</h3><p>​    CAS：<code>compare and swap</code>比较并且交换，是<code>乐观锁</code>的一种实现的，JUC很多工具类都是基于CAS的。</p>
<p><strong>注意：底层比较和交换是原子的</strong></p>
<h3 id="2、CAS如何保证线程安全？"><a href="#2、CAS如何保证线程安全？" class="headerlink" title="2、CAS如何保证线程安全？"></a>2、CAS如何保证线程安全？</h3><p>​    线程在操作变量时不会进行加锁，在<strong>准备写回主存时，先去查询原值是否被修改，若无修改则写回，若被修改则此次操作失效重新read到工作内存操作。</strong></p>
<h3 id="3、原子类底层的实现？"><a href="#3、原子类底层的实现？" class="headerlink" title="3、原子类底层的实现？"></a>3、原子类底层的实现？</h3><p>​    <strong>其实原子类就可以看成实现了乐观锁。</strong>原子类型底层是 <strong>Volatile + CAS</strong> 实现，例如整型数据</p>
<p><strong>（1）Value用Valatile修饰</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure>

<p><strong>（2）方法调用底层的Unsafe类的方法（基于CAS实现）</strong></p>
<p>例如：自增方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用Unsafe类的getAndAddInt方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层是用CAS实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、CAS存在的问题"><a href="#4、CAS存在的问题" class="headerlink" title="4、CAS存在的问题"></a>4、CAS存在的问题</h3><ul>
<li><strong>一直自旋</strong></li>
</ul>
<p>do-while循环一直执行的话，<strong>CPU一直空转，开销大。</strong></p>
<ul>
<li><strong>ABA问题</strong></li>
</ul>
<p>（1）线程1读取了A，线程2也读取了A</p>
<p>（2）线程2通过CAS将A改成了B，但同时线程3进来了，通过CAS将B改成了A</p>
<p>（3）最后<strong>线程1发现数据是A，CAS没有错，则写成了自己要改的值</strong>，虽然结果正确但我们<strong>还是要将此次的CAS判错。</strong></p>
<p><strong>解决方案：加一个标志位，或者版本号。</strong></p>
<p>标志位：操作一次就加1，判断是否为0，版本号同理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update table set value &#x3D; newValue ，vision &#x3D; vision + 1 where value &#x3D; #&#123;oldValue&#125; and vision &#x3D; #&#123;vision&#125; </span><br><span class="line">&#x2F;&#x2F; 判断原来的值和版本号是否匹配，中间有别的线程修改，值可能相等，但是版本号100%不一样</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>只能保证一个变量保持原子性</strong></li>
</ul>
<p>CAS操作多个数据就不行了，<strong>底层只能保证一个数据的比较 + 交换操作。</strong></p>
<p>可以使用<strong>原子引用AtomicReference</strong>来保证对象之间的原子性，<strong>把多个对象放入CAS中操作。</strong></p>
<h2 id="四、悲观锁"><a href="#四、悲观锁" class="headerlink" title="四、悲观锁"></a>四、悲观锁</h2><h3 id="1、JVM层面的锁：synchronized"><a href="#1、JVM层面的锁：synchronized" class="headerlink" title="1、JVM层面的锁：synchronized"></a>1、JVM层面的锁：synchronized</h3><p>​    <code>synchronized</code>是<strong>JVM层面</strong>的悲观锁，JVM什么都帮我们做了。</p>
<p>​    使用<code>synchronized</code>关键字来实现线程的同步，可以对<code>对象、方法、代码块</code>进行同步。</p>
<p>底层：使用了Monitor保证了<strong>同一时间只允许一个线程操作数据。</strong></p>
<ul>
<li><strong>对象</strong></li>
</ul>
<p>​    同步对象时，对象的<strong>对象头中Mark Word字段有指向Monitor的指针，如果Monitor被某个线程持有，则owner部分会指向该线程。</strong></p>
<ul>
<li><strong>方法</strong></li>
</ul>
<p>​    同步方法时，通过<strong>在字节码中设置ACC_SYNCHRONIZED标志位（底层隐式调用monitor来实现同步的），</strong>其他线程发现方法中有标志位时，就会阻塞。</p>
<ul>
<li><strong>代码块</strong></li>
</ul>
<p>​    同步代码块时，通过<code>monitorenter 和 monitorexit</code>实现的。<strong>（底层依赖OS的mutex lock原语）</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20201209104356106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="1-1、为什么说synchronized是重量级锁"><a href="#1-1、为什么说synchronized是重量级锁" class="headerlink" title="1.1、为什么说synchronized是重量级锁"></a>1.1、为什么说synchronized是重量级锁</h4><p>​    因为synchronized来同步线程，涉及到<strong>Java线程的挂起和唤醒操作</strong>，而Java线程实际上是映射了OS的线程，所以同步时就会涉及到<strong>OS的内核态与用户态的切换。</strong>这样的操作显然是重量级的，所以Java6之后对synchronized进行了优化。</p>
<h4 id="1-2、说说Java6之后锁升级的过程？"><a href="#1-2、说说Java6之后锁升级的过程？" class="headerlink" title="1.2、说说Java6之后锁升级的过程？"></a>1.2、说说Java6之后锁升级的过程？</h4><ul>
<li><strong>synchronized的优化</strong></li>
</ul>
<p>由于synchronized是<strong>重量级锁，耗费资源</strong>，所以进行优化。</p>
<p><strong>优化方法：无锁状态到有锁状态，引入锁升级机制。</strong></p>
<ul>
<li><strong>锁升级</strong></li>
</ul>
<p>锁分类是按照<strong>控制粒度层面</strong>划分：</p>
<p><img src="https://img-blog.csdnimg.cn/20201209105217646.png" alt="在这里插入图片描述"></p>
<p><strong>注意：锁升级过程不可逆。（都是synchronized一个关键字，内部实现不同罢了）</strong></p>
<p>（1）无锁</p>
<p>​    开始阶段，资源例如对象<strong>还没有被锁定</strong>，所有线程都能访问这一资源，<strong>Mark Word存放对象的hashcode值</strong>。</p>
<p>（2）偏向锁</p>
<p>​    一旦有线程锁定了这个对象，<strong>Mark Word标志位修改为1</strong>，就进入偏向模式，同时会把这个<strong>线程的ID记录在对象的Mark Word中。</strong></p>
<p>这个过程是CAS来实现：每次<strong>同一线程进入，虚拟机就不进行任何同步的操作了，对标志位+1就好了</strong>，不是则CAS会失败，也就意味着获取锁失败。</p>
<p>​    <strong>注：当发现不只一个线程来操作对象时，偏向锁升级为轻量级锁。</strong></p>
<p>（3）轻量级锁</p>
<p>​    当线程进入时，<strong>会进行CAS尝试，会拷贝Mark Word在线程对应的JVM栈中生成Lock Record空间，里面有owner指针，指向了当前对象</strong>，此时就实现了绑定，说明加锁成功，则<strong>在Mark Word字段中增加指向栈中的锁记录的指针。</strong></p>
<ul>
<li><p>自旋</p>
<p>其他线程进入时，发现<strong>CAS不成功，就会进行自旋（CPU空轮询）等待</strong>，一直等待资源被释放，避免了挂起操作耗费资源。</p>
</li>
</ul>
<p>但自旋会使cpu一直轮询占用，所以<strong>当自旋个数超过CPU一半、或者自旋次数超过10次就升级为重量级锁。</strong></p>
<p>（4）重量级锁</p>
<p>​    使用<strong>monitor</strong>来实现线程的同步。参考前面的synchronized悲观锁。</p>
<h4 id="1-3、synchronized具有可重入性、不可中断性"><a href="#1-3、synchronized具有可重入性、不可中断性" class="headerlink" title="1.3、synchronized具有可重入性、不可中断性"></a>1.3、synchronized具有可重入性、不可中断性</h4><ul>
<li><strong>（1）可重入性</strong></li>
</ul>
<p>synchronized锁对象的时候，就会有一个<strong>计数器（该线程获取锁的次数）</strong>，获取时就+1 ，执行完后计数器 -1，清零表示释放掉锁。</p>
<p>​    <strong>作用：避免了死锁</strong></p>
<ul>
<li><strong>（2）不可中断性</strong></li>
</ul>
<p>该线程通过synchronized锁住对象时，<strong>其余的线程获取资源的话会被阻塞、或者等待。该线程不释放，其余线程就一直阻塞、等待，不可以被中断。</strong></p>
<p><strong>注意：Lock的tryLock方法是可以被中断的。</strong></p>
<h4 id="1-4、双重校验锁实现对象单例"><a href="#1-4、双重校验锁实现对象单例" class="headerlink" title="1.4、双重校验锁实现对象单例"></a>1.4、双重校验锁实现对象单例</h4><p>​    问题： uniqueInstance = new Singleton(); 这段代码，在多线程环境下会导致一个线程获得还没有初始化的实例。</p>
<p>​    <strong>例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</strong></p>
<p>​    uniqueInstance 采用 volatile 关键字修饰很重要，保证了<strong>可见性，有序性（防止指令重排）</strong>保证在多线程环境下也能正常运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、API层面的锁：Lock"><a href="#2、API层面的锁：Lock" class="headerlink" title="2、API层面的锁：Lock"></a>2、API层面的锁：Lock</h3><p>​    Lock是一个接口，是<strong>API层面</strong>的锁。需要lock()和unlock()来获取和释放锁。</p>
<p>​    <strong>意义：提供了区别于synchronized的另一种具有更多广泛操作的同步方式，支持更灵活的结构，可以关联多个Condition对象。</strong></p>
<h4 id="2-1、说说synchronized与Lock的区别"><a href="#2-1、说说synchronized与Lock的区别" class="headerlink" title="2.1、说说synchronized与Lock的区别"></a>2.1、说说synchronized与Lock的区别</h4><ul>
<li><p><strong>synchronized是关键字，是JVM层面的锁，而Lock是个接口，是API层面的锁</strong></p>
</li>
<li><p>synchronized会自动释放锁，而Lock必须手动释放锁unlock()</p>
</li>
<li><p><strong>synchronized是非公平锁，Lock公平锁和非公平锁都有实现</strong></p>
</li>
<li><p>synchronized是不可被中断的，<strong>Lock可以中断也可以不被中断。（阻塞 -&gt; 中断阻塞）</strong></p>
</li>
<li><p>Lock可以通过<code>boolean tryLock();</code>方法可以知道线程是否拿到锁，synchronized不能。</p>
</li>
<li><p>synchronized能锁住方法和代码块，<strong>Lock只能锁住代码块</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line"><span class="comment">//同步方法</span></span><br><span class="line"><span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    	e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    String name = Thread.currentThread().getName();</span><br><span class="line">    System.out.println(name + <span class="string">"正在卖"</span> + ticket--);</span><br><span class="line">&#125;</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用Lock的读锁子类来提高多线程读效率</p>
</li>
</ul>
<h4 id="2-2、说说AQS吧，谈谈对它的理解"><a href="#2-2、说说AQS吧，谈谈对它的理解" class="headerlink" title="2.2、说说AQS吧，谈谈对它的理解"></a>2.2、说说AQS吧，谈谈对它的理解</h4><p>​    AQS是<code>抽象队列同步器</code>，我的理解：它是一个<strong>通过CAS来对竞争资源进行同步管理的框架。</strong></p>
<ul>
<li>实现思想</li>
</ul>
<ol>
<li><strong>利用CAS 和 Volatile 原子的修改共享标志位state，</strong>值为1 时表示有线程占用，因为有<code>独占和共享</code>两种模式，所以设置成<strong>int类型</strong>。</li>
<li><strong>维护一个等待队列，实现未获取到资源进行等待的队列</strong></li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20181128142923147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L211bGluc2VuNzc=,size_16,color_FFFFFF,t_70" alt=""></p>
<h4 id="2-3、synchronized与Reentrantlock的区别"><a href="#2-3、synchronized与Reentrantlock的区别" class="headerlink" title="2.3、synchronized与Reentrantlock的区别"></a>2.3、synchronized与Reentrantlock的区别</h4><ul>
<li>两者都是<strong>独占、可重入锁</strong></li>
<li><strong>synchronized依赖于JVM，而ReentrantLock依赖于API</strong>，实现了Lock接口，<strong>内部sync是继承自AQS</strong></li>
<li>ReentrantLock多一些特性，例如<strong>可中断、可以实现公平锁、实现选择通知可以创建多个Condition对象。</strong></li>
</ul>
<p>可中断：通过<code>lockInterruptibly()</code>方法实现，正在等待的线程可以中断等待</p>
<p>synchronized 与 <code>wait</code> 和 <code>notify / notifyAll</code>实现<code>等待 / 通知</code>，而ReentrantLock通过Condition（对象监视器）来实现，<strong>线程注册到Condition上，有选择性的通知线程。</strong></p>
<h4 id="2-4、Semaphore与ReentrantLock的区别"><a href="#2-4、Semaphore与ReentrantLock的区别" class="headerlink" title="2.4、Semaphore与ReentrantLock的区别"></a>2.4、Semaphore与ReentrantLock的区别</h4><ul>
<li>synchronized 和 ReentrantLock 都是<strong>独占锁</strong>，一次只允许一个线程访问某个资源。</li>
<li>Semaphore(信号量)是<strong>共享锁</strong>，允许多个线程同时访问，可以指定<strong>同一时间，资源可被访问的线程数量，一般用于流量控制。</strong></li>
</ul>
<h2 id="五、ThreadLocal"><a href="#五、ThreadLocal" class="headerlink" title="五、ThreadLocal"></a>五、ThreadLocal</h2><p><strong>使用目的：</strong></p>
<p>​    我们创建的变量，多线程情况可能被其他线程访问修改。当我们想要<strong>一个线程专属的本地变量时，能够做到数据的隔离，就需要ThreadLocal。</strong></p>
<h3 id="1、ThreadLocal常见的使用场景？"><a href="#1、ThreadLocal常见的使用场景？" class="headerlink" title="1、ThreadLocal常见的使用场景？"></a>1、ThreadLocal常见的使用场景？</h3><p><strong>一般用于的场景：</strong></p>
<p>（1）数据库操作时，主要用于隔离，使得<strong>每个线程使用的都是一个数据库连接。</strong></p>
<p>（2）Web项目，例如一些user或者token、cookie之类的<strong>用户信息需要跨越若干层方法传递</strong>，每个方法加一个user（token、cookie）很麻烦</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    getInfo(user);</span><br><span class="line">    checkInfo(user);</span><br><span class="line">    setSomeThing(user);</span><br><span class="line">    log(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用ThreadLocal将<strong>信息和线程绑定</strong>改进：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">threadLocalUser.set(user);</span><br><span class="line">getInfo();</span><br><span class="line">checkInfo();</span><br><span class="line">setSomeThing();</span><br><span class="line"><span class="comment">// 各层内部获取</span></span><br><span class="line">threadLocalUser.get();</span><br></pre></td></tr></table></figure>

<h3 id="2、ThreadLocal实现原理"><a href="#2、ThreadLocal实现原理" class="headerlink" title="2、ThreadLocal实现原理"></a>2、ThreadLocal实现原理</h3><p>​    <strong>实际上每个Thread，内部都维护了一个ThreadLocalMap类型的变量threadsLocals，这样每次创建一个绑定线程的ThreadLocal时，就存入线程的threadLocals中。</strong></p>
<p>注意：<strong>threadlocals和inheritableThreadLocals初始化为null</strong>，直到创建threadlocal时，才创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * InheritableThreadLocal values pertaining to this thread. This map is</span></span><br><span class="line"><span class="comment"> * maintained by the InheritableThreadLocal class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>拓展：inheritableThreadLocals 可以设置ThreadLocal成线程共享。</p>
<h3 id="3、ThreadLocal-和-ThreadLocalMap-的关系"><a href="#3、ThreadLocal-和-ThreadLocalMap-的关系" class="headerlink" title="3、ThreadLocal 和 ThreadLocalMap 的关系"></a>3、ThreadLocal 和 ThreadLocalMap 的关系</h3><ul>
<li>ThreadLocalMap 是 ThreadLocal 的一个静态内部类</li>
<li><strong>创建与线程绑定的本地变量ThreadLocal时，实际上是先初始化ThreadLocalMap ，然后将ThreadLocal存进去。</strong></li>
<li>ThreadLocalMap 是个Map结构，但<strong>不是实现Map接口</strong>，<strong>key是ThreadLocal，而Value是ThreadLocal set的值</strong>，所以内部维护多个ThreadLocal。</li>
</ul>
<h3 id="4、ThreadLocalMap-的底层结构（重点）"><a href="#4、ThreadLocalMap-的底层结构（重点）" class="headerlink" title="4、ThreadLocalMap 的底层结构（重点）"></a>4、ThreadLocalMap 的底层结构（重点）</h3><p>​    先来撕一撕源码发现：</p>
<ul>
<li>它<strong>并未实现Map接口</strong></li>
<li>他的<strong>Entry是继承WeakReference（弱引用）</strong></li>
<li>没有HashMap中的next，所以<strong>不存在链表</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1、底层实现时什么结构？"><a href="#4-1、底层实现时什么结构？" class="headerlink" title="4.1、底层实现时什么结构？"></a>4.1、底层实现时什么结构？</h4><p>​    ThreadLocalMap 没有采用map接口，而是使用的<strong>Entry数组存储</strong>多个ThreadLocal值。</p>
<p>插入过程中，根据<strong>ThreadLocal对象的hash值（int i = key.threadLocalHashCode &amp; (len-1)），定位到table中的索引位置。</strong></p>
<h4 id="4-2、如何解决hash冲突？"><a href="#4-2、如何解决hash冲突？" class="headerlink" title="4.2、如何解决hash冲突？"></a>4.2、如何解决hash冲突？</h4><p>​    先看看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"><span class="comment">// 相等就直接返回，不相等就继续查找，找到相等位置。</span></span><br><span class="line"><span class="keyword">if</span> (k == key)</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">    expungeStaleEntry(i);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    i = nextIndex(i, len);</span><br><span class="line">e = tab[i];</span><br></pre></td></tr></table></figure>

<ul>
<li><p>索引位置有值时，<strong>判断key即ThreadLocal是否相同，相同就更新。</strong></p>
</li>
<li><p>索引位置有值时，key不同，则hash冲突时，<code>i = nextIndex(i, len);</code>，即<strong>key不等于entry</strong>，那就找下一个空位置，直到为空为止</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2020121020195786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="5、ThreadLocal-实例存放在堆内存嘛？"><a href="#5、ThreadLocal-实例存放在堆内存嘛？" class="headerlink" title="5、ThreadLocal 实例存放在堆内存嘛？"></a>5、ThreadLocal 实例存放在堆内存嘛？</h3><p>​    虽然线程私有的都是放在JVM栈中，但是<strong>ThreadLocal的实例以及其值还是存放在堆中，</strong>通过一些技巧将可见性修改成了线程可见。</p>
<h3 id="6、ThreadLocal-为什么会有内存泄露问题？（重点）"><a href="#6、ThreadLocal-为什么会有内存泄露问题？（重点）" class="headerlink" title="6、ThreadLocal 为什么会有内存泄露问题？（重点）"></a>6、ThreadLocal 为什么会有内存泄露问题？（重点）</h3><ul>
<li><p>弱引用：一定回收</p>
<p>弱引用的对象，<strong>不管当前内存空间足够与否，都会回收它的内存。</strong></p>
</li>
</ul>
<p>​    ThreadLocalMap中的Entry类，他继承了WeakReference弱引用，使得<strong>key被设计成WeakReference弱引用。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>内存泄露问题</strong></p>
<p>如果创建ThreadLocal的线程一直持续运行，那么这个<strong>Entry对象中的value不置为null，就一直得不到回收，发生内存泄露。</strong></p>
</li>
</ul>
<p>例如：<strong>线程池</strong>里面的线程，<strong>线程本来就是复用的，value没有被回收，则下一次复用仍然没有被回收，导致内存泄露。</strong></p>
<ul>
<li>解决：最后使用<code>remove</code>方法，将<strong>所有value对象置为null</strong>即可。<strong>netty的fastThreadLocal</strong>来弥补问题。</li>
</ul>
<h3 id="7、为什么key要设计成弱引用？不是找麻烦嘛？"><a href="#7、为什么key要设计成弱引用？不是找麻烦嘛？" class="headerlink" title="7、为什么key要设计成弱引用？不是找麻烦嘛？"></a>7、为什么key要设计成弱引用？不是找麻烦嘛？</h3><p>​    不这样做其实就会导致，<strong>如果最后不把key即ThreadLocal置null，也会跟value一样，发生内存泄露问题。</strong></p>
<h2 id="六、线程池"><a href="#六、线程池" class="headerlink" title="六、线程池"></a>六、线程池</h2><h3 id="1、能说说线程池（池化技术）的好处吗？"><a href="#1、能说说线程池（池化技术）的好处吗？" class="headerlink" title="1、能说说线程池（池化技术）的好处吗？"></a>1、能说说线程池（池化技术）的好处吗？</h3><ul>
<li><strong>降低资源的消耗：</strong>避免频繁的创建和销毁线程造成的消耗。</li>
<li><strong>提高了响应速度：</strong>任务<strong>不需要等待</strong>线程创建。</li>
<li><strong>增强了线程的可管理性：</strong>使用线程池可以进行<strong>统一的分配，调优和监控。</strong></li>
</ul>
<h3 id="2、线程实现Runnable接口和Callable接口的区别"><a href="#2、线程实现Runnable接口和Callable接口的区别" class="headerlink" title="2、线程实现Runnable接口和Callable接口的区别"></a>2、线程实现Runnable接口和Callable接口的区别</h3><ul>
<li>使用Callable接口创建线程<strong>会返回结果</strong>，但是<strong>一般的任务不需要返回结果 / 抛出异常，所以为了简洁起见，就使用Runnable。</strong></li>
<li>Runnable一直都存在，而<strong>Callable是1.5引入的。</strong></li>
<li>工具类Executors，可以实现两者的转换。</li>
</ul>
<h3 id="3、说一说执行execute-方法和submit-方法的区别是什么呢？"><a href="#3、说一说执行execute-方法和submit-方法的区别是什么呢？" class="headerlink" title="3、说一说执行execute()方法和submit()方法的区别是什么呢？"></a>3、说一说执行execute()方法和submit()方法的区别是什么呢？</h3><ul>
<li>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被执行。</li>
<li>submit()，线程池会返回Future对象，通过<strong>Future来判断任务是否执行成功</strong>。<code>Future</code> 的 <code>get()</code>方法来获取返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.submit实际上也是先创建一个绑定的Future对象，然后调用execute方法</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="function">thrownew <span class="title">NullPointerException</span><span class="params">()</span></span>;</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 3.执行execute()方法</span></span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.上面方法调用的 newTaskFor 方法返回了一个 FutureTask 对象。</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、如何规范且优雅的创建线程池？"><a href="#4、如何规范且优雅的创建线程池？" class="headerlink" title="4、如何规范且优雅的创建线程池？"></a>4、如何规范且优雅的创建线程池？</h3><ul>
<li><p><strong>为什么不使用Executors</strong> </p>
<p>《阿里巴巴Java开发手册》中<strong>强制线程池不允许使用 Executors 去创建</strong>，而是<strong>通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20201212101827631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>因为Executors创建，实际上就是调用<code>ThreadPoolExecutor</code>的方法，且<strong>可能堆积大量的请求，或者堆积大量的线程，从而导致OOM。</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用 ThreadPoolExecutor 创建</strong></li>
</ul>
<p><code>ThreadPoolExecutor</code>构造函数重要参数分析</p>
<p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>
<ul>
<li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了<strong>最小可以同时运行的线程数量。</strong></li>
<li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务<strong>达到队列容量</strong>的时候，<strong>当前可以同时运行的线程数量变为最大线程数。</strong></li>
<li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数:</p>
<ol>
<li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li>
<li><strong><code>handler</code></strong> :拒绝策略。</li>
</ol>
<h3 id="5、说一说线程池的拒绝策略吧！（重要）"><a href="#5、说一说线程池的拒绝策略吧！（重要）" class="headerlink" title="5、说一说线程池的拒绝策略吧！（重要）"></a>5、说一说线程池的拒绝策略吧！（重要）</h3><ul>
<li><strong>何时采用拒绝策略</strong></li>
</ul>
<p>如果当前<strong>同时运行的线程数量达到最大线程数量</strong>并且<strong>等待队列也已经被放满</strong>了</p>
<ul>
<li><strong>拒绝策略种类：</strong></li>
</ul>
<ol>
<li>默认抛出异常</li>
<li><strong>调用线程来执行，它喜欢增加队列容量，降低任务的提交速度，影响性能。</strong></li>
<li>拒绝</li>
<li><strong>丢弃最早执行的线程请求</strong></li>
</ol>
<ul>
<li><strong>高峰结束</strong></li>
</ul>
<p>高峰期过去，<strong>超过corePoolSize的那部分线程</strong>长时间没有task任务做，<strong>则结束释放资源</strong>。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">rnang0</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://rnang0.github.io/2021/02/15/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/">http://rnang0.github.io/2021/02/15/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://rnang0.github.io" target="_blank">rnang0 Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a><a class="post-meta__tags" href="/tags/%E9%94%81/">锁</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post_share"><div class="social-share" data-image="https://img-blog.csdnimg.cn/20201207121521698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/12/28/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%EF%BC%9AJVM/"><img class="next_cover" src="https://img-blog.csdnimg.cn/2021012409181395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">春招面经：JVM</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/06/23/春招复习4：操作系统/" title="春招复习4：操作系统"><img class="relatedPosts_cover" src="https://img-blog.csdnimg.cn/20200624114032370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-23</div><div class="relatedPosts_title">春招复习4：操作系统</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/25/春招复习7：Java并发/" title="春招复习7：Java并发"><img class="relatedPosts_cover" src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=4060513360,1461496884&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-25</div><div class="relatedPosts_title">春招复习7：Java并发</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/13/春招复习6：JVM/" title="春招复习6：JVM"><img class="relatedPosts_cover" src="https://img-blog.csdnimg.cn/20200718152358438.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-13</div><div class="relatedPosts_title">春招复习6：JVM</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By rnang0</div><div class="footer_custom_text">Hi, welcome to my <a href="http://rnang0.github.io/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script></body></html>